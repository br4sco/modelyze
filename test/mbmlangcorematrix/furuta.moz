include MBMLANGVISUALMATRIX

def world, f1, f2, f3, f4, f5, f6: Frame
def Jd = (1., 2., 3.)
def m = 1.
def l = 1.
def th01 = 0.
def u1 = (1., 0., 0.)
def th02 = PI / 2.
def u2 = (0., 1., 0.)

def xm11, xm12, xm13: Real
def xm1 = mkVector3 xm11 xm12 xm13

def xm21, xm22, xm23: Real
def xm2 = mkVector3 xm21 xm22 xm23

def qm11, qm12, qm13, qm14: Real
def qm1 = mkQuaternion qm11 qm12 qm13 qm14

def qm21, qm22, qm23, qm24: Real
def qm2 = mkQuaternion qm21 qm22 qm23 qm24

def qr1 = mkQuaternion ()
def qr2 = mkQuaternion ()
def qr3 = mkQuaternion ()

def model =
            sphericalJoint world f1;
            revoluteJoint zhat xhat yhat world f1;
            torqueActuator (mkVector3 0. 0. 2.) world f1;
            rigidArm (-l, 0., 0.) qr1 world f1 f2;
            body m Jd xm1 qm1 world f2;
            gravity m world f2;
            rigidArm (l, 0., 0.) qr2 world f3 f2;
            sphericalJoint f3 f4;
            revoluteJoint ((mkR qm1) * xhat) ((mkR qm1) * yhat) ((mkR qm1) * zhat) f3 f4;
            rigidArm (-l, 0., 0.) qr3 world f4 f5;
            body m Jd xm2 qm2 world f5;
            gravity m world f5;
            // qr1 ~== qm1;
            // qr2 ~== qm1;
            // qr3 ~== qm2;
            qm11 <- 1.;
            // qm1 ~== mkQuaternion (ea2quat th01 u1);
            qm2 ~== mkQuaternion (ea2quat th02 u2)
            // qm2 ~== M2q ((q2M (mkQuaternion (ea2quat (PI / 2.) (0., 0., -1.)))) * (q2M (mkQuaternion (ea2quat (PI / 4.) (0., -1., 0.)))))

def _ = elaborateToFile (equationsElement model ++ visualElement xm1 qm1 (visualAxes 1.) ++ visualElement xm2 qm2 (visualAxes 1.))
