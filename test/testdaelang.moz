/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include daelang

def simple_assert(pred: Bool) = {
  if pred then println("OK!") else println("Fail! ");
}

def print_expected_actual(expected: ?, actual: ?) -> () = {
  def _ = println("== expected:");
  def _ = dprint(expected);
  def _ = println("== actual:");
  dprint(actual)
}

// def f = fun x: <Real> -> undefined

// def test_setvalue = {
//   def _ = println("==> Start test case setvalue");
//   def x, y: Real;
//   def fp = (set_value f x 10.);
//   def _ = simple_assert((fp x) == 10.);
//   println("==> End test case setvalue")
// }

// def test_is_undefined = {
//   def _ = println("==> Start test case is_undefined");
//   def x, y: Real;
//   def fp = (set_value f x 10.);
//   def _ = simple_assert(is_undefined (fp y));
//   println("==> End test case is_undefined")
// }

def test_M_m_eq = {
  def _ = println("==> Start test case M_m_eq");
  def x, y: Real;
  def m = x = y;
  def (E, _, _) = M_m m ((Set.empty), (Map.empty), (Set.empty));
  def _ = simple_assert (Set.mem m E);
  println("==> End test case M_m_eq")
}

def test_M_m_init = {
  def _ = println("==> Start test case M_m_init");
  def x: Real;
  def sigma = M_m (init x 1.) ((Set.empty), (Map.empty), (Set.empty));
  // test multiple inits with the same value
  def sigma = M_m (init x 1.) sigma;
  def (_, fp, _) = sigma;
  def (b, r) = (Map.find x fp);
  def _ = simple_assert b;
  def _ = simple_assert (r == 1.);
  // Calls below should throw errors
  // def _ = M_m (init x 2.) sigma;
  println("==> End test case M_m_init")
}

def test_M_m_init_guess = {
  def _ = println("==> Start test case M_m_init_guess");
  def x: Real;
  def sigma = M_m (init_guess x 1.) ((Set.empty), (Map.empty), (Set.empty));
  // test multiple init_guesss with the same value
  def sigma = M_m (init_guess x 1.) sigma;
  def (_, fp, _) = sigma;
  def (b, r) = (Map.find x fp);
  def _ = simple_assert (!b);
  def _ = simple_assert (r == 1.);
  // Calls below should throw errors
  // def _ = M_m (init_guess x 2.) sigma;
  println("==> End test case M_m_init_guess")
}

def test_M_m_init_over_guess = {
  def _ = println("==> Start test case M_m_init_over_guess");
  def x: Real;
  def sigma = M_m (init_guess x 1.) ((Set.empty), (Map.empty), (Set.empty));
  // test multiple inits with the same value
  def sigma = M_m (init x 2.) sigma;
  def (_, fp, _) = sigma;
  def (b, r) = (Map.find x fp);
  def _ = simple_assert b;
  def _ = simple_assert (r == 2.);
  // Calls below should throw errors
  // def _ = M_m (init x 2.) sigma;
  println("==> End test case M_m_init_over_guess")
}

def test_M_m_nil = {
  def _ = println("==> Start test case M_m_nil");
  def x: Real;
  def sigma = M_m (init x 1.) ((Set.empty), (Map.empty), (Set.empty));
  // test multiple inits with the same value
  def sigma = M_m nil sigma;
  def (_, fp, _) = sigma;
  def (b, r) = (Map.find x fp);
  def _ = simple_assert b;
  def _ = simple_assert (r == 1.);
  println("==> End test case M_m_nil")
}

def test_elabtopol = {
  def _ = println("==> Start test case elabtopol");
  def n1, n2, n3, n4: Real;
  def f12, f23, f34, f41: Real;
  def e12, e23, e34, e41: Real;
  def circ = ((Branch f12 e12 n1 n2);
    (Branch f23 e23 n2 n3);
    (Branch f34 e34 n3 n4);
    (Branch f41 e41 n4 n1);
    (RefBranch f41 e41 n4));
  def actual = elabtopol (cont_to_set circ);
  def expected = "{e12_1 = u_1 - u_2;\ne23_1 = u_2 - u_3;\ne34_1 = u_3 - u_4;\ne41_1 = u_4 - u_1, f12_1 - f41_1 = 0, -f12_1 + f23_1 = 0, -f23_1 + f34_1 = 0, -f34_1 + f41_1 + f41_1 = 0, e41_1 = u_4}";
  def _ = print_expected_actual expected actual;
  println("==> End test case elabtopol")
}
