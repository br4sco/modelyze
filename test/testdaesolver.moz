/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Equation
//include DAESolver

type Residual = Real -> {Real} -> {Real} -> [Real]
type Varvals = <Real> -> <Real>

// General expression evaluation
def eval(expr:<?>, yy:Varvals, yp:Varvals) -> ? = {
    match expr with
    | der x ->
        (match x with
         | sym:Real -> eval(yp(x), yy, yp)
         | _ -> error "Derivatives only allowed on unknowns")
    | sym:Real -> eval(yy(expr), yy, yp)
    | f e -> (eval(f,yy,yp)) (eval(e,yy,yp))
    | lift v:? -> v
    | _ ->  error "Unsupported model construct"
}

// Evaluate an expression of real type. The unknowns in the
// expression are looked up in yy and yp arrays.
def evalFromArray(expr:Expr, ukmap:UkMap, yy:{Real}, yp:{Real}) -> Real = {
  def yyfun(s:Signal) -> Signal = {Array.get yy (fst(Map.find s ukmap))};
  def ypfun(s:Signal) -> Signal = {Array.get yp (fst (Map.find s ukmap))};
  eval(expr,yyfun,ypfun);
}

// Create the residual function of the DAE. Used by IDA/Sundials.
def makeResidual(ukmap:UkMap, model:Equations, ctime:Real, yy:{Real}, yp:{Real}) -> [Real] = {
  def realExpr(expr:Expr) = evalFromArray(expr,ukmap,yy,yp);
  def traverseEq(m:Equations,acc:[Real]) -> [Real] = {
    match m with
    | e1 ; e2 -> traverseEq(e2,traverseEq(e1,acc))
    | e1 = e2 -> (realExpr(e1) - realExpr(e2))::acc
    | _ -> acc
  };
  traverseEq(model,[]);
}

//Generate arrays of initial values
def makeInitValues(model:Equations, ukmap:UkMap) -> ({Real},{Real}) = {
  def initvalmap = initValues(model);
  def size = (Map.size ukmap);
  def yy = (Array.make size 0.);
  def yp = (Array.make size 0.);
  def setvals(initvals:[(Signal,Signal)]) -> {Real} = {
    match initvals with
    | (u,e)::xs -> {
        def v = (match e with
                 | lift v:Real -> v
                 | _ -> error "Cannot initialize a variable with a variable.");
        def _ = (Array.set yy (fst (Map.find u ukmap)) v);
        setvals xs;
      }
    | [] -> yy
  };
  (setvals(Map.toList initvalmap), yp)
}

def initConditionCorrection(ukmap:UkMap) -> {Real} = {
  def id = {Array.make (Map.size ukmap) 0.};
  def worker(uklist:[(Signal,(Int,Bool))]) -> {Real} = {
    match uklist with
    | (u,(i,true))::us -> {
         def _ = (Array.set id i 1.0);
         worker us;
      }
    | _::us -> worker us
    | [] -> id
  };
  worker (Map.toList ukmap);
}

def makeRootFun(expr: [Expr], ukm: UkMap, t: Real, yy: {Real}, yp: {Real}) -> [Real] = {
  def f = (fun e: Expr -> evalFromArray e ukm yy yp);
  map expr f
}

def modelp(x: <Real>, y: <Real>) -> Equations = {
  init x 1.;
  init y 1.;
  der x = x;
  x + y = 1.
}

def main = {
  def x,y: Real;
  def m = modelp(x, y);
  def ukm = makeUkMap(m);
  def (yy, yp) = makeInitValues(m, ukm);
  def ic = initConditionCorrection(ukm);
  def resf = makeResidual(ukm,m);
  def rootf = makeRootFun [x - 2.] ukm;
  def t0 = 0.0;
  // def s = (DAESolver.init resf t0 yy yp);
  def s = (DAESolver.init_with_rootf resf 1 rootf t0 yy yp);
  def _ = dprint(yy);
  def _ = (DAESolver.calc_ic_ya_ydp s ic yy yp 0.1);
  def _ = dprint(yy);
  def res = (DAESolver.solve_normal s (t0 + 2.) yy yp);
  def _ = dprint(res);
  dprint(yy)
}
