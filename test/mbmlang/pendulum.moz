include Pendulum_Common

// Unkowns
def x_m, y_m, z_m: Real
def vx_m, vy_m, vz_m: Real
def Fx_m, Fy_m, Fz_m: Real
def fi_m, th_m, ps_m: Real
def omx_m, omy_m, omz_m: Real
def Tx_m, Ty_m, Tz_m: Real
def x_g, y_g, z_g: Real
def Fx_g, Fy_g, Fz_g: Real
def x_h, y_h, z_h: Real
def Fx_h, Fy_h, Fz_h: Real
def x_r1, y_r1, z_r1: Real
def Fx_r1, Fy_r1, Fz_r1: Real
def fi_r1, th_r1, ps_r1: Real
def Tx_r1, Ty_r1, Tz_r1: Real
def fi_r2, th_r2, ps_r2: Real
def Tx_r2, Ty_r2, Tz_r2: Real

// // === 2D ===
// def r_m = mkVector(x_m, y_m)
// def v_m = mkVector(vx_m, vy_m)
// def F_m = mkVector(Fx_m, Fy_m)
// def om_m = mkScalar(omz_m)
// def T_m = mkScalar(Tz_m)

// def r_g = mkVector(x_g, y_g)
// def F_g = mkVector(Fx_g, Fy_g)

// def r_h = mkVector(x_h, y_h)
// def F_h = mkVector(Fx_h, Fy_h)

// def r_r1 = mkVector(x_r1, y_r1)
// def F_r1 = mkVector(Fx_r1, Fy_r1)
// def F_r1_2 = F_r1
// def T_r1 = mkScalar(Tz_r1)
// def T_r2 = mkScalar(Tz_r2)
// def T_r2_2 = T_r2

// // 2D rotation
// def R_r1 = R_p fi_r1
// def R_r2 = R_p fi_r2
// def R_m = R_r2 // From topological equations

// def th_r1 = mkScalar(fi_r1)

// def dth_r2 = mkScalar(fi_r2')
// def dth_m = dth_r2 // From topological equations

// def gg = mkVector(z, g)
// def r = mkVector(u, z)
// def SSM = skewsym_p (R_r2 * r)

// // === 3D with 2D rotation ===
// def r_m = mkVector(x_m, y_m, z_m)
// def v_m = mkVector(vx_m, vy_m, vz_m)
// def F_m = mkVector(Fx_m, Fy_m, Fz_m)
// def om_m = mkVector(omx_m, omy_m, omz_m)
// def T_m = mkVector(Tx_m, Ty_m, Tz_m)

// def r_g = mkVector(x_g, y_g, z_g)
// def F_g = mkVector(Fx_g, Fy_g, Fz_g)

// def r_h = mkVector(x_h, y_h, z_h)
// def F_h = mkVector(Fx_h, Fy_h, Fz_h)

// def r_r1 = mkVector(x_r1, y_r1, z_r1)
// def F_r1 = mkVector(Fx_r1, Fy_r1, Fz_r1)
// def F_r1_2 = mkVector(Fx_r1, Fy_r1)
// def T_r1 = mkVector(Tx_r1, Ty_r1, Tz_r1)
// def T_r2 = mkVector(Tx_r2, Ty_r2, Tz_r2)
// def T_r2_2 = mkScalar(Tz_r2)

// // rotation
// def R_r1 = R_z fi_r1
// def R_r2 = R_z fi_r2
// def R_m = R_r2 // From topological equations

// def th_r1 = mkScalar(fi_r1)

// def dth_r2 = mkVector(z, z, fi_r2')
// def dth_m = dth_r2 // From topological equations

// def gg = mkVector(z, g, z)
// def r = mkVector(u, z, z)
// def SSM = skewsym_p (R_r2 * r)

// === 3D with 2.5D rotation ===
def r_m = mkVector(x_m, y_m, z_m)
def v_m = mkVector(vx_m, vy_m, vz_m)
def F_m = mkVector(Fx_m, Fy_m, Fz_m)
def om_m = mkVector(omx_m, omy_m, omz_m)
def T_m = mkVector(Tx_m, Ty_m, Tz_m)

def r_g = mkVector(x_g, y_g, z_g)
def F_g = mkVector(Fx_g, Fy_g, Fz_g)

def r_h = mkVector(x_h, y_h, z_h)
def F_h = mkVector(Fx_h, Fy_h, Fz_h)

def r_r1 = mkVector(x_r1, y_r1, z_r1)
def F_r1 = mkVector(Fx_r1, Fy_r1, Fz_r1)
def F_r1_2 = mkVector(Fx_r1, Fy_r1, Fz_r1)
def T_r1 = mkVector(Tx_r1, Ty_r1, Tz_r1)
def T_r2 = mkVector(Tx_r2, Ty_r2, Tz_r2)
def T_r2_2 = mkVector(Tx_r2, Ty_r2, Tz_r2)

// rotation
def R_r2 = R_zxz fi_r2 th_r2 ps_r2
def R_m = R_r2 // From topological equations

def R_r1 = mkVector(fi_r1, th_r1, ps_r1)

def dth_r2 = mkVector(
                      th_r2' * cos fi_r2 + ps_r2' * sin fi_r2 * sin th_r2,
                      -th_r2' * sin fi_r2 + ps_r2' * cos fi_r2 * sin th_r2,
                      fi_r2' + ps_r2' * cos th_r2
                     )
def dth_m = dth_r2 // From topological equations

def gg = mkVector(z, g, z)
def r = mkVector(u, z, z)
def SSM = skewsym (R_r2 * r)

def body = [
  r_m' - v_m,
  v_m' - F_m,
  dth_m - om_m,
  om_m' - T_m
]

def gravity = [
  F_g - gg
]

def joint = [
  r_h
]

def arm = [
  r_r1 + R_r2 * r,
  R_r1,
  T_r2_2 + SSM * F_r1_2
]

def ttopol = [
  r_h - r_r1 - r_m,
  r_g - r_m,
  F_m + F_g + F_h,
  F_r1 - F_h
]

def rtopol = [
  // th_r2 - th_m, We substitute this rather than formulating the across equation directly
  T_r1,
  T_m + T_r2
]

def model = concat [
                   body
                   , gravity
                   , joint
                   , arm
                   , ttopol
                   , rtopol
                   ]

// def _ = iter (fun M: MatrixMapSReal -> def _ = dp M; ()) model
def rs = concat (concat (map (fun M: MatrixMapSReal -> matrixToList M) model))
def _ = writeFile MODEL_FILENAME (exportModelica "Pendulum" rs (listToMap [
                                                                            (fi_r2, (0., false)),
                                                                            (th_r2, (0., false)),
                                                                            (ps_r2, (0., false))
                                                                          ]))
