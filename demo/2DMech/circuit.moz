/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include EquationsFormulation

def ii_V, uu_V, ii_R, uu_R, ii_L, uu_L: Vector
def i_V, i_R, u_R, i_L, u_L: Real
def V, R, L: Real
def n1, n2, n3, n4: Node

def uvM = listToMatrix [[1.]] (mmSRealZero (1, 1))

def VS(n1: Node, n2: Node) = {
def ii_V, uu_V: Vector;
def i_V: Real;
def V: Real;
(
  ((n1, [(unitVector, uvM)]), (n2, [(unitVector, uvM)])),
  [
    (uu_V, V *. unitVector)
    , (ii_V, i_V *. unitVector)
  ],
  [(uu_V, [])],
  [(ii_V, [unitVector])]
)
}

def RS(n1: Node, n2: Node) = {
def ii_R, uu_R: Vector;
def i_R, u_R: Real;
def R: Real;
(
  ((n1, [(unitVector, uvM)]), (n2, [(unitVector, uvM)])),
  [
    (uu_R, R *. ii_R)
    , (ii_R, i_R *. unitVector)
  ],
  [(uu_R, [])],
  [(ii_R, [unitVector])]
)
}

def RS2(n1: Node, n2: Node) = {
def ii_R, uu_R: Vector;
def i_R, u_R: Real;
def R: Real;
(
  ((n1, [(unitVector, uvM)]), (n2, [(unitVector, uvM)])),
  [
    (uu_R, u_R *. unitVector)
    , (ii_R, (1. / R) *. uu_R)
  ],
  [(uu_R, [unitVector])],
  [(ii_R, [])]
)
}

def RS3(n1: Node, n2: Node) = {
def ii_R, uu_R: Vector;
def i_R, u_R: Real;
def R: Real;
(
  ((n1, [(unitVector, uvM)]), (n2, [(unitVector, uvM)])),
  [
    (uu_R, R *. ii_R)
    , (ii_R, (1. / R) *. uu_R)
  ],
  [(uu_R, [])],
  [(ii_R, [])]
)
}

def LS(n1: Node, n2: Node) = {
def ii_L, uu_L: Vector;
def i_L: Real;
def L: Real;
(
  ((n1, [(unitVector, uvM)]), (n2, [(unitVector, uvM)])),
  [
    (uu_L, L *. der ii_L)
    , (ii_L, i_L *. unitVector)
  ],
  [(uu_L, [])],
  [(ii_L, [unitVector])]
)
}

def CS(n1: Node, n2: Node) = {
def ii_C, uu_C: Vector;
def u_C: Real;
def C: Real;
(
  ((n1, [(unitVector, uvM)]), (n2, [(unitVector, uvM)])),
  [
    (ii_C, C *. der uu_C)
    , (uu_C, u_C *. unitVector)
  ],
  [(uu_C, [unitVector])],
  [(ii_C, [])]
)
}

def RC = [
          (VS n1 n2), (RS2 n3 n1), (CS n2 n3)
          // (CS n2 n3), (RS3 n3 n1), (VS n1 n2)
          // (VS n1 n2), (CS n2 n3), (RS2 n3 n1)
          // (VS n1 n2), (RS n3 n1), (CS n2 n3) //Fail: AccThrSpace is null space
         ]

def LLCCC =
[
  // (CS n3 n4), (CS n4 n2), (CS n4 n1), (LS n1 n2), (LS n2 n3)
  (CS n3 n4), (LS n2 n3), (CS n4 n2), (CS n4 n1), (LS n1 n2) // Fail
]

def i_1, j_1, i_2, j_2, k: Vector
def r_m, F_m, t_m, T_m: Vector
def r_g, F_g, t_g, T_g: Vector
def rx_m, ry_m, tk_m: Real
def rx_g, ry_g, tk_g: Real
def Fx_m, Fy_m, Tk_m: Real
def Fx_g, Fy_g, Tk_g: Real
def m, g, I: Real
def n_m1, n_m2: Node

def iM = tr (listToMatrix [[1., 0.]] (mmSRealZero (1, 2)))
def jM = tr (listToMatrix [[0., 1.]] (mmSRealZero (1, 2)))
def kM = tr (listToMatrix [[1.]] (mmSRealZero (1, 1)))

// def mkRoM(o: <Real>) = {
//   listToMatrix [
//                 [cos o, -sin o],g
//                 [sin o, cos o]
//                ] (mmSRealZero (2, 2))
// }

// def mkTrM(rx: <Real>, ry: <Real>) = {
//   listToMatrix [
//                 [rx],
//                 [ry]
//                ] (mmSRealZero (2, 1))
// }

// def mkTM(o: <Real>, rx: <Real>, ry: <Real>) = {
//   def R = mkRoM o;
//   def T = mkTrM rx ry;
//   hconcat (vconcat R T) (listToMatrix [[0., 0., 1.]] (mmSRealZero (1, 3)))
// }

// def mkTMInv(o: <Real>, rx: <Real>, ry: <Real>) = {
//   def R = mkRoM o;
//   def T = mkTrM rx ry;
//   hconcat (vconcat (tr R) (-T)) (listToMatrix [[0., 0., 1.]] (mmSRealZero (1, 3)))
// }

def BD = [[
            (
             ((n_m2, [(i_2, iM), (j_2, jM), (k, kM)]), (n_m1, [(i_1, iM), (j_1, jM), (k, kM)])),
             [(F_g, (m * g) *. j_2), (r_g, rx_g *. i_2 + ry_g *. j_2)],
             [(r_g, [i_2, j_2])],
             [(F_g ,[])]
            )
            ,
            (
             ((n_m1, [(i_1, iM), (j_1, jM), (k, kM)]), (n_m2, [(i_2, iM), (j_2, jM), (k, kM)])),
             [(F_m, m *. r_m''), (r_m, rx_m *. i_1 + ry_m *. j_1)],
             [(r_m, [i_1, j_1])],
             [(F_m ,[])]
            )
          ],
          [
            (
             ((n_m2, [(i_2, iM), (j_2, jM), (k, kM)]), (n_m1, [(i_1, iM), (j_1, jM), (k, kM)])),
             [(T_m, I *. t_m''), (t_m, tk_m *. k)],
             [(t_m, [k])],
             [(T_m ,[])]
            )
            ,
            (
             ((n_m2, [(i_2, iM), (j_2, jM), (k, kM)]), (n_m1, [(i_1, iM), (j_1, jM), (k, kM)])),
             [(T_g, zeroVector), (t_g, tk_g *. k)],
             [(t_g, [k])],
             [(T_g ,[])]
            )
         ]]

def main = {
  // def _ = dprint(getSpaceMap [RL]);
  // def _ = dprint(getSpaceMap BD);
  // def _ = formulateRes [RC];
  def _ = formulateRes [LLCCC];
  // def _ = formulateRes BD;
  // def _ = dprint(getBasesToMatrixMap BD);
  ()
}
