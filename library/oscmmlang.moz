/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include OSCLANGHelpers
include GraphElaboration

def nilp: () -> Equations
def pre: <Real> -> <Real>
def sw: Equations -> (() -> ?) -> <Bool> -> Equations

def evalReal(e: <Real>, vm: VMap) -> Real = {
  def llog = logger "evalReal" DEBUG;
  def _ = llog "expr" e;
  def _ = llog "variable map" vm;
  def v = evalRealFromVMap e vm;
  def _ = llog "evals to:" v;
  v
}

def evalBool(e: <Bool>, vm: VMap) -> Bool = {
  def llog = logger "evalBool" DEBUG;
  def _ = llog "expr" e;
  def _ = llog "variable map" vm;
  def b = evalBoolFromVMap e vm;
  def _ = llog "evals to:" b;
  b
}

def stable(es: Equations, vm: VMap) -> Bool = {
  def llog = logger "stable";
  match es with
  | e_1; e_2 -> (stable e_1 vm) && (stable e_2 vm)
  | d_1 = d_2 -> true
  | init _ _ -> true
  | Branch _ _ _ _ -> true
  | sw es_1 _ r -> (evalBool r vm) && (stable es_1 vm)
  | nilp _ -> true
  | _ -> unmatched llog es
}

def elabsws(es: Equations, vm: VMap) -> Equations = {
  def llog = logger "elabsws";
  match es with
  | e_1; e_2 -> (elabsws e_1 vm); (elabsws e_2 vm)
  | d_1 = d_2 -> es
  | init _ _ -> es
  | Branch _ _ _ _ -> es
  | sw es_1 (lift es_2: (() -> ?)) r -> {
      if evalBool r vm then sw (elabsws es_1 vm) es_2 r
      else es_2 ()
    }
  | nilp _ -> es
  | _ -> unmatched llog es
}

def evalinits(es: Equations, vm: VMap) -> VMap = {
  def llog = logger "evalinits";
  match es with
  | e_1; e_2 -> evalinits e_1 (evalinits e_2 vm)
  | d_1 = d_2 -> vm
  | init x v ->
      if !(isDefined vm x) then add x (evalReal v vm) vm else vm
  | Branch _ _ _ _ -> vm
  | sw es_1 _ _ -> (evalinits es_1 vm)
  | nilp _ -> vm
  | _ -> unmatched llog es
}

def elabtopol(es: Equations) -> Set(Equations) = {
  def llog = logger "elabtopol";
  def work(es: Equations, T: Set(?)) -> Set(?) = {
    match es with
    | e_1; e_2 -> work e_1 (work e_2 T)
    | d_1 = d_2 -> T
    | init x v -> T
    | Branch _ _ _ _ -> (Set.add es T)
    | sw es_1 _ _ -> (work es_1 T)
    | nilp _ -> T
    | _ -> unmatched llog es
  };

  elaboratetopology (work es (Set.empty))
}

def gathereqs(es: Equations) -> Set(Equations) = {
  def work(es: Equations, E: Set(Equations)) -> Set(Equations) = {
    def llog = logger "gathereqs";
    match es with
    | e_1; e_2 -> work e_1 (work e_2 E)
    | d_1 = d_2 -> (Set.add es E)
    | init x v -> E
    | Branch _ _ _ _ -> E
    | sw es_1 _ _ -> (work es_1 E)
    | nilp _ -> E
    | _ -> unmatched llog es
  };

  work es (Set.empty)
}

def gatherregs(es: Equations) -> Set(<Bool>) = {
  def work(es: Equations, P: Set(<Bool>)) -> Set(<Bool>) = {
    def llog = logger "gatherregs";
    match es with
    | e_1; e_2 -> work e_1 (work e_2 P)
    | d_1 = d_2 -> P
    | init x v -> P
    | Branch _ _ _ _ -> P
    | sw es_1 _ p -> (work es_1 (Set.add p P))
    | nilp _ -> P
    | _ -> unmatched llog es
  };

  work es (Set.empty)
}

def evalpres(E: Set(Equations), vm: VMap) -> Set(Equations) = {
  def llog = logger "evalpres";
  def work(e: Equations) -> Equations = {
    def workharder(ee: <?>) -> <?> = {
      match ee with
      | pre x -> evalReal x vm
      | f ee_1 -> (workharder f) (workharder ee_1)
      | _ -> ee
    };

    match e with
    | e_1 = e_2 -> (workharder e_1) = (workharder e_2)
    | _ -> unmatched llog e
  };

  listToSet (map work (Set.toList E))
}

def gatherIEulerDefEquations(E: Set(Equations), ll: VMap) -> Set(Equations) = {
  def llog = logger "gatherIEulerDefEquations";

  def work(acc: Set(Equations), e: Equations) -> Set(Equations) = {
    match e with
    | e_1 = e_2 ->
      if (isIEDerDefined ll e_1) && (isIEDerDefined ll e_2) then (Set.add e acc)
      else acc
    | _ -> unmatched llog e
  };

  foldLeft work (Set.empty) (Set.toList E)
}

def mapToImplEuler(E: Set(Equations), ll: VMap, h: Real) -> Set(Equations) = {
  def llog = logger "mapToBEuler";

  def work(e: Equations) -> Equations = {
    def workharder(ee: <?>) -> <?> = {
      match ee with
      | der x -> (x - (evalReal x ll)) / h
      | f ee_1 -> (workharder f) (workharder ee_1)
      | _ -> ee
    };

    match e with
    | e_1 = e_2 -> (workharder e_1) = (workharder e_2)
    | _ -> unmatched llog e
  };

  listToSet (map work (Set.toList E))
}

def addIEDerApprox(vm0: VMap, vm1: VMap, h: Real) -> VMap = {
  def f(a: VMap, e: (<Real>, Real)) -> VMap = {
    def (x, _) = e;
    if (isDefined vm0 x) && (isDefined vm1 x) then
      add (der x) (((find x vm1) - (find x vm0)) / h) a
    else a
  };

  foldLeft f vm1 (Map.toList vm1)
}

def impulseApprox(E: Set(Equations), ll: VMap, rl: VMap, h: Real) -> VMap = {
  def IEDE = gatherIEulerDefEquations E ll;
  def EIE = mapToImplEuler IEDE ll h;
  def nrl = solveNLEQ EIE rl 0.;
  nrl
}

def ivApprox(E: Set(Equations), dia: VMap, h: Real) -> VMap = {
  def IEDE = gatherIEulerDefEquations E dia;
  def EIE = mapToImplEuler IEDE dia (-h);
  def iva = solveNLEQ EIE dia 0.;
  iva
}

def elaborate(m: Equations) -> Set(Equations) = {
  def E = gathereqs m;
  def Et = elabtopol m;
  union E Et
}

def combineImpIVApp(imp: VMap, iva: VMap, ii: (<Real> -> Bool)) -> VMap = {
  def big_number = INFINITE;
  def big_neg_number = NEG_INFINITE;

  def f(e: (<Real>, Real)) -> (<Real>, Real) = {
    def getinf(v: Real) -> Real = {
      if v > 0. then big_number else big_neg_number
    };
    def (x, v) = e;
    if ii x then (x, getinf v) else (x, find x iva)
  };

  listToMap (map f (Map.toList imp))
}

def isImpulse(ll: VMap, dia: VMap, rla: VMap, h: Real, k: Real, x: <Real>) -> Bool = {
  def llog = logger "isImpulse" DEBUG;

  def d(x: <Real>) -> Real = {
    if (isDefined ll x) && (isDefined dia x) && (isDefined rla x) then
      abs ((find x ll) + 2. * (find x dia) - (find x rla)) / h^2.
    else 0.
  };

  def f(e: (<Real>, Real)) -> Real = {
    def (x, _) = e;
    d(x)
  };

  def avg = k * (sum (map f (Map.toList dia))) / int2real ((Map.size dia) + 1);

  def _ = llog "var" x;
  def _ = llog "d2" (d x);
  def _ = llog "avg" avg;

  (d x) > avg
}
