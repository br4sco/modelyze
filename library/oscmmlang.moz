/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include OSCLANGHelpers
include GraphElaboration

def pre: <Real> -> <Real>
def sw: Equations -> (() -> ?) -> <Bool> -> Equations

def unmatched(llog: ((Int, String) -> String -> Dyn), pat: Dyn) = {
  def _ = llog INFO "Pattern:" pat;
  error "Unmatched pattern"
}

def indexred(E: Set(Equations)) -> Set(Equations) = {
  def llog = logger "indexred" TRACE;
  def _ = llog "before ir" (setToCont E);
  def (Ep, dmap) = indexReducationPantelides (setToCont E) (Map.empty);
  def _ = llog "after ir" Ep;
  contToSet Ep
}

def evalReal(e: <Real>, vm: VMap) -> Real = {
  evalRealFromVMap e vm
}

def evalBool(e: <Bool>, vm: VMap) -> Bool = {
  evalBoolFromVMap e vm
}

def stable(es: Equations, vm: VMap) -> Bool = {
  def llog = logger "stable";
  match es with
  | e_1; e_2 -> (stable e_1 vm) && (stable e_2 vm)
  | d_1 = d_2 -> true
  | init _ _ -> true
  | Branch _ _ _ _ -> true
  | sw es_1 _ r -> (evalBool r vm) && (stable es_1 vm)
  | _ -> unmatched llog es
}

def elabsws(es: Equations, vm: VMap) -> Equations = {
  def llog = logger "elabsws";
  match es with
  | e_1; e_2 -> (elabsws e_1 vm); (elabsws e_2 vm)
  | d_1 = d_2 -> es
  | init _ _ -> es
  | Branch _ _ _ _ -> es
  | sw es_1 (lift es_2: (() -> ?)) r -> {
      if evalBool r vm then sw (elabsws es_1 vm) es_2 r
      else es_2 ()
    }
  | _ -> unmatched llog es
}

def evalinits(es: Equations, vm: VMap) -> VMap = {
  def llog = logger "evalinits";
  match es with
  | e_1; e_2 -> evalinits e_1 (evalinits e_2 vm)
  | d_1 = d_2 -> vm
  | init x v ->
      if !(isDefined vm x) then add x (evalReal v vm) vm else vm
  | Branch _ _ _ _ -> vm
  | sw es_1 _ _ -> (evalinits es_1 vm)
  | _ -> unmatched llog es
}

def elabtopol(es: Equations) -> Set(Equations) = {
  def llog = logger "elabtopol";
  def work(es: Equations, T: Set(?)) -> Set(?) = {
    match es with
    | e_1; e_2 -> work e_1 (work e_2 T)
    | d_1 = d_2 -> T
    | init x v -> T
    | Branch _ _ _ _ -> (Set.add es T)
    | sw es_1 _ _ -> (work es_1 T)
    | _ -> unmatched llog es
  };

  elaboratetopology (work es (Set.empty))
}

def gathereqs(es: Equations) -> Set(Equations) = {
  def work(es: Equations, E: Set(Equations)) -> Set(Equations) = {
    def llog = logger "gathereqs";
    match es with
    | e_1; e_2 -> work e_1 (work e_2 E)
    | d_1 = d_2 -> (Set.add es E)
    | init x v -> E
    | Branch _ _ _ _ -> E
    | sw es_1 _ _ -> (work es_1 E)
    | _ -> unmatched llog es
  };

  work es (Set.empty)
}

def gatherregs(es: Equations) -> Set(<Bool>) = {
  def work(es: Equations, P: Set(<Bool>)) -> Set(<Bool>) = {
    def llog = logger "gatherregs";
    match es with
    | e_1; e_2 -> work e_1 (work e_2 P)
    | d_1 = d_2 -> P
    | init x v -> P
    | Branch _ _ _ _ -> P
    | sw es_1 _ p -> (work es_1 (Set.add p P))
    | _ -> unmatched llog es
  };

  work es (Set.empty)
}

def evalpres(E: Set(Equations), vm: VMap) -> Set(Equations) = {
  def llog = logger "evalpres";
  def work(e: Equations) -> Equations = {
    def workharder(ee: <?>) -> <?> = {
      match ee with
      | pre x -> evalReal x vm
      | f ee_1 -> (workharder f) (workharder ee_1)
      | _ -> ee
    };

    match e with
    | e_1 = e_2 -> (workharder e_1) = (workharder e_2)
    | _ -> unmatched llog e
  };

  listToSet (map work (Set.toList E))
}

def mapToImplEuler(E: Set(Equations), vm: VMap, h: Real) -> Set(Equations) = {
  def llog = logger "mapToBEuler";
  def work(e: Equations) -> Equations = {
    def workharder(ee: <?>) -> <?> = {
      match ee with
      | der x -> (x - (evalReal x vm)) / h
      | f ee_1 -> (workharder f) (workharder ee_1)
      | _ -> ee
    };

    match e with
    | e_1 = e_2 -> (workharder e_1) = (workharder e_2)
    | _ -> unmatched llog e
  };

  listToSet (map work (Set.toList E))
}

// TODO: handle newly introduced eqs and variables
def impulseApprox(E: Set(Equations), vm: VMap, h: Real) -> VMap = {
  def EIE = mapToImplEuler E vm h;
  def nvm = solveNLEQ EIE vm 0.;
  nvm
}

def ivApprox(E: Set(Equations), vm: VMap, h: Real) -> VMap = {
  def EIE = mapToImplEuler E vm (-h);
  def nvm = solveNLEQ EIE vm 0.;
  nvm
}

def elaborate(m: Equations) -> Set(Equations) = {
  def E = gathereqs m;
  def Et = elabtopol m;
  union E Et
}
