/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include OSCLANG
include GraphElaboration

def pre: <Real> -> <Real>
def sw: Equations -> (() -> ?) -> <Bool> -> Equations

def unmatched(llog: ((Int, String) -> String -> Dyn), pat: Dyn) = {
  def _ = llog INFO "Pattern:" pat;
  error "Unmatched pattern"
}

def evalReal(e: <Real>, vm: VMap) -> Real = {
  evalRealFromVMap e vm
}

def evalBool(e: <Bool>, vm: VMap) -> Bool = {
  evalBoolFromVMap e vm
}

def stable(es: Equations, vm: VMap) -> Bool = {
  def llog = logger "stable";
  match es with
  | e_1; e_2 -> (stable e_1 vm) && (stable e_2 vm)
  | d_1 = d_2 -> true
  | init _ _ -> true
  | Branch _ _ _ _ -> true
  | sw es_1 _ r -> (evalBool r vm) && (stable es_1 vm)
  | _ -> unmatched llog es
}

def elabsws(es: Equations, vm: VMap) -> Equations = {
  def llog = logger "elabsws";
  match es with
  | e_1; e_2 -> (elabsws e_1 vm); (elabsws e_2 vm)
  | d_1 = d_2 -> es
  | init _ _ -> es
  | Branch _ _ _ _ -> es
  | sw es_1 (lift es_2: (() -> ?)) r -> {
      if evalBool r vm then sw (elabsws es_1 vm) (fun t: () -> es_2) r
      else es_2 ()
    }
  | _ -> unmatched llog es
}

def elabinits(es: Equations, vm: VMap) -> VMap = {
  def llog = logger "elabinits";
  match es with
  | e_1; e_2 -> elabinits e_1 (elabinits e_2 vm)
  | d_1 = d_2 -> vm
  | init x v ->
      if isUndefined x vm then add x (evalReal v vm) vm else vm
  | Branch _ _ _ _ -> vm
  | sw es_1 _ _ -> (elabinits es_1 vm)
  | _ -> unmatched llog es
}

def elabtopol(es: Equations) -> Set(Equations) = {
  def llog = logger "elabtopol";
  def work(es: Equations, T: Set(?)) -> Set(?) = {
    match es with
    | e_1; e_2 -> work e_1 (work e_2 T)
    | d_1 = d_2 -> T
    | init x v -> T
    | Branch _ _ _ _ -> (Set.add es T)
    | sw es_1 _ _ -> (work es_1 T)
    | _ -> unmatched llog es
  };

  elaboratetopology (work es (Set.empty))
}

def gathereqs(es: Equations) -> Set(Equations) = {
  def work(es: Equations, E: Set(Equations)) -> Set(Equations) = {
    def llog = logger "gathereqs";
    match es with
    | e_1; e_2 -> work e_1 (work e_2 E)
    | d_1 = d_2 -> (Set.add es E)
    | init x v -> E
    | Branch _ _ _ _ -> E
    | sw es_1 _ _ -> (work es_1 E)
    | _ -> unmatched llog es
  };

  work es (Set.empty)
}

def elaboratepre(E: Set(Equations), vm: VMap) -> Set(Equations) = {
  def llog = logger "elaboratepre";
  def work(e: Equations) -> Equations = {
    def workharder(ee: <Real>) -> <Real> = {
      match ee with
      | pre x -> evalReal x vm
      | f ee_1 -> f (workharder ee_1)
      | _ -> ee
    };

    match e with
    | e_1 = e_2 -> (workharder e_1) = (workharder e_2)
    | _ -> unmatched llog e
  };

  listToSet (map work (Set.toList E))
}
