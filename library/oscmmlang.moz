/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include OSCLANGHelpers
include GraphElaboration

def nilp: () -> Equations
def pre: <Real> -> <Real>
def sw: Equations -> (() -> ?) -> <Bool> -> Equations

def evalReal(e: <Real>, vm: VMap) -> Real = {
  evalRealFromVMap e vm
}

def evalBool(e: <Bool>, vm: VMap) -> Bool = {
  def llog = logger "evalBool" TRACE;
  def _ = llog "expr" e;
  def _ = llog "variable map" vm;
  def _ = llog "evals to:" (evalBoolFromVMap e vm);
  evalBoolFromVMap e vm
}

def stable(es: Equations, vm: VMap) -> Bool = {
  def llog = logger "stable";
  match es with
  | e_1; e_2 -> (stable e_1 vm) && (stable e_2 vm)
  | d_1 = d_2 -> true
  | init _ _ -> true
  | Branch _ _ _ _ -> true
  | sw es_1 _ r -> (evalBool r vm) && (stable es_1 vm)
  | nilp _ -> true
  | _ -> unmatched llog es
}

def elabsws(es: Equations, vm: VMap) -> Equations = {
  def llog = logger "elabsws";
  match es with
  | e_1; e_2 -> (elabsws e_1 vm); (elabsws e_2 vm)
  | d_1 = d_2 -> es
  | init _ _ -> es
  | Branch _ _ _ _ -> es
  | sw es_1 (lift es_2: (() -> ?)) r -> {
      if evalBool r vm then sw (elabsws es_1 vm) es_2 r
      else es_2 ()
    }
  | nilp _ -> es
  | _ -> unmatched llog es
}

def evalinits(es: Equations, vm: VMap) -> VMap = {
  def llog = logger "evalinits";
  match es with
  | e_1; e_2 -> evalinits e_1 (evalinits e_2 vm)
  | d_1 = d_2 -> vm
  | init x v ->
      if !(isDefined vm x) then add x (evalReal v vm) vm else vm
  | Branch _ _ _ _ -> vm
  | sw es_1 _ _ -> (evalinits es_1 vm)
  | nilp _ -> vm
  | _ -> unmatched llog es
}

def elabtopol(es: Equations) -> Set(Equations) = {
  def llog = logger "elabtopol";
  def work(es: Equations, T: Set(?)) -> Set(?) = {
    match es with
    | e_1; e_2 -> work e_1 (work e_2 T)
    | d_1 = d_2 -> T
    | init x v -> T
    | Branch _ _ _ _ -> (Set.add es T)
    | sw es_1 _ _ -> (work es_1 T)
    | nilp _ -> T
    | _ -> unmatched llog es
  };

  elaboratetopology (work es (Set.empty))
}

def gathereqs(es: Equations) -> Set(Equations) = {
  def work(es: Equations, E: Set(Equations)) -> Set(Equations) = {
    def llog = logger "gathereqs";
    match es with
    | e_1; e_2 -> work e_1 (work e_2 E)
    | d_1 = d_2 -> (Set.add es E)
    | init x v -> E
    | Branch _ _ _ _ -> E
    | sw es_1 _ _ -> (work es_1 E)
    | nilp _ -> E
    | _ -> unmatched llog es
  };

  work es (Set.empty)
}

def gatherregs(es: Equations) -> Set(<Bool>) = {
  def work(es: Equations, P: Set(<Bool>)) -> Set(<Bool>) = {
    def llog = logger "gatherregs";
    match es with
    | e_1; e_2 -> work e_1 (work e_2 P)
    | d_1 = d_2 -> P
    | init x v -> P
    | Branch _ _ _ _ -> P
    | sw es_1 _ p -> (work es_1 (Set.add p P))
    | nilp _ -> P
    | _ -> unmatched llog es
  };

  work es (Set.empty)
}

def evalpres(E: Set(Equations), vm: VMap) -> Set(Equations) = {
  def llog = logger "evalpres";
  def work(e: Equations) -> Equations = {
    def workharder(ee: <?>) -> <?> = {
      match ee with
      | pre x -> evalReal x vm
      | f ee_1 -> (workharder f) (workharder ee_1)
      | _ -> ee
    };

    match e with
    | e_1 = e_2 -> (workharder e_1) = (workharder e_2)
    | _ -> unmatched llog e
  };

  listToSet (map work (Set.toList E))
}

def gatherIEulerDefEquations(E: Set(Equations), ll: VMap) -> Set(Equations) = {
  def llog = logger "gatherIEulerDefEquations";

  def work(acc: Set(Equations), e: Equations) -> Set(Equations) = {
    match e with
    | e_1 = e_2 ->
      if (isIEDerDefined ll e_1) && (isIEDerDefined ll e_2) then (Set.add e acc)
      else acc
    | _ -> unmatched llog e
  };

  foldLeft work (Set.empty) (Set.toList E)
}

def mapToImplEuler(E: Set(Equations), ll: VMap, h: Real) -> Set(Equations) = {
  def llog = logger "mapToBEuler";

  def work(e: Equations) -> Equations = {
    def workharder(ee: <?>) -> <?> = {
      match ee with
      | der x -> (x - (evalReal x ll)) / h
      | f ee_1 -> (workharder f) (workharder ee_1)
      | _ -> ee
    };

    match e with
    | e_1 = e_2 -> (workharder e_1) = (workharder e_2)
    | _ -> unmatched llog e
  };

  listToSet (map work (Set.toList E))
}

def impulseApprox(E: Set(Equations), ll: VMap, rl: VMap, h: Real) -> VMap = {
  def IEDE = gatherIEulerDefEquations E ll;
  def EIE = mapToImplEuler IEDE ll h;
  def nrl = solveNLEQ EIE rl 0.;
  nrl
}

def containsImps(dma: VMap, tresh: Real) -> Bool = {
  def p(e: (<Real>, Real)) -> Bool = {
    def (x, v) = e;
    (abs v) > tresh
  };

  exists p (Map.toList dma)
}

def ivApprox(E: Set(Equations), rl: VMap, h: Real) -> VMap = {
  // def IEDE = gatherIEulerDefEquations E rl;
  def IEDE = E;
  def EIE = mapToImplEuler IEDE rl (-h);
  def nrl = solveNLEQ EIE rl 0.;
  nrl
}

def elaborate(m: Equations) -> Set(Equations) = {
  def E = gathereqs m;
  def Et = elabtopol m;
  union E Et
}

def combineImpIVApp(imp: VMap, iva: VMap, co: Real) -> VMap = {
  def f(e: (<Real>, Real)) -> (<Real>, Real) = {
    def getinf(v: Real) -> Real = {
      if v > 0. then INFINITE else NEG_INFINITE
    };
    def (x, v) = e;
    if v > (find x iva)*100. then (x, getinf v) else (x, find x iva)
  };

  listToMap (map f (Map.toList imp))
}
