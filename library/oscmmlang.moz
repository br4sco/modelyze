/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include OSCLANG
include GraphElaboration

def pre: <Real> -> Equations
def sw: Equations -> (() -> ?) -> <Bool> -> Equations

def unmatched(llog: ((Int, String) -> String -> Dyn), pat: Dyn) = {
  def _ = llog INFO "Pattern:" pat;
  error "Unmatched pattern"
}

def evalReal(e: <Real>, vm: VMap) -> Real = {
  evalRealFromVMap e vm
}

def evalBool(e: <Bool>, vm: VMap) -> Bool = {
  evalBoolFromVMap e vm
}

def stable(es: Equations, vm: VMap) -> Bool = {
  def llog = logger "stable";
  match es with
  | e_1; e_2 -> (stable e_1 vm) && (stable e_2 vm)
  | d_1 = d_2 -> true
  | init _ _ -> true
  | Branch _ _ _ _ -> true
  | sw es_1 _ r -> (evalBool r vm) && (stable es_1 vm)
  | _ -> unmatched llog es
}

def elabsws(es: Equations, vm: VMap) -> Equations = {
  def llog = logger "elabsws";
  match es with
  | e_1; e_2 -> (elabsws e_1 vm); (elabsws e_2 vm)
  | d_1 = d_2 -> es
  | init _ _ -> es
  | Branch _ _ _ _ -> es
  | sw es_1 (lift es_2: (() -> ?)) r -> {
      if evalBool r vm then sw (elabsws es_1 vm) (fun t: () -> es_2) r
      else es_2 ()
    }
  | _ -> unmatched llog es
}

def elabinits(es: Equations, vm: VMap) -> VMap = {
  def llog = logger "elabinits";
  match es with
  | e_1; e_2 -> elabinits e_1 (elabinits e_2 vm)
  | d_1 = d_2 -> vm
  | init x v ->
      if isUndefined x vm then add x (evalReal v vm) vm else vm
  | Branch _ _ _ _ -> vm
  | sw es_1 _ _ -> (elabinits es_1 vm)
  | _ -> unmatched llog es
}

def elabtopol(es: Equations, E: Set(Equations)) -> Set(Equations) = {
  def llog = logger "elabtopol";
  def gather(es: Equations, E: Set(?)) -> Set(?) = {
    match es with
    | e_1; e_2 -> gather e_1 (gather e_2 E)
    | d_1 = d_2 -> E
    | init x v -> E
    | Branch _ _ _ _ -> (Set.add es E)
    | sw es_1 _ _ -> (gather es_1 E)
    | _ -> unmatched llog es
  };

  elaboratetopology (gather es (Set.empty))
}

def gathereqs(es: Equations, E: Set(Equations)) -> Set(Equations) = {
  def llog = logger "gathereqs";
  match es with
  | e_1; e_2 -> gathereqs e_1 (gathereqs e_2 E)
  | d_1 = d_2 -> (Set.add es E)
  | init x v -> E
  | Branch _ _ _ _ -> E
  | sw es_1 _ _ -> (gathereqs es_1 E)
  | _ -> unmatched llog es
}
