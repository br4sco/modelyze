/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include OSCLANG
include GraphElaboration

type Location
type Predicate = <Bool>
type Step
type Invariant = <Bool>
type Transition = ([Step], Location)
type GuardedTransition = (Predicate, () -> Transition)

def loc: Location -> Invariant -> [GuardedTransition] -> Location
def eqns: Equations -> Location
def (;): Location -> Location -> Location
def noloc: () -> Location
def step: <Real> -> <Real> -> Step

def elabtopol(G: Set(?)) -> Set(Equations) = {
  def E = {
   if (Set.size G) == 0 then Set.empty
   else  elaboratetopology G
  };
  E
}

def eval(e: <Real>, vmap: VMap) -> Real = {
  evalFromVMap e vmap
}

def fulfills(inv: Invariant, vmap: VMap) -> Bool = {
  evalBoolFromVMap inv vmap
}

def transition(gts: [GuardedTransition], vmap: VMap, nvmap: VMap)
  -> (Location, VMap) = {

  def valid(gt: GuardedTransition) -> Bool = {
    evalBoolFromVMap (fst gt) vmap
  };

  def addstep(nvmap: VMap, s: Step) -> VMap = {
    match s with
    | step x e -> {
        if isUndefined x nvmap then add x (eval e vmap) nvmap
        else error "Multiple steps on the same state variable"
      };
  };

  def vts = filter valid gts;

  match vts with
  | [] -> error "No valid location transitions"
  | _ -> {
      def locs = map (fun t: GuardedTransition -> (snd t) ()) vts;

      def f(acc: (Location, VMap), t: Transition) -> (Location, VMap) = {
        def (locs, nvmap) = acc;
        def (ss, l) = t;
        (locs;l, foldLeft addstep nvmap ss)
      };

      foldLeft f (noloc (), nvmap) locs
    }
}

def findLocsBeforeImp(lcs: Location, vmap: VMap, nvmap: VMap)
  -> (Location, VMap) = {

  match lcs with
  | lcs_1; lcs_2 -> {
      def (lloc, lnvmap) = (findLocsBeforeImp lcs_1 vmap nvmap);
      def (rloc, rnvmap) = (findLocsBeforeImp lcs_2 vmap lnvmap);
      (lloc; rloc, rnvmap)
    }
  | loc loc_1 inv (lift gts: [GuardedTransition]) -> {
      if fulfills inv vmap then {
        def (l, nnvmap) = findLocsBeforeImp loc_1 vmap nvmap;
        (loc l inv gts, nvmap)
      } else transition gts vmap nvmap
    }
  | eqn _ -> (lcs, nvmap)
  | noloc _ -> (lcs, nvmap)
  | _ -> {
      def _ = dprint(lcs);
      error "Unmatched pattern in findLocsBeforeImp"
    }
}

def getDAE(lcs: Location) -> Equations = {
  def getEquations(lcs: Location) -> Equations = {
    match lcs with
    | lcs_1; lcs_2 -> (getEquations lcs_1); (getEquations lcs_2)
    | loc loc_1 _ _ -> getEquations loc_1
    | eqns e -> e
    | noloc _ -> nilp ()
    | _ -> {
        def _ = dprint(lcs);
        error "Unmatched pattern in getEquations"
      }
  };
  getEquations lcs
}
