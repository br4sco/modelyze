/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include GRAPHSIMMECHANICAL
include GRAPHSIMELECTRICAL

type FrameFun2NodeFun2 = Frame -> Frame -> Node -> Node -> Model
type FrameFun1NodeFun2 = Frame -> Node -> Node -> Model

def inParallel(l: FrameFun2NodeFun2, r: FrameFun2NodeFun2) -> FrameFun2NodeFun2 = {
  fun f1: Frame -> fun f2: Frame -> fun n1: Node -> fun n2: Node ->
    l f1 f2 n1 n2;
    r f1 f2 n1 n2
}
def (||) = inParallel

def inSeries(l: Frame, r: FrameFun1NodeFun2) -> NodeFun2 = {
  r l
}
def (--) = inSeries

def inSeries(l: FrameFun1NodeFun2, r: Frame) -> NodeFun2 = {
  l r
}
def (--) = inSeries

def inSeries(f: Frame, r: FrameFun2NodeFun2) -> FrameFun1NodeFun2 = {
  r f
}
def (--) = inSeries

def inSeries(l: FrameFun1NodeFun2, r: FrameFun2NodeFun2) -> FrameFun1NodeFun2 = {
  fun f2: Frame -> fun n1: Node -> fun n2: Node ->
    def f1: Frame;
    l f1 n1 n2;
    r f1 f2 n1 n2
}
def (--) = inSeries

def inParallel(l: FrameFun2NodeFun2, r: FrameFun2) -> FrameFun2NodeFun2 = {
  fun f1: Frame -> fun f2: Frame -> fun n1: Node -> fun n2: Node ->
    l f1 f2 n1 n2;
    r f1 f2
}
def (||) = inParallel

def inParallel(l: FrameFun2, r: FrameFun2NodeFun2) -> FrameFun2NodeFun2 = inParallel r l
def (||) = inParallel

def inSeries(l: FrameFun1, r: FrameFun2NodeFun2) -> FrameFun1NodeFun2 = {
  fun f2: Frame -> fun n1: Node -> fun n2: Node ->
    def f1: Frame;
    l f1;
    r f1 f2 n1 n2
}
def (--) = inSeries

def inSeries(l: FrameFun1NodeFun2, r: FrameFun2) -> FrameFun1NodeFun2 = {
  fun f2: Frame -> fun n1: Node -> fun n2: Node ->
    def f1: Frame;
    l f1 n1 n2;
    r f1 f2
}
def (--) = inSeries

def inSeries(l: FrameFun2NodeFun2, r: FrameFun2) -> FrameFun2NodeFun2 = {
  fun f1: Frame -> fun f3: Frame -> fun n1: Node -> fun n2: Node ->
    def f2: Frame;
    l f1 f2 n1 n2;
    r f2 f3
}
def (--) = inSeries

def inSeries(l: FrameFun2, r: FrameFun2NodeFun2) -> FrameFun2NodeFun2 = {
  fun f1: Frame -> fun f3: Frame -> fun n1: Node -> fun n2: Node ->
    def f2: Frame;
    l f1 f2;
    r f2 f3 n1 n2
}
def (--) = inSeries

// def inSeriesExposeNode(l: FrameFun2NodeFun2, f2: Frame) -> (FrameFun2NodeFun2, Frame) = {
//   (l, f2)
// }
// def (-.-) = inSeriesExposeNode

// def inSeriesExposeNode(lf2: (FrameFun2NodeFun2, Frame), r: FrameFun2NodeFun2) -> FrameFun2NodeFun2 = {
//   fun f1: Frame -> fun f3: Frame -> fun n1: Node -> fun n2: Node ->
//     def (l, f2) = lf2;
//     l f1 f2 n1 n2;
//     r f2 f3 n1 n2
// }
// def (-.-) = inSeriesExposeNode

def inSeries(l: FrameFun2NodeFun2, r: FrameFun2NodeFun2) -> FrameFun2NodeFun2 = {
  fun f1: Frame -> fun f3: Frame -> fun n1: Node -> fun n2: Node ->
    def f2: Frame;
    l f1 f2 n1 n2;
    r f2 f3 n1 n2
}
def (--) = inSeries

def EMFE(k: Real, u: Voltage, i: Current, omu: AngularVelocityU) -> NodeFun2 = {
  fun n1: Node -> fun n2: Node ->
    electricalEdge n1 n2 u i;
    u = k * omu
}

def EMFE(k: Real, i: Current, omu: AngularVelocityU) -> NodeFun2 = {
  fun n1: Node -> fun n2: Node ->
    def u_EMF: Voltage;
    n1 -- EMFE k u_EMF i omu -- n2
}

def EMFM(k: Real, uu: Vector3, omu: AngularVelocityU, Tu: TorqueU, i: Current) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    def om1, om2, om3, T1, T2, T3: Real;
    def om = vec3 om1 om2 om3;
    def T = vec3 T1 T2 T3;
    def n = normalize uu;
    angularVelocityEdge f1 f2 om T;
    Tu = dot n T;
    om = omu *. n;
    Tu = k * i
}

def EMFM(k: Real, uu: Vector3, omu: AngularVelocityU, i: Current) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    def Tu_EMF: TorqueU;
    f1 -- EMFM k uu omu Tu_EMF i -- f2
}

def EMF(k: Real, uu: Vector3) -> FrameFun2NodeFun2 = {
  fun f1: Frame -> fun f2: Frame -> fun n1: Node -> fun n2: Node ->
    def omu_EMF: AngularVelocityU;
    def i_EMF: Current;
    f1 -- EMFM k uu omu_EMF i_EMF -- f2;
    n1 -- EMFE k i_EMF omu_EMF -- n2;
}

def DCMotor(L: Real, R: Real, k: Real, G: Real, uu: Vector3) -> FrameFun2NodeFun2 = {
  fun f1: Frame -> fun f2: Frame -> fun n1: Node -> fun n2: Node ->
    def emf = f1 -- EMF (G * k) uu -- f2;
    n1 -- Inductor L -- Resistor R -- emf -- n2
}
