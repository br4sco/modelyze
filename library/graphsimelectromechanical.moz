/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include GRAPHSIMMECHANICAL
include GRAPHSIMELECTRICAL

type FrameNodeFun4 = Frame -> Frame -> Node -> Node -> Model
type FrameNodeFun3 = Frame -> Node -> Node -> Model

def inSeries(f1: Frame, ff: FrameNodeFun4) -> FrameNodeFun3 = {
  fun f2: Frame -> fun n1: Node -> fun n2: Node ->
    ff f1 f2 n1 n2
}
def (--) = inSeries

def inSeries(ff: FrameNodeFun3, f2: Frame) -> NodeFun2 = {
  fun n1: Node -> fun n2: Node ->
    ff f2 n1 n2
}
def (--) = inSeries

def EMFE(k: Real, u: Voltage, i: Current, omu: AngularVelocityU) -> NodeFun2 = {
  fun n1: Node -> fun n2: Node ->
    electricalEdge n1 n2 u i;
    u = k * omu
}

def EMFE(k: Real, i: Current, omu: AngularVelocityU) -> NodeFun2 = {
  fun n1: Node -> fun n2: Node ->
    def u_EMF: Voltage;
    n1 -- EMFE k u_EMF i omu -- n2
}

def EMFM(k: Real, uu: Vector3, omu: AngularVelocityU, Tu: TorqueU, i: Current) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    def om1, om2, om3, T1, T2, T3: Real;
    def om = vec3 om1 om2 om3;
    def T = vec3 T1 T2 T3;
    def n = normalize uu;
    angularVelocityEdge f1 f2 om T;
    Tu = dot n T;
    om = omu *. n;
    Tu = k * i
}

def EMFM(k: Real, uu: Vector3, omu: AngularVelocityU, i: Current) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    def Tu_EMF: TorqueU;
    f1 -- EMFM k uu omu Tu_EMF i -- f2
}

def EMF(k: Real, uu: Vector3) -> FrameNodeFun4 = {
  fun f1: Frame -> fun f2: Frame -> fun n1: Node -> fun n2: Node ->
    def omu_EMF: AngularVelocityU;
    def i_EMF: Current;
    f1 -- EMFM k uu omu_EMF i_EMF -- f2;
    n1 -- EMFE k i_EMF omu_EMF -- n2;
}

def DCMotor(L: Real, R: Real, k: Real, G: Real, uu: Vector3) -> FrameNodeFun4 = {
  fun f1: Frame -> fun f2: Frame -> fun n1: Node -> fun n2: Node ->
    def emf = f1 -- EMF (G * k) uu -- f2;
    n1 -- Inductor L -- Resistor R -- emf -- n2
}
