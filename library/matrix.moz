/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Base

def EPSILON = 1.e-15

type Pos = (Int, Int)
type Dim  = (Int, Int)
type Matrix = (Dyn, Dim)
type MatrixFind = Pos -> Dyn -> Dyn
type MatrixAdd = Pos -> Dyn -> Dyn -> Matrix
type MatrixZero = (Int, Int) -> Matrix
type MatrixProd = Matrix -> Matrix -> Matrix

// Data structures to hold sparse matrices
type MMap = (Int => (Int => Dyn))
type MatrixMap = (MMap, Dim)
type MatrixMapInt = (Int => (Int => Int), Dim)
type MatrixMapReal = (Int => (Int => Real), Dim)
type MatrixMapSReal = (Int => (Int => <Real>), Dim)
type MatrixMapIntDyn = (Int => (Int => (Int, Dyn)), Dim)

def DIMENSION_MISSMATCH = "Dimension missmatch"
def BAD_MATRIX = "Bad matrix"
def EMPTY_MATRIX_LIST = "Empty matrix list"

// Operators and functions over Ints (in lack of type polymorphism)
def iszInt(v: Int) -> Bool = { v == 0 }
def eqInt(l: Int, r: Int) -> Bool = { l == r }
def addInt(l: Int, r: Int) -> Int = { l + r }
def prodInt(l: Int, r: Int) -> Int = { l * r }
def chsgnInt(v: Int) -> Int = { -v }
def gtInt(l: Int, r: Int) -> Bool = { l > r }

// Operators and functions over Reals (in lack of type polymorphism)
def iszReal(v: Real) -> Bool = { (abs v) < EPSILON }
def eqReal(l: Real, r: Real) -> Bool = { abs (l - r) < EPSILON }
def addReal(l: Real, r: Real) -> Real = { l + r }
def prodReal(l: Real, r: Real) -> Real = { l * r }
def chsgnReal(v: Real) -> Real = { -v }
def gtReal(l: Real, r: Real) -> Bool = { l > r }

// S Real
def iszSReal(v: <Real>) -> Bool = {
  match v with
  | lift r: Real -> iszReal r
  | _ -> false
}
def addSReal(l: <Real>, r: <Real>) -> <Real> = {
  if iszSReal l && iszSReal r then 0.
  else if iszSReal l then r
  else if iszSReal r then l
  else {
    match r with
    | -r -> l - r
    | _ -> l + r
  }
}
def prodSReal(l: <Real>, r: <Real>) -> <Real> = {
  def isuSReal(v: <Real>) -> Bool = {
    match v with
    | sval r: Real -> eqReal r 1.
    | _ -> false
  };

  def isnuSReal(v: <Real>) -> Bool = {
    match v with
    | sval r: Real -> eqReal r (-1.)
    | _ -> false
  };

  if iszSReal l then 0.
  else if iszSReal r then 0.
  else if isuSReal l then r
  else if isuSReal r then l
  else if isnuSReal l then -r
  else if isnuSReal r then -l
  else l * r
}
def chsgnSReal(v: <Real>) -> <Real> = {
  if iszSReal v then 0.
  else {
    match v with
    | -v -> v
    | _ -> -v
  }
}

def _mem(ij: Pos, Mm: MMap) -> Bool = {
  def (i, j) = ij;
  if Map.mem i Mm then Map.mem j (Map.find i Mm) else false
}

def _find(ij: Pos, Mm: MMap) -> Dyn = {
  def (i, j) = ij;
  Map.find j (Map.find i Mm)
}

def _add(ij: Pos, v: Dyn, Mm: MMap) -> MMap = {
  def (i, j) = ij;
  Map.add i (Map.add j v (Map.find i Mm)) Mm
}

def _remove(ij: Pos, Mm: MMap) -> MMap = {
  def (i, j) = ij;
  Map.add i (Map.remove j (Map.find i Mm)) Mm
}

def posEq(lhs: Pos, rhs: Pos) -> Bool = {
  ((fst lhs) == (fst rhs)) && ((snd lhs) == (snd rhs))
}
def (==): Pos -> Pos -> Bool = posEq

def posEq(lhs: Pos, rhs: Pos) -> Bool = { !(lhs == rhs) }
def (!=): Pos -> Pos -> Bool = posEq

def posLT(lhs: Pos, rhs: Pos) -> Bool = {
  (fst rhs > fst lhs || snd rhs > snd lhs)
}
def (<): Pos -> Pos -> Bool = posLT

def posLTorEq(lhs: Pos, rhs: Pos) -> Bool = {
  (lhs == rhs) || (lhs < rhs)
}
def (<=): Pos -> Pos -> Bool = posLTorEq

def posGT(lhs: Pos, rhs: Pos) -> Bool = { rhs < lhs }
def (>): Pos -> Pos -> Bool = posGT

def posGTorEq(lhs: Pos, rhs: Pos) -> Bool = { rhs <= lhs }
def (>=): Pos -> Pos -> Bool = posGTorEq

def posAdd(lhs: Pos, rhs: Pos) -> Pos = {
  (fst lhs + fst rhs, snd lhs + snd rhs)
}
def (+): Pos -> Pos -> Pos = posAdd

def posSub(lhs: Pos, rhs: Pos) -> Pos = {
  (fst lhs - fst rhs, snd lhs - snd rhs)
}
def (-): Pos -> Pos -> Pos = posSub

def _nextpos(ij: Pos, mn: Pos) -> Pos = {
  if ij > mn then error DIMENSION_MISSMATCH
  else { if snd ij == snd mn then (fst ij + 1, 1) else (fst ij, snd ij + 1) }
}

def mmZero(d: (Int, Int)) -> MatrixMap = {
  def (n, _) = d;
  def work(i: Int, a: MMap) -> MMap = {
    if i > 0 then work (i - 1) (Map.add i (Map.empty) a) else a
  };

  if (0, 0) > d then error "Dimensions need to be greater or equal to zero"
  else (work n (Map.empty), d)
}
def mmIntZero(d: (Int, Int)) -> MatrixMapInt = { mmZero d }
def mmRealZero(d: (Int, Int)) -> MatrixMapReal = { mmZero d }
def mmSRealZero(d: (Int, Int)) -> MatrixMapSReal = { mmZero d }

def mmId(id: Dyn, n: Int) -> MatrixMap = {
  def work(i: Int, a: MMap) -> MMap = {
    if i > 0 then work (i - 1) (_add (i, i) id a) else a
  };
  (work n (fst (mmZero (n, n))), (n, n))
}
def mmIntId(n: Int) -> MatrixMapInt = { mmId 1 n }
def mmRealId(n: Int) -> MatrixMapReal = { mmId 1. n }
def mmSRealId(n: Int) -> MatrixMapSReal = {
  def u: <Real> = 1.;
  mmId u n
}

def dim(M: Matrix) -> (Int, Int) = { snd M }
def rdim(M: Matrix) -> Int = { fst (dim M) }
def cdim(M: Matrix) -> Int = { snd (dim M) }

def mmFind(z: Dyn, ij: Pos, M: MatrixMap) -> Dyn = {
  def (Mm, d) = M;
  def (i, j) = ij;
  if (ij <= (0, 0) || ij > d) then {def _ = dprint(M); error DIMENSION_MISSMATCH}
  else {
    if (_mem ij Mm) then (_find ij Mm)
    else z
  }
}
def mmIntFind(ij: Pos, M: MatrixMapInt) -> Int = { mmFind 0 ij M }
def find: Pos -> MatrixMapInt -> Int = mmIntFind
def mmRealFind(ij: Pos, M: MatrixMapReal) -> Real = { mmFind 0. ij M }
def find: Pos -> MatrixMapReal -> Real = mmRealFind
def mmSRealFind(ij: Pos, M: MatrixMapSReal) -> <Real> = {
  def z: <Real> = 0.;
  mmFind z ij M
}
def find: Pos -> MatrixMapSReal -> <Real> = mmSRealFind

def matrixToList(mfind: MatrixFind, M: Matrix) -> [[Dyn]] = {
  def workRow(i: Int, j: Int, a: [Dyn]) -> [Dyn] = {
    if j > 0 then workRow i (j - 1) ((mfind (i, j) M)::a) else a
  };

  def work(i: Int, a: [[Dyn]]) -> [[Dyn]] = {
    if i > 0 then work (i - 1) ((workRow i (cdim M) [])::a) else a
  };

  work (rdim M) []
}
def matrixToList(M: MatrixMapReal) -> [[Real]] = {
  matrixToList mmRealFind M
}
def matrixToList(M: MatrixMapSReal) -> [[<Real>]] = {
  matrixToList mmSRealFind M
}

def dp(mfind: MatrixFind, M: Matrix) -> Matrix = {
  def _ = println("[");
  def _ = iter (fun r: [Dyn] -> {
      def _ = print("  "); def _ = dprintln(r); ()
    }) (matrixToList mfind M);
  def _ = print("] d = ");
  def _ = dprintln(dim M);
  M
}
def dp(M: MatrixMapInt) -> MatrixMapInt = { dp mmIntFind M }
def dp(M: MatrixMapReal) -> MatrixMapReal = { dp mmRealFind M }
def dp(M: MatrixMapSReal) -> MatrixMapSReal = { dp mmSRealFind M }

def mmAdd(isz: (Dyn -> Bool), ij: Pos, v: Dyn, M: MatrixMap)
  -> MatrixMap = {

  def (Mm, d) = M;
  if (ij <= (0, 0) || ij > d) then error DIMENSION_MISSMATCH
  else {
    if isz v then {
      if _mem ij Mm then (_remove ij Mm, d) else M
    } else (_add ij v Mm, d)
  }
}
def mmIntAdd(ij: Pos, v: Int, M: MatrixMapInt) -> MatrixMapInt = {
  mmAdd iszInt ij v M
}
def add: Pos -> Int -> MatrixMapInt -> MatrixMapInt = mmIntAdd
def mmRealAdd(ij: Pos, v: Real, M: MatrixMapReal) -> MatrixMapReal = {
  mmAdd iszReal ij v M
}
def add: Pos -> Real -> MatrixMapReal -> MatrixMapReal = mmRealAdd
def mmSRealAdd(ij: Pos, v: <Real>, M: MatrixMapSReal) -> MatrixMapSReal = {
  mmAdd iszSReal ij v M
}
def add: Pos -> <Real> -> MatrixMapSReal -> MatrixMapSReal = mmSRealAdd

def listToMatrix(madd: MatrixAdd, l: [[Dyn]], M: Matrix) -> Matrix = {
  def workRow(l: [Dyn], i: Int, j: Int, a: Matrix) -> Matrix = {
    match l with
    | x::xs -> workRow xs i (j + 1) (madd (i, j) x a)
    | [] -> a
  };

  def work(l: [[Dyn]], i: Int, a: Matrix) -> Matrix = {
    match l with
    | xs::xss -> work xss (i + 1) (workRow xs i 1 a)
    | [] -> a
  };

  work l 1 M
}
def listToMatrix(l: [[Int]], M: MatrixMapInt) -> MatrixMapInt = {
  listToMatrix mmIntAdd l M
}
def listToMatrix(l: [[Real]], M: MatrixMapReal) -> MatrixMapReal = {
  listToMatrix mmRealAdd l M
}
def listToMatrix(l: [[<Real>]], M: MatrixMapSReal) -> MatrixMapSReal = {
  listToMatrix mmSRealAdd l M
}

def forij(f: (Pos -> Bool), M: Matrix) -> Bool = {
  def work(c: Int) -> Bool = {
    def p = (c / (cdim M) + 1, c mod (cdim M) + 1);
    if (c + 1 > ((rdim M) * (cdim M))) then true
    else { if !(f p) then false else work (c + 1) }
  };
  work 0
}

def matrixEq(mfind: MatrixFind, eq: (Dyn -> Dyn -> Bool),
  lM: Matrix, rM: Matrix)-> Bool = {

  if (dim lM) != (dim rM) then error DIMENSION_MISSMATCH
  else forij (fun ij: Pos -> { eq (mfind ij lM) (mfind ij rM) }) lM
}
def matrixEq(lM: MatrixMapInt, rM: MatrixMapInt) -> Bool = {
  matrixEq mmIntFind eqInt lM rM
}
def (==): MatrixMapInt -> MatrixMapInt -> Bool = matrixEq
def matrixEq(lM: MatrixMapReal, rM: MatrixMapReal) -> Bool = {
  matrixEq mmRealFind eqReal lM rM
}
def (==): MatrixMapReal -> MatrixMapReal -> Bool = matrixEq

def matrixNEq(mfind: MatrixFind, eq: (Dyn -> Dyn -> Bool),
  lM: Matrix, rM: Matrix) -> Bool = { !(matrixEq mfind eq lM rM) }
def matrixNEq(lM: MatrixMapInt, rM: MatrixMapInt) -> Bool = {
  matrixNEq mmIntFind eqInt lM rM
}
def (!=): MatrixMapInt -> MatrixMapInt -> Bool = matrixNEq
def matrixNEq(lM: MatrixMapReal, rM: MatrixMapReal) -> Bool = {
  matrixNEq mmRealFind eqReal lM rM
}
def (!=): MatrixMapReal -> MatrixMapReal -> Bool = matrixNEq

def mapij(madd: MatrixAdd, mzero: MatrixZero, f: (Pos -> Dyn), M: Matrix)
  -> Matrix = {
  def work(ij: Pos, a: Matrix) -> Matrix = {
    if dim M < ij then a
    else { work (_nextpos ij (dim M)) (madd ij (f ij) a) }
  };
  work (1, 1) (mzero (dim M))
}
def mapij(f: (Pos -> Int), M: Matrix) -> MatrixMapInt = {
  mapij mmIntAdd mmIntZero f M
}
def mapij(f: (Pos -> Real), M: Matrix) -> MatrixMapReal = {
  mapij mmRealAdd mmRealZero f M
}
def mapij(f: (Pos -> <Real>), M: Matrix) -> MatrixMapSReal = {
  mapij mmSRealAdd mmSRealZero f M
}

def map(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, f: (Dyn -> Dyn),
  M: Matrix) -> Matrix = {
  mapij madd mzero (fun ij: Pos -> f (mfind ij M)) M
}
def map(f: (Dyn -> Int), M: Matrix) -> MatrixMapInt = {
  map mmIntFind mmIntAdd mmIntZero f M
}
def map(f: (Dyn -> Real), M: Matrix) -> MatrixMapReal = {
  map mmRealFind mmRealAdd mmRealZero f M
}
def map(f: (Dyn -> <Real>), M: Matrix) -> MatrixMapSReal = {
  map mmSRealFind mmSRealAdd mmSRealZero f M
}

def foldij(f: (Dyn -> Pos -> Dyn), a: Dyn, M: Matrix) -> Dyn = {
  def work(ij: Pos, a: Dyn) -> Dyn = {
    if ij > dim M then a else work (_nextpos ij (dim M)) (f a ij)
  };
  work (1, 1) a
}

def matrixAddition(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero,
  add: (Dyn -> Dyn -> Dyn), lM: Matrix, rM: Matrix) -> Matrix = {

if (dim lM) != (dim rM) then error DIMENSION_MISSMATCH
  else mapij madd mzero (fun ij: Pos -> { add (mfind ij lM) (mfind ij rM) }) rM
}
def matrixAddition(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = {
  matrixAddition mmIntFind mmIntAdd mmIntZero addInt lM rM
}
def (+): MatrixMapInt -> MatrixMapInt -> MatrixMapInt = matrixAddition
def matrixAddition(lM: MatrixMapReal, rM: MatrixMapReal) -> MatrixMapReal = {
  matrixAddition mmRealFind mmRealAdd mmRealZero addReal lM rM
}
def (+): MatrixMapReal -> MatrixMapReal -> MatrixMapReal = matrixAddition
def matrixAddition(lM: MatrixMapSReal, rM: MatrixMapSReal) -> MatrixMapSReal = {
  matrixAddition mmSRealFind mmSRealAdd mmSRealZero addSReal lM rM
}
def (+): MatrixMapSReal -> MatrixMapSReal -> MatrixMapSReal = matrixAddition

def matrixChsgn(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero,
  cs: (Dyn -> Dyn), M: Matrix) -> Matrix = {

  mapij madd mzero (fun ij: Pos -> cs (mfind ij M)) M
}
def matrixChsgn(M: MatrixMapInt) -> MatrixMapInt = {
  matrixChsgn mmIntFind mmIntAdd mmIntZero chsgnInt M
}
def (---): MatrixMapInt -> MatrixMapInt = matrixChsgn
def matrixChsgn(M: MatrixMapReal) -> MatrixMapReal = {
  matrixChsgn mmRealFind mmRealAdd mmRealZero chsgnReal M
}
def (---): MatrixMapReal -> MatrixMapReal = matrixChsgn
def matrixChsgn(M: MatrixMapSReal) -> MatrixMapSReal = {
  matrixChsgn mmSRealFind mmSRealAdd mmSRealZero chsgnSReal M
}
def (---): MatrixMapSReal -> MatrixMapSReal = matrixChsgn

def matrixSubst(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero,
  add: (Dyn -> Dyn -> Dyn), cs: (Dyn -> Dyn), lM: Matrix, rM: Matrix)
  -> Matrix = {

  matrixAddition mfind madd mzero add lM (matrixChsgn mfind madd mzero cs rM)
}
def matrixSubst(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = {
  matrixSubst mmIntFind mmIntAdd mmIntZero addInt chsgnInt lM rM
}
def (-): MatrixMapInt -> MatrixMapInt -> MatrixMapInt = matrixSubst
def matrixSubst(lM: MatrixMapReal, rM: MatrixMapReal) -> MatrixMapReal = {
  matrixSubst mmRealFind mmRealAdd mmRealZero addReal chsgnReal lM rM
}
def (-): MatrixMapReal -> MatrixMapReal -> MatrixMapReal = matrixSubst
def matrixSubst(lM: MatrixMapSReal, rM: MatrixMapSReal) -> MatrixMapSReal = {
  matrixSubst mmSRealFind mmSRealAdd mmSRealZero addSReal chsgnSReal lM rM
}
def (-): MatrixMapSReal -> MatrixMapSReal -> MatrixMapSReal = matrixSubst

def matrixScalarProd(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero,
  prod: (Dyn -> Dyn -> Dyn), s: Dyn, M: Matrix) -> Matrix = {

  mapij madd mzero (fun ij: Pos -> { prod s (mfind ij M) }) M
}
def matrixScalarProd(s: Int, M: MatrixMapInt) -> MatrixMapInt = {
  matrixScalarProd mmIntFind mmIntAdd mmIntZero prodInt s M
}
def (*.): Int -> MatrixMapInt -> MatrixMapInt = matrixScalarProd
// def matrixScalarProd(M: MatrixMapInt, s: Int) -> MatrixMapInt = {
//   matrixScalarProd mmIntFind mmIntAdd mmIntZero prodInt s M
// }
// def (*): MatrixMapInt -> Int -> MatrixMapInt = matrixScalarProd
def matrixScalarProd(s: Real, M: MatrixMapReal) -> MatrixMapReal = {
  matrixScalarProd mmRealFind mmRealAdd mmRealZero prodReal s M
}
def (*.): Real -> MatrixMapReal -> MatrixMapReal = matrixScalarProd
// def matrixScalarProd(M: MatrixMapReal, s: Real) -> MatrixMapReal = {
//   matrixScalarProd mmRealFind mmRealAdd mmRealZero prodReal s M
// }
// def (*): MatrixMapReal -> Real -> MatrixMapReal = matrixScalarProd
def matrixScalarProd(s: <Real>, M: MatrixMapSReal) -> MatrixMapSReal = {
  matrixScalarProd mmSRealFind mmSRealAdd mmSRealZero prodSReal s M
}
def (*.): <Real> -> MatrixMapSReal -> MatrixMapSReal = matrixScalarProd
// def matrixScalarProd(M: MatrixMapSReal, s: <Real>) -> MatrixMapSReal = {
//   matrixScalarProd mmSRealFind mmSRealAdd mmSRealZero prodSReal s M
// }
// def (*): MatrixMapSReal -> <Real> -> MatrixMapSReal = matrixScalarProd
// def matrixScalarProd(s: Real, M: MatrixMapSReal) -> MatrixMapSReal = {
//   matrixScalarProd mmSRealFind mmSRealAdd mmSRealZero prodSReal s M
// }
// def (*): Real -> MatrixMapSReal -> MatrixMapSReal = matrixScalarProd

def matrixProd(mfindl: MatrixFind, mfindr: MatrixFind, madd: MatrixAdd,
  mzero: MatrixZero, add: (Dyn -> Dyn -> Dyn), prod: (Dyn -> Dyn -> Dyn),
  lM : Matrix, rM: Matrix) -> Matrix = {

  def f(ij: Pos) -> Dyn = {
    def work(i: Int, a: Dyn) -> Dyn = {
      if i <= cdim lM then {
        def lpos = (fst ij, i);
        def rpos = (i, snd ij);
        work (i + 1) (add a (prod (mfindl lpos lM) (mfindr rpos rM)))
      } else a
    };

    def lpos = (fst ij, 1);
    def rpos = (1, snd ij);
    work 2 (prod (mfindl lpos lM) (mfindr rpos rM))
  };
  if (cdim lM) != (rdim rM) then { def _ = dp lM; error DIMENSION_MISSMATCH}
  else mapij madd mzero f (mzero (rdim lM, cdim rM))
}
def mmIntProd(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = {
  matrixProd mmIntFind mmIntFind mmIntAdd mmIntZero addInt prodInt lM rM
}
def (*): MatrixMapInt -> MatrixMapInt -> MatrixMapInt = mmIntProd
def mmRealProd(lM: MatrixMapReal, rM: MatrixMapReal) -> MatrixMapReal = {
  matrixProd mmRealFind mmRealFind mmRealAdd mmRealZero addReal prodReal lM rM
}
def (*): MatrixMapReal -> MatrixMapReal -> MatrixMapReal = mmRealProd
def mmSRealProd(lM: MatrixMapSReal, rM: MatrixMapSReal) -> MatrixMapSReal = {
  matrixProd mmSRealFind mmSRealFind mmSRealAdd mmSRealZero addSReal prodSReal
    lM rM
}
def (*): MatrixMapSReal -> MatrixMapSReal -> MatrixMapSReal = mmSRealProd

def matrixTranspose(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero,
  M: Matrix) -> Matrix = {

  mapij madd mzero (fun ij: Pos -> { mfind (snd ij, fst ij) M })
    (mzero (cdim M, rdim M))
}
def tr(M: MatrixMapInt) -> MatrixMapInt = {
  matrixTranspose mmIntFind mmIntAdd mmIntZero M
}
def tr(M: MatrixMapReal) -> MatrixMapReal = {
  matrixTranspose mmRealFind mmRealAdd mmRealZero M
}
def tr(M: MatrixMapSReal) -> MatrixMapSReal = {
  matrixTranspose mmSRealFind mmSRealAdd mmSRealZero M
}

def matrixVSplit(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, j: Int,
  M: Matrix) -> (Matrix, Matrix) = {

  if j <= 0 || j > cdim M then error DIMENSION_MISSMATCH
  else {
    def A = mapij madd mzero (fun ij: Pos -> mfind ij M) (mzero (rdim M, j));
    def B = mapij madd mzero (fun ij: Pos -> mfind (fst ij, snd ij + j) M)
      (mzero (rdim M, cdim M - j));
    (A, B)
  }
}
def vsplit(j: Int, M: MatrixMapInt) -> (MatrixMapInt, MatrixMapInt) = {
  matrixVSplit mmIntFind mmIntAdd mmIntZero j M
}
def vsplit(j: Int, M: MatrixMapReal) -> (MatrixMapReal, MatrixMapReal) = {
  matrixVSplit mmRealFind mmRealAdd mmRealZero j M
}

def matrixHSplit(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, i: Int,
  M: Matrix) -> (Matrix, Matrix) = {

  if i <= 0 || i > rdim M then error DIMENSION_MISSMATCH
  else {
    def A = mapij madd mzero (fun ij: Pos -> mfind ij M) (mzero (i, cdim M));
    def B = mapij madd mzero (fun ij: Pos -> mfind (fst ij + i, snd ij) M)
      (mzero (rdim M - i, cdim M));
    (A, B)
  }
}
def hsplit(i: Int, M: MatrixMapInt) -> (MatrixMapInt, MatrixMapInt) = {
  matrixHSplit mmIntFind mmIntAdd mmIntZero i M
}
def hsplit(i: Int, M: MatrixMapReal) -> (MatrixMapReal, MatrixMapReal) = {
  matrixHSplit mmRealFind mmRealAdd mmRealZero i M
}
def hsplit(i: Int, M: MatrixMapSReal) -> (MatrixMapSReal, MatrixMapSReal) = {
  matrixHSplit mmSRealFind mmSRealAdd mmSRealZero i M
}

def matrixSub(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, s: Pos,
  e: Pos, M: Matrix) -> Matrix = {

  if s > e  || s <= (0, 0) || e > (dim M) then error DIMENSION_MISSMATCH
  else mapij madd mzero (fun ij: Pos -> { mfind (ij + s - (1, 1)) M})
    (mzero (e - s + (1, 1)))
}
def sub(s: Pos, e: Pos, M: MatrixMapInt) -> MatrixMapInt = {
  matrixSub mmIntFind mmIntAdd mmIntZero s e M
}
def sub(s: Pos, e: Pos, M: MatrixMapReal) -> MatrixMapReal = {
  matrixSub mmRealFind mmRealAdd mmRealZero s e M
}
def sub(s: Pos, e: Pos, M: MatrixMapSReal) -> MatrixMapSReal = {
  matrixSub mmSRealFind mmSRealAdd mmSRealZero s e M
}

def matrixConcat(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero,
  lM: Matrix, rM: Matrix) -> Matrix = {

  def f(ij: Pos) -> Dyn = {
    if snd ij <= (cdim lM) then mfind ij lM else mfind
      (fst ij, snd ij - cdim lM) rM
  };
  if (rdim lM) != (rdim rM) then error DIMENSION_MISSMATCH
  else mapij madd mzero f (mzero (rdim lM, (cdim lM) + (cdim rM)))
}
def vconcat(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = {
  matrixConcat mmIntFind mmIntAdd mmIntZero lM rM
}
def hconcat(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = {
  tr (vconcat (tr lM) (tr rM))
}
def vconcat(lM: MatrixMapReal, rM: MatrixMapReal) -> MatrixMapReal = {
  matrixConcat mmRealFind mmRealAdd mmRealZero lM rM
}
def hconcat(lM: MatrixMapReal, rM: MatrixMapReal) -> MatrixMapReal = {
  tr (vconcat (tr lM) (tr rM))
}
def vconcat(lM: MatrixMapSReal, rM: MatrixMapSReal) -> MatrixMapSReal = {
  matrixConcat mmSRealFind mmSRealAdd mmSRealZero lM rM
}
def hconcat(lM: MatrixMapSReal, rM: MatrixMapSReal) -> MatrixMapSReal = {
  tr (vconcat (tr lM) (tr rM))
}

def matrixConcatList(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero,
  Ms: [Matrix]) -> Matrix = {

  if isEmpty Ms then error EMPTY_MATRIX_LIST
  else foldLeft (matrixConcat mfind madd mzero) (hd Ms) (tl Ms)
}
def vconcat(Ms: [MatrixMapInt]) -> MatrixMapInt = {
  matrixConcatList mmIntFind mmIntAdd mmIntZero Ms
}

def vconcat(Ms: [MatrixMapReal]) -> MatrixMapReal = {
  matrixConcatList mmRealFind mmRealAdd mmRealZero Ms
}

def vconcat(Ms: [MatrixMapSReal]) -> MatrixMapSReal = {
  matrixConcatList mmSRealFind mmSRealAdd mmSRealZero Ms
}

def rowopj(madd: MatrixAdd, f: (Int -> Dyn), i: Int, M: Matrix) -> Matrix = {
  if i <= 0 || i > rdim M then error DIMENSION_MISSMATCH
  else {
    def work(j: Int, a: Matrix) -> Matrix = {
      if j > cdim M then a else work (j + 1) (madd (i, j) (f j) a)
    };
    work 1 M
  }
}
def rowopj(f: (Int -> Int), i: Int, M: MatrixMapInt) -> MatrixMapInt = {
  rowopj mmIntAdd f i M
}
def rowopj(f: (Int -> Real), i: Int, M: MatrixMapReal) -> MatrixMapReal = {
  rowopj mmRealAdd f i M
}

def swrows(i1: Int, i2: Int, M: MatrixMap) -> MatrixMap = {
  if i1 <= 0 || i2 <= 0 || i1 > rdim M || i2 > rdim M then
    error DIMENSION_MISSMATCH
  else {
    def (Mm, d) = M;
    if (Map.mem i1 Mm) && (Map.mem i2 Mm) then {
      (Map.add i1 (Map.find i2 Mm) (Map.add i2 (Map.find i1 Mm) Mm), d)
    } else error BAD_MATRIX
  }
}

def swcols(j1: Int, j2: Int, M: MatrixMap) -> MatrixMap = {
  def (Mm, d) = M;
  def work(i: Int, a: MMap) -> MMap = {
    if i > rdim M then a
    else if _mem (i, j1) Mm && _mem (i, j2) Mm then {
      work (i + 1) (_add (i, j1) (_find (i, j2) Mm)
        (_add (i, j2) (_find (i, j1) Mm) a))
    } else if _mem (i, j1) Mm then {
      work (i + 1) (_remove (i, j1) (_add (i, j2) (_find (i, j1) Mm) a))
    } else if _mem (i, j2) Mm then {
      work (i + 1) (_add (i, j1) (_find (i, j2) Mm) (_remove (i, j2) a))
    } else work (i + 1) a
  };

  if j1 <= 0 || j2 <= 0 || j1 > cdim M || j2 > cdim M then
    error DIMENSION_MISSMATCH
  else (work 1 Mm, snd M)
}

def argmax(mfind: (Pos -> Dyn), gt: (Dyn -> Dyn -> Bool), M: Matrix) -> Pos = {
  if dim M < (1, 1) then error DIMENSION_MISSMATCH
  else {
    def f(a: (Pos, Dyn), ij: Pos) -> (Pos, Dyn) = {
      def v = mfind ij M;
      if gt v (snd a) then (ij, v) else a
    };
    fst (foldij f ((1, 1), mfind (1, 1) M) M)
  }
}
def argmax(M: MatrixMapInt) -> Pos = { argmax mmIntFind gtInt M }
def argmax(M: MatrixMapReal) -> Pos = { argmax mmRealFind gtReal M }

def rowreduce(M: MatrixMapReal) -> MatrixMapReal = {
  def sub(hk: Pos, i: Int, M: MatrixMapReal) -> MatrixMapReal = {
    def (h, k) = hk;
    def lv = find (i, k) M;
    def work(j: Int, a: MatrixMapReal) -> MatrixMapReal = {
      if j > cdim M then a
      else {
        if j == k then work (j + 1) (add (i, j) 0. a)
        else work (j + 1)
          (add (i, j) ((find (i, j) a) - lv * (find (h, j) a)) a)
      }
    };
    work k M
  };

  def rowops(hk: Pos, M: MatrixMapReal) -> MatrixMapReal = {
    def (h, k) = hk;
    def work(i: Int, a: MatrixMapReal) -> MatrixMapReal = {
      if i > rdim M then a
      else {
        if i == h then work (i + 1) a
        else work (i + 1) (sub hk i a)
      }
    };
    work 1 M
  };

  def scale(hk: Pos, M: MatrixMapReal) -> MatrixMapReal = {
    def (h, k) = hk;
    def pv = find hk M;
    def work(j: Int, a: MatrixMapReal) -> MatrixMapReal = {
      if j > cdim M then a
      else {
        work (j + 1) (add (h, j) ((find (h, j) a) / pv) a)
      }
    };
    work (k + 1) (add (h, k) 1. M)
  };

  def find_i_max(hk: Pos, M: MatrixMapReal) -> Int = {
    def gt(l: Real, r: Real) -> Bool = { abs l > abs r };
    fst (argmax mmRealFind gt (sub hk (rdim M, snd hk) M)) + fst hk - 1
  };

  def work(hk: Pos, a: MatrixMapReal) -> MatrixMapReal = {
    if (hk > dim M) then a
    else {
      def (h, k) = hk;
      def i_max = find_i_max hk a;
      if abs (find (i_max, k) a) < EPSILON then work (h, k + 1) a
      else {
        work (h + 1, k + 1) (rowops hk (scale hk (swrows h i_max a)))
      }
    }
  };
  work (1, 1) M
}

def trimzerorows(M: MatrixMap) -> MatrixMap = {
  def (Mm, d) = M;
  def work(i: Int, o: Int, a: MMap) -> MMap = {
    if i > rdim M then a
    else {
      def r = (Map.find i Mm);
      if ((Map.size r) != 0) then work (i + 1) o (Map.add (i - o) r a)
      else work (i + 1) (o + 1) a
    }
  };
  def fMm = work 1 0 (Map.empty);
  (fMm, (Map.size fMm, cdim M))
}
def trimrows(M: MatrixMapReal) -> MatrixMapReal = { trimzerorows M }

def real2sreal(M: MatrixMapReal) -> MatrixMapSReal = {
  def f(ij: Pos) -> <Real> = { find ij M };
  mapij f (mmSRealZero (dim M))
}

def real2int(M: MatrixMapReal) -> MatrixMapInt = {
  def f(ij: Pos) -> Int = { real2int (find ij M) };
  mapij f (mmIntZero (dim M))
}

def int2real(M: MatrixMapInt) -> MatrixMapReal = {
  def f(ij: Pos) -> Real = { int2real (find ij M) };
  mapij f (mmIntZero (dim M))
}

def argfind(mfind: MatrixFind, p: (Dyn -> Bool), M: Matrix) -> Pos = {
  def work(ij: Pos) -> Pos = {
    if ij > dim M then ij
    else if p (mfind ij M) then ij
    else work (_nextpos ij (dim M))
  };
  work (1, 1)
}
def argfind(p: (Int -> Bool), M: MatrixMapInt) -> Pos = {
  argfind mmIntFind p M
}
def argfind(p: (Real -> Bool), M: MatrixMapReal) -> Pos = {
  argfind mmRealFind p M
}

def listToMatrix(l: [[Real]], M: MatrixMapSReal) -> MatrixMapSReal = {
  real2sreal (listToMatrix l (mmRealZero (dim M)))
}

def skewsym(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, cs: (Dyn -> Dyn), v: Matrix) -> Matrix = {
  if dim v != (3, 1) then error DIMENSION_MISSMATCH
  else {
    def A = mzero (3, 3);
    def A = madd (1, 2) (cs (mfind (3, 1) v)) A;
    def A = madd (2, 1) (mfind (3, 1) v) A;
    def A = madd (3, 1) (cs (mfind (2, 1) v)) A;
    def A = madd (1, 3) (mfind (2, 1) v) A;
    def A = madd (2, 3) (cs (mfind (1, 1) v)) A;
    madd (3, 2) (mfind (1, 1) v) A
  }
}
def ss(v: MatrixMapInt) -> MatrixMapInt = { skewsym mmIntFind mmIntAdd mmIntZero chsgnInt v }
def ss(v: MatrixMapReal) -> MatrixMapReal = { skewsym mmRealFind mmRealAdd mmRealZero chsgnReal v }
def ss(v: MatrixMapSReal) -> MatrixMapSReal = { skewsym mmSRealFind mmSRealAdd mmSRealZero chsgnSReal v }
