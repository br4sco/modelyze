/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Base

type Pos = (Int, Int)
type MatrixMap = (Int => (Int => Dyn))
type Matrix = (MatrixMap, Pos, Dyn)
type IntMatrix = (Int => (Int => Int), Pos, Int)

def DIMENSION_MISSMATCH = "Dimension missmatch"
def iszInt = (fun v: Int -> v == 0)
def eqInt(l: Int, r: Int) -> Bool = { l == r }
def addInt(l: Int, r: Int) -> Int = { l + r }
def prodInt(l: Int, r: Int) -> Int = { l * r }

def _mem(ij: Pos, Mm: MatrixMap) -> Bool = {
  def (i, j) = ij;
  if Map.mem i Mm then Map.mem j (Map.find i Mm) else false
}

def _find(ij: Pos, Mm: MatrixMap) -> Dyn = {
  def (i, j) = ij;
  Map.find j (Map.find i Mm)
}

def _add(ij: Pos, v: Dyn, Mm: MatrixMap) -> MatrixMap = {
  def (i, j) = ij;
  Map.add i (Map.add j v (Map.find i Mm)) Mm
}

def _remove(ij: Pos, Mm: MatrixMap) -> MatrixMap = {
  def (i, j) = ij;
  Map.add i (Map.remove j (Map.find i Mm)) Mm
}

def _z(M: Matrix) = { def (_, _, z) = M; z }

def posEq(lhs: Pos, rhs: Pos) -> Bool = {
  ((fst lhs) == (fst rhs)) && ((snd lhs) == (snd rhs))
}
def (==): Pos -> Pos -> Bool = posEq

def posEq(lhs: Pos, rhs: Pos) -> Bool = { !(lhs == rhs) }
def (!=): Pos -> Pos -> Bool = posEq

def posLT(lhs: Pos, rhs: Pos) -> Bool = {
  (((fst lhs) < (fst rhs)) && ((snd lhs) <= (snd rhs))) ||
  (((fst lhs) <= (fst rhs)) && ((snd lhs) < (snd rhs)))
}
def (<): Pos -> Pos -> Bool = posLT

def posLTorEq(lhs: Pos, rhs: Pos) -> Bool = {
  (lhs == rhs) || (lhs < rhs)
}
def (<=): Pos -> Pos -> Bool = posLTorEq

def posGT(lhs: Pos, rhs: Pos) -> Bool = { rhs < lhs }
def (>): Pos -> Pos -> Bool = posGT

def posGTorEq(lhs: Pos, rhs: Pos) -> Bool = { rhs <= lhs }
def (>=): Pos -> Pos -> Bool = posGTorEq

def MatrixZero(z: Dyn, d: (Int, Int)) -> Matrix = {
  def (n, _) = d;
  def work(i: Int, a: MatrixMap) -> MatrixMap = {
    if i > 0 then work (i - 1) (Map.add i (Map.empty) a) else a
  };

  if (0, 0) >= d then error "Dimensions need to be greater than zero"
  else (work n (Map.empty), d, z)
}
def IntMatrixZero(d: (Int, Int)) -> IntMatrix = { MatrixZero 0 d }

def MatrixId(z: Dyn, id: Dyn, n: Int) -> Matrix = {
  def work(i: Int, a: MatrixMap) -> MatrixMap = { if i > 0 then work (i - 1) (_add (i, i) id a) else a };
  (work n (fst (MatrixZero z (n, n))), (n, n), z)
}
def IntMatrixId(n: Int) -> IntMatrix = { MatrixId 0 1 n }

def dim(M: Matrix) -> (Int, Int) = { snd M }
def rdim(M: Matrix) -> Int = { fst (dim M) }
def cdim(M: Matrix) -> Int = { snd (dim M) }

def MatrixSet(isz: (Dyn -> Bool), ij: Pos, v: Dyn, M: Matrix) -> Matrix = {
  def (Mm, d, z) = M;
  def (i, j) = ij;
  if (ij <= (0, 0) || ij > d) then error DIMENSION_MISSMATCH
  else {
    if isz v then {
      if _mem d Mm then (_remove ij Mm, d, z) else M
    } else (_add ij v Mm, d, z)
  }
}
def MatrixSet(ij: Pos, v: Int, M: IntMatrix) -> IntMatrix = { MatrixSet iszInt ij v M }

def MatrixGet(ij: Pos, M: Matrix) -> Dyn = {
  def (Mm, d, z) = M;
  def (i, j) = ij;
  if (ij <= (0, 0) || ij > d) then error DIMENSION_MISSMATCH
  else {
    if (_mem ij Mm) then (_find ij Mm)
    else z
  }
}

def MatrixToList(M: Matrix) -> [[Dyn]] = {
  def workRow(i: Int, j: Int, a: [Dyn]) -> [Dyn] = {
    if j > 0 then workRow i (j - 1) ((MatrixGet (i, j) M)::a) else a
  };

  def work(i: Int, a: [[Dyn]]) -> [[Dyn]] = {
    if i > 0 then work (i - 1) ((workRow i (cdim M) [])::a) else a
  };

  work (rdim M) []
}

def listToMatrix(l: [[Dyn]], M: Matrix) -> Matrix = {
  def workRow(l: [Dyn], i: Int, j: Int, a: Matrix) -> Matrix = {
    match l with
    | x::xs -> workRow xs i (j + 1) (MatrixSet (i, j) x a)
    | [] -> a
  };

  def work(l: [[Dyn]], i: Int, a: Matrix) -> Matrix = {
    match l with
    | xs::xss -> work xss (i + 1) (workRow xs i 1 a)
    | [] -> a
  };

  work l 1 M
}

def dp(M: Matrix) -> Matrix = {
  def _ = println("[");
  def _ = iter (fun r: [Dyn] -> {
      def _ = print("  "); def _ = dprint(r); ()
    }) (MatrixToList M);
  def _ = println("]");
  M
}

def forij(f: (Pos -> Dyn -> Bool), M: Matrix) -> Bool = {
  def work(c: Int) -> Bool = {
    def p = (c / (cdim M) + 1, c mod (cdim M) + 1);
    if (c + 1 > ((rdim M) * (cdim M))) then true
    else { if !(f p (MatrixGet p M)) then false else work (c + 1) }
  };
  work 0
}

def MatrixEq(eq: (Dyn -> Dyn -> Bool), lM: Matrix, rM: Matrix) -> Bool = {
  def f(p: Pos, v: Dyn) -> Bool = { eq (MatrixGet p lM) (MatrixGet p rM) };
  if (dim lM) != (dim rM) then error DIMENSION_MISSMATCH
  else forij f lM
}
def MatrixEq(lM: IntMatrix, rM: IntMatrix) -> Bool = { MatrixEq eqInt lM rM }
def (==): IntMatrix -> IntMatrix -> Bool = MatrixEq

def MatrixNEq(eq: (Dyn -> Dyn -> Bool), lM: Matrix, rM: Matrix) -> Bool = { !(MatrixEq eq lM rM) }
def MatrixNEq(lM: IntMatrix, rM: IntMatrix) -> Bool = { MatrixNEq eqInt lM rM }
def (!=): IntMatrix -> IntMatrix -> Bool = MatrixNEq

def mapij(z: Dyn, isz: (Dyn -> Bool), f: (Pos -> Dyn -> Dyn), M: Matrix) -> Matrix = {
  def work(c: Int, a: Matrix) -> Matrix = {
    def p = (c / (cdim M) + 1, c mod (cdim M) + 1);
    if c + 1 > ((rdim M) * (cdim M)) then a
    else work (c + 1) ( MatrixSet isz p (f p (MatrixGet p M)) a)
  };
  work 0 (MatrixZero z (dim M))
}
def mapij(f: (Pos -> Dyn -> Int), M: Matrix) -> IntMatrix = { mapij 0 iszInt f M }

def MatrixAdd(isz: (Dyn -> Bool), add: (Dyn -> Dyn -> Dyn), lM: Matrix, rM: Matrix) -> Matrix = {
  def f(ij: Pos, v: Dyn) -> Dyn = { add (MatrixGet ij lM) (MatrixGet ij rM) };
  if (dim lM) != (dim rM) then error DIMENSION_MISSMATCH
  else mapij (_z lM) isz f rM
}
def MatrixAdd(lM: IntMatrix, rM: IntMatrix) -> IntMatrix = { MatrixAdd iszInt addInt lM rM }
def (+): IntMatrix -> IntMatrix -> IntMatrix = MatrixAdd

def MatrixScalarProd(isz: (Dyn -> Bool), prod: (Dyn -> Dyn -> Dyn), s: Dyn, M: Matrix) -> Matrix = {
  def f(ij: Pos, v: Dyn) -> Dyn = { prod s (MatrixGet ij M) };
  mapij (_z M) isz f M
}
def MatrixScalarProd(isz: (Dyn -> Bool), prod: (Dyn -> Dyn -> Dyn), M: Matrix, s: Dyn) -> Matrix = { MatrixScalarProd isz prod s M }
def MatrixScalarProd(s: Int, M: IntMatrix) -> IntMatrix = { MatrixScalarProd iszInt prodInt s M }
def (*): Int -> IntMatrix -> IntMatrix = MatrixScalarProd
def MatrixScalarProd(M: IntMatrix, s: Int) -> IntMatrix = { MatrixScalarProd iszInt prodInt s M }
def (*): IntMatrix -> Int -> IntMatrix = MatrixScalarProd

def MatrixProd(isz: (Dyn -> Bool), add: (Dyn -> Dyn -> Dyn), prod: (Dyn -> Dyn -> Dyn), lM : Matrix, rM: Matrix) -> Matrix = {
  def f(ij: Pos, v: Dyn) -> Dyn = {
    def work(i: Int, a: Dyn) -> Dyn = {
      if i > 0 then {
        def _ = dprint(ij);
        def _ = dprint((fst ij, i));
        def _ = dprint((i, snd ij));
        def _ = dprint("==");
        work (i - 1) (add a (prod (MatrixGet (fst ij, i) lM) (MatrixGet (i, snd ij) rM)))
      } else a
    };
    def _ = dprint(ij);
    def _ = dprint((fst ij, cdim rM));
    def _ = dprint((rdim lM, snd ij));
    def _ = dprint("==");
    work ((rdim lM) - 1) (prod (MatrixGet (fst ij, cdim rM) lM) (MatrixGet (rdim lM, snd ij) rM))
  };
  if (cdim lM) != (rdim rM) then error DIMENSION_MISSMATCH
  else mapij (_z lM) isz f (MatrixZero (_z lM) (rdim lM, cdim rM))
}
def MatrixProd(lM: IntMatrix, rM: IntMatrix) -> IntMatrix = { MatrixProd iszInt addInt prodInt lM rM }
def (*): IntMatrix -> IntMatrix -> IntMatrix = MatrixProd
