/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Base

type Pos = (Int, Int)
type Matrix = (Dyn, Pos)
type MatrixFind = Pos -> Dyn -> Dyn
type MatrixAdd = Pos -> Dyn -> Dyn -> Matrix
type MatrixZero = (Int, Int) -> Matrix

// Data structures to hold sparse matrices
type MMap = (Int => (Int => Dyn))
type MatrixMap = (MMap, Pos)
type MatrixMapInt = (Int => (Int => Int), Pos)
type MatrixMapReal = (Int => (Int => Real), Pos)

def DIMENSION_MISSMATCH = "Dimension missmatch"
def BAD_MATRIX = "Bad matrix"

// Operators and functions for Ints (in lack of type polymorphism)
def iszInt = (fun v: Int -> v == 0)
def eqInt(l: Int, r: Int) -> Bool = { l == r }
def addInt(l: Int, r: Int) -> Int = { l + r }
def prodInt(l: Int, r: Int) -> Int = { l * r }
def chsgnInt(v: Int) -> Int = { -v }

// Operators and functions for Reals (in lack of type polymorphism)
def iszReal = (fun v: Real -> v == 0.)
def eqReal(l: Real, r: Real) -> Bool = { l == r }
def addReal(l: Real, r: Real) -> Real = { l + r }
def prodReal(l: Real, r: Real) -> Real = { l * r }
def chsgnReal(v: Real) -> Real = { -v }

def _mem(ij: Pos, Mm: MMap) -> Bool = {
  def (i, j) = ij;
  if Map.mem i Mm then Map.mem j (Map.find i Mm) else false
}

def _find(ij: Pos, Mm: MMap) -> Dyn = {
  def (i, j) = ij;
  Map.find j (Map.find i Mm)
}

def _add(ij: Pos, v: Dyn, Mm: MMap) -> MMap = {
  def (i, j) = ij;
  Map.add i (Map.add j v (Map.find i Mm)) Mm
}

def _remove(ij: Pos, Mm: MMap) -> MMap = {
  def (i, j) = ij;
  Map.add i (Map.remove j (Map.find i Mm)) Mm
}

def posEq(lhs: Pos, rhs: Pos) -> Bool = {
  ((fst lhs) == (fst rhs)) && ((snd lhs) == (snd rhs))
}
def (==): Pos -> Pos -> Bool = posEq

def posEq(lhs: Pos, rhs: Pos) -> Bool = { !(lhs == rhs) }
def (!=): Pos -> Pos -> Bool = posEq

def posLT(lhs: Pos, rhs: Pos) -> Bool = {
  (fst rhs > fst lhs || snd rhs > snd lhs)
}
def (<): Pos -> Pos -> Bool = posLT

def posLTorEq(lhs: Pos, rhs: Pos) -> Bool = {
  (lhs == rhs) || (lhs < rhs)
}
def (<=): Pos -> Pos -> Bool = posLTorEq

def posGT(lhs: Pos, rhs: Pos) -> Bool = { rhs < lhs }
def (>): Pos -> Pos -> Bool = posGT

def posGTorEq(lhs: Pos, rhs: Pos) -> Bool = { rhs <= lhs }
def (>=): Pos -> Pos -> Bool = posGTorEq

def posAdd(lhs: Pos, rhs: Pos) -> Pos = { (fst lhs + fst rhs, snd lhs + snd rhs) }
def (+): Pos -> Pos -> Pos = posAdd

def posSub(lhs: Pos, rhs: Pos) -> Pos = { (fst lhs - fst rhs, snd lhs - snd rhs) }
def (-): Pos -> Pos -> Pos = posSub

def _nextpos(ij: Pos, mn: Pos) -> Pos = {
  if ij > mn then error DIMENSION_MISSMATCH
  else { if snd ij == snd mn then (fst ij + 1, 1) else (fst ij, snd ij + 1) }
}

def mmZero(d: (Int, Int)) -> MatrixMap = {
  def (n, _) = d;
  def work(i: Int, a: MMap) -> MMap = {
    if i > 0 then work (i - 1) (Map.add i (Map.empty) a) else a
  };

  if (0, 0) > d then error "Dimensions need to be greater or equal to zero"
  else (work n (Map.empty), d)
}
def mmIntZero(d: (Int, Int)) -> MatrixMapInt = { mmZero d }
def mmRealZero(d: (Int, Int)) -> MatrixMapReal = { mmZero d }

def mmId(id: Dyn, n: Int) -> MatrixMap = {
  def work(i: Int, a: MMap) -> MMap = { if i > 0 then work (i - 1) (_add (i, i) id a) else a };
  (work n (fst (mmZero (n, n))), (n, n))
}
def mmIntId(n: Int) -> MatrixMapInt = { mmId 1 n }
def mmRealId(n: Int) -> MatrixMapReal = { mmId 1. n }

def dim(M: Matrix) -> (Int, Int) = { snd M }
def rdim(M: Matrix) -> Int = { fst (dim M) }
def cdim(M: Matrix) -> Int = { snd (dim M) }

def mmAdd(z: Dyn, isz: (Dyn -> Bool), ij: Pos, v: Dyn, M: MatrixMap) -> MatrixMap = {
  def (Mm, d) = M;
  if (ij <= (0, 0) || ij > d) then error DIMENSION_MISSMATCH
  else {
    if isz v then {
      if _mem d Mm then (_remove ij Mm, d) else M
    } else (_add ij v Mm, d)
  }
}
def mmIntAdd(ij: Pos, v: Int, M: MatrixMapInt) -> MatrixMapInt = { mmAdd 0 iszInt ij v M }
def add: Pos -> Int -> MatrixMapInt -> MatrixMapInt = mmIntAdd
def mmRealAdd(ij: Pos, v: Real, M: MatrixMapReal) -> MatrixMapReal = { mmAdd 0. iszReal ij v M }
def add: Pos -> Real -> MatrixMapReal -> MatrixMapReal = mmRealAdd

def mmFind(z: Dyn, ij: Pos, M: MatrixMap) -> Dyn = {
  def (Mm, d) = M;
  def (i, j) = ij;
  if (ij <= (0, 0) || ij > d) then error DIMENSION_MISSMATCH
  else {
    if (_mem ij Mm) then (_find ij Mm)
    else z
  }
}
def mmIntFind(ij: Pos, M: MatrixMapInt) -> Int = { mmFind 0 ij M }
def find: Pos -> MatrixMapInt -> Int = mmIntFind
def mmRealFind(ij: Pos, M: MatrixMapReal) -> Real = { mmFind 0. ij M }
def find: Pos -> MatrixMapReal -> Real = mmRealFind

def matrixToList(mfind: MatrixFind, M: Matrix) -> [[Dyn]] = {
  def workRow(i: Int, j: Int, a: [Dyn]) -> [Dyn] = {
    if j > 0 then workRow i (j - 1) ((mfind (i, j) M)::a) else a
  };

  def work(i: Int, a: [[Dyn]]) -> [[Dyn]] = {
    if i > 0 then work (i - 1) ((workRow i (cdim M) [])::a) else a
  };

  work (rdim M) []
}

def listToMatrix(madd: MatrixAdd, l: [[Dyn]], M: Matrix) -> Matrix = {
  def workRow(l: [Dyn], i: Int, j: Int, a: Matrix) -> Matrix = {
    match l with
    | x::xs -> workRow xs i (j + 1) (madd (i, j) x a)
    | [] -> a
  };

  def work(l: [[Dyn]], i: Int, a: Matrix) -> Matrix = {
    match l with
    | xs::xss -> work xss (i + 1) (workRow xs i 1 a)
    | [] -> a
  };

  work l 1 M
}
def listToMatrix(l: [[Int]], M: MatrixMapInt) -> MatrixMapInt = { listToMatrix mmIntAdd l M }
def listToMatrix(l: [[Real]], M: MatrixMapReal) -> MatrixMapReal = { listToMatrix mmRealAdd l M }

def dp(mfind: MatrixFind, M: Matrix) -> Matrix = {
  def _ = println("[");
  def _ = iter (fun r: [Dyn] -> {
      def _ = print("  "); def _ = dprint(r); ()
    }) (matrixToList mfind M);
  def _ = print("] d = ");
  def _ = dprint(dim M);
  M
}

def forij(f: (Pos -> Bool), M: Matrix) -> Bool = {
  def work(c: Int) -> Bool = {
    def p = (c / (cdim M) + 1, c mod (cdim M) + 1);
    if (c + 1 > ((rdim M) * (cdim M))) then true
    else { if !(f p) then false else work (c + 1) }
  };
  work 0
}

def matrixEq(mfind: MatrixFind, eq: (Dyn -> Dyn -> Bool), lM: Matrix, rM: Matrix) -> Bool = {
  if (dim lM) != (dim rM) then error DIMENSION_MISSMATCH
  else forij (fun ij: Pos -> { eq (mfind ij lM) (mfind ij rM) }) lM
}
def matrixEq(lM: MatrixMapInt, rM: MatrixMapInt) -> Bool = { matrixEq mmIntFind eqInt lM rM }
def (==): MatrixMapInt -> MatrixMapInt -> Bool = matrixEq
def matrixEq(lM: MatrixMapReal, rM: MatrixMapReal) -> Bool = { matrixEq mmRealFind eqReal lM rM }
def (==): MatrixMapReal -> MatrixMapReal -> Bool = matrixEq

def matrixNEq(mfind: MatrixFind, eq: (Dyn -> Dyn -> Bool), lM: Matrix, rM: Matrix) -> Bool = { !(matrixEq mfind eq lM rM) }
def matrixNEq(lM: MatrixMapInt, rM: MatrixMapInt) -> Bool = { matrixNEq mmIntFind eqInt lM rM }
def (!=): MatrixMapInt -> MatrixMapInt -> Bool = matrixNEq
def matrixNEq(lM: MatrixMapReal, rM: MatrixMapReal) -> Bool = { matrixNEq mmRealFind eqReal lM rM }
def (!=): MatrixMapReal -> MatrixMapReal -> Bool = matrixNEq

def mapij(madd: MatrixAdd, mzero: MatrixZero, f: (Pos -> Dyn), M: Matrix) -> Matrix = {

  def work(ij: Pos, a: Matrix) -> Matrix = {
    if dim M < ij then a
    else work (_nextpos ij (dim M)) (madd ij (f ij) a)
  };
  work (1, 1) (mzero (dim M))
}
def mapij(f: (Pos -> Int), M: Matrix) -> MatrixMapInt = { mapij mmIntAdd mmIntZero f M }
def mapij(f: (Pos -> Real), M: Matrix) -> MatrixMapReal = { mapij mmRealAdd mmRealZero f M }

// def foldij(f: (Dyn -> Pos -> Dyn), a: Dyn, M: Matrix) -> Dyn = {
//   def work(ij: Pos, a: Dyn) -> Dyn = {
    
//   };
// }

def matrixAddition(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, add: (Dyn -> Dyn -> Dyn), lM: Matrix, rM: Matrix) -> Matrix = {
  if (dim lM) != (dim rM) then error DIMENSION_MISSMATCH
  else mapij madd mzero (fun ij: Pos -> { add (mfind ij lM) (mfind ij rM) }) rM
}
def matrixAddition(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = { matrixAddition mmIntFind mmIntAdd mmIntZero addInt lM rM }
def (+): MatrixMapInt -> MatrixMapInt -> MatrixMapInt = matrixAddition
def matrixAddition(lM: MatrixMapReal, rM: MatrixMapReal) -> MatrixMapReal = { matrixAddition mmRealFind mmRealAdd mmRealZero addReal lM rM }
def (+): MatrixMapReal -> MatrixMapReal -> MatrixMapReal = matrixAddition

def matrixChsgn(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, cs: (Dyn -> Dyn), M: Matrix) -> Matrix = {
  mapij madd mzero (fun ij: Pos -> cs (mfind ij M)) M
}
def matrixChsgn(M: MatrixMapInt) -> MatrixMapInt = { matrixChsgn mmIntFind mmIntAdd mmIntZero chsgnInt M }
def (--): MatrixMapInt -> MatrixMapInt = matrixChsgn
def matrixChsgn(M: MatrixMapReal) -> MatrixMapReal = { matrixChsgn mmRealFind mmRealAdd mmRealZero chsgnReal M }
def (--): MatrixMapReal -> MatrixMapReal = matrixChsgn

def matrixSubst(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, add: (Dyn -> Dyn -> Dyn), cs: (Dyn -> Dyn), lM: Matrix, rM: Matrix) -> Matrix = {
  matrixAddition mfind madd mzero add lM (matrixChsgn mfind madd mzero cs rM)
}
def matrixSubst(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = { matrixSubst mmIntFind mmIntAdd mmIntZero addInt chsgnInt lM rM }
def (-): MatrixMapInt -> MatrixMapInt -> MatrixMapInt = matrixSubst
def matrixSubst(lM: MatrixMapReal, rM: MatrixMapReal) -> MatrixMapReal = { matrixSubst mmRealFind mmRealAdd mmRealZero addReal chsgnReal lM rM }
def (-): MatrixMapReal -> MatrixMapReal -> MatrixMapReal = matrixSubst

def matrixScalarProd(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, prod: (Dyn -> Dyn -> Dyn), s: Dyn, M: Matrix) -> Matrix = {
  mapij madd mzero (fun ij: Pos -> { prod s (mfind ij M) }) M
}
def matrixScalarProd(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, prod: (Dyn -> Dyn -> Dyn), M: Matrix, s: Dyn) -> Matrix = { matrixScalarProd mfind madd mzero prod s M }
def matrixScalarProd(s: Int, M: MatrixMapInt) -> MatrixMapInt = { matrixScalarProd mmIntFind mmIntAdd mmIntZero prodInt s M }
def (*): Int -> MatrixMapInt -> MatrixMapInt = matrixScalarProd
def matrixScalarProd(M: MatrixMapInt, s: Int) -> MatrixMapInt = { matrixScalarProd mmIntFind mmIntAdd mmIntZero prodInt s M }
def (*): MatrixMapInt -> Int -> MatrixMapInt = matrixScalarProd
def matrixScalarProd(s: Real, M: MatrixMapReal) -> MatrixMapReal = { matrixScalarProd mmRealFind mmRealAdd mmRealZero prodReal s M }
def (*): Real -> MatrixMapReal -> MatrixMapReal = matrixScalarProd
def matrixScalarProd(M: MatrixMapReal, s: Real) -> MatrixMapReal = { matrixScalarProd mmRealFind mmRealAdd mmRealZero prodReal s M }
def (*): MatrixMapReal -> Real -> MatrixMapReal = matrixScalarProd

def matrixProd(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, add: (Dyn -> Dyn -> Dyn), prod: (Dyn -> Dyn -> Dyn), lM : Matrix, rM: Matrix) -> Matrix = {
  def f(ij: Pos) -> Dyn = {
    def work(i: Int, a: Dyn) -> Dyn = {
      if i > 0 then {
        def lpos = (fst ij, i);
        def rpos = (i, snd ij);
        work (i - 1) (add a (prod (mfind lpos lM) (mfind rpos rM)))
      } else a
    };

    def lpos = (fst ij, cdim lM);
    def rpos = (rdim rM, snd ij);
    work ((cdim lM) - 1) (prod (mfind lpos lM) (mfind rpos rM))
  };
  if (cdim lM) != (rdim rM) then error DIMENSION_MISSMATCH
  else mapij madd mzero f (mzero (rdim lM, cdim rM))
}
def matrixProd(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = { matrixProd mmIntFind mmIntAdd mmIntZero addInt prodInt lM rM }
def (*): MatrixMapInt -> MatrixMapInt -> MatrixMapInt = matrixProd
def matrixProd(lM: MatrixMapReal, rM: MatrixMapReal) -> MatrixMapReal = { matrixProd mmRealFind mmRealAdd mmRealZero addReal prodReal lM rM }
def (*): MatrixMapReal -> MatrixMapReal -> MatrixMapReal = matrixProd

def matrixTranspose(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, M: Matrix) -> Matrix = {
  mapij madd mzero (fun ij: Pos -> { mfind (snd ij, fst ij) M }) (mzero (cdim M, rdim M))
}
def tr(M: MatrixMapInt) -> MatrixMapInt = { matrixTranspose mmIntFind mmIntAdd mmIntZero M }
def tr(M: MatrixMapReal) -> MatrixMapReal = { matrixTranspose mmRealFind mmRealAdd mmRealZero M }

def matrixSub(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, s: Pos, e: Pos, M: Matrix) -> Matrix = {
  if s > e  || s <= (0, 0) || e > (dim M) then error DIMENSION_MISSMATCH
  else mapij madd mzero (fun ij: Pos -> { mfind (ij + s - (1, 1)) M}) (mzero (e - s + (1, 1)))
}
def sub(s: Pos, e: Pos, M: MatrixMapInt) -> MatrixMapInt = { matrixSub mmIntFind mmIntAdd mmIntZero s e M }
def sub(s: Pos, e: Pos, M: MatrixMapReal) -> MatrixMapReal = { matrixSub mmRealFind mmRealAdd mmRealZero s e M }

def matrixConcat(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, lM: Matrix, rM: Matrix) -> Matrix = {
  def f(ij: Pos) -> Dyn = {
    if ij <= (dim lM) then mfind ij lM else mfind (fst ij, snd ij - cdim lM) rM
  };
  if (rdim lM) != (rdim rM) then error DIMENSION_MISSMATCH
  else mapij madd mzero f (mzero (rdim lM, (cdim lM) + (cdim rM)))
}
def vconcat(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = { matrixConcat mmIntFind mmIntAdd mmIntZero lM rM }
def hconcat(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = { tr (vconcat (tr lM) (tr rM)) }
def vconcat(lM: MatrixMapReal, rM: MatrixMapReal) -> MatrixMapReal = { matrixConcat mmRealFind mmRealAdd mmRealZero lM rM }
def hconcat(lM: MatrixMapReal, rM: MatrixMapReal) -> MatrixMapReal = { tr (vconcat (tr lM) (tr rM)) }

def rowopj(madd: MatrixAdd, f: (Int -> Dyn), i: Int, M: Matrix) -> Matrix = {
  if i <= 0 || i > rdim M then error DIMENSION_MISSMATCH
  else {
    def work(j: Int, a: Matrix) -> Matrix = {
      if j > cdim M then a else work (j + 1) (madd (i, j) (f j) a)
    };
    work 1 M
  }
}
def rowopj(f: (Int -> Int), i: Int, M: MatrixMapInt) -> MatrixMapInt = { rowopj mmIntAdd f i M }
def rowopj(f: (Int -> Real), i: Int, M: MatrixMapReal) -> MatrixMapReal = { rowopj mmRealAdd f i M }

def swrows(i1: Int, i2: Int, M: MatrixMap) -> MatrixMap = {
  if i1 <= 0 || i2 <= 0 || i1 > rdim M || i2 > rdim M then error DIMENSION_MISSMATCH
  else {
    def (Mm, d) = M;
    if (Map.mem i1 Mm) && (Map.mem i2 Mm) then {
      (Map.add i1 (Map.find i2 Mm) (Map.add i2 (Map.find i1 Mm) Mm), d)
    } else error BAD_MATRIX
  }
}

def rowFindFirst(p: (Dyn -> Bool), i: Int, M: MatrixMap) -> Int = {
  if i <= 0 || i > rdim M then error DIMENSION_MISSMATCH
  else {
    def work(l: [(Int, Dyn)], a: Int) -> Int = {
      match l with
      | e::es -> if p (snd e) then work es (min a (fst e)) else work es a
      | [] -> a
    };
    work (Map.toList (Map.find i (fst M))) ((rdim M) + 1)
  }
}
