/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Base

type Pos = (Int, Int)
type Matrix = (Dyn, Pos)
type MMap = (Int => (Int => Dyn))
type MatrixMap = (MMap, Pos)
type MatrixMapInt = (Int => (Int => Int), Pos)
type MatrixFind = Pos -> Dyn -> Dyn
type MatrixAdd = Pos -> Dyn -> Dyn -> Matrix
type MatrixZero = (Int, Int) -> Matrix
type MatrixId = Int -> Matrix

def DIMENSION_MISSMATCH = "Dimension missmatch"
def iszInt = (fun v: Int -> v == 0)
def eqInt(l: Int, r: Int) -> Bool = { l == r }
def addInt(l: Int, r: Int) -> Int = { l + r }
def prodInt(l: Int, r: Int) -> Int = { l * r }
def chsgnInt(v: Int) -> Int = { -v }

def _mem(ij: Pos, Mm: MMap) -> Bool = {
  def (i, j) = ij;
  if Map.mem i Mm then Map.mem j (Map.find i Mm) else false
}

def _find(ij: Pos, Mm: MMap) -> Dyn = {
  def (i, j) = ij;
  Map.find j (Map.find i Mm)
}

def _add(ij: Pos, v: Dyn, Mm: MMap) -> MMap = {
  def (i, j) = ij;
  Map.add i (Map.add j v (Map.find i Mm)) Mm
}

def _remove(ij: Pos, Mm: MMap) -> MMap = {
  def (i, j) = ij;
  Map.add i (Map.remove j (Map.find i Mm)) Mm
}

def posEq(lhs: Pos, rhs: Pos) -> Bool = {
  ((fst lhs) == (fst rhs)) && ((snd lhs) == (snd rhs))
}
def (==): Pos -> Pos -> Bool = posEq

def posEq(lhs: Pos, rhs: Pos) -> Bool = { !(lhs == rhs) }
def (!=): Pos -> Pos -> Bool = posEq

def posLT(lhs: Pos, rhs: Pos) -> Bool = {
  (((fst lhs) < (fst rhs)) && ((snd lhs) <= (snd rhs))) ||
  (((fst lhs) <= (fst rhs)) && ((snd lhs) < (snd rhs)))
}
def (<): Pos -> Pos -> Bool = posLT

def posLTorEq(lhs: Pos, rhs: Pos) -> Bool = {
  (lhs == rhs) || (lhs < rhs)
}
def (<=): Pos -> Pos -> Bool = posLTorEq

def posGT(lhs: Pos, rhs: Pos) -> Bool = { rhs < lhs }
def (>): Pos -> Pos -> Bool = posGT

def posGTorEq(lhs: Pos, rhs: Pos) -> Bool = { rhs <= lhs }
def (>=): Pos -> Pos -> Bool = posGTorEq

def posAdd(lhs: Pos, rhs: Pos) -> Pos = { (fst lhs + fst rhs, snd lhs + snd rhs) }
def (+): Pos -> Pos -> Pos = posAdd

def posSub(lhs: Pos, rhs: Pos) -> Pos = { (fst lhs - fst rhs, snd lhs - snd rhs) }
def (-): Pos -> Pos -> Pos = posSub

def mmZero(d: (Int, Int)) -> MatrixMap = {
  def (n, _) = d;
  def work(i: Int, a: MMap) -> MMap = {
    if i > 0 then work (i - 1) (Map.add i (Map.empty) a) else a
  };

  if (0, 0) >= d then error "Dimensions need to be greater than zero"
  else (work n (Map.empty), d)
}
def mmIntZero(d: (Int, Int)) -> MatrixMapInt = { mmZero d }

def mmId(id: Dyn, n: Int) -> MatrixMap = {
  def work(i: Int, a: MMap) -> MMap = { if i > 0 then work (i - 1) (_add (i, i) id a) else a };
  (work n (fst (mmZero (n, n))), (n, n))
}
def mmIntId(n: Int) -> MatrixMapInt = { mmId 1 n }

def dim(M: Matrix) -> (Int, Int) = { snd M }
def rdim(M: Matrix) -> Int = { fst (dim M) }
def cdim(M: Matrix) -> Int = { snd (dim M) }

def mmAdd(z: Dyn, isz: (Dyn -> Bool), ij: Pos, v: Dyn, M: MatrixMap) -> MatrixMap = {
  def (Mm, d) = M;
  if (ij <= (0, 0) || ij > d) then error DIMENSION_MISSMATCH
  else {
    if isz v then {
      if _mem d Mm then (_remove ij Mm, d) else M
    } else (_add ij v Mm, d)
  }
}
def mmIntAdd(ij: Pos, v: Int, M: MatrixMapInt) -> MatrixMapInt = { mmAdd 0 iszInt ij v M }
def add: Pos -> Int -> MatrixMapInt -> MatrixMapInt = mmIntAdd

def mmFind(z: Dyn, ij: Pos, M: MatrixMap) -> Dyn = {
  def (Mm, d) = M;
  def (i, j) = ij;
  if (ij <= (0, 0) || ij > d) then error DIMENSION_MISSMATCH
  else {
    if (_mem ij Mm) then (_find ij Mm)
    else z
  }
}
def mmIntFind(ij: Pos, M: MatrixMapInt) -> Int = { mmFind 0 ij M }
def find: Pos -> MatrixMapInt -> Int = mmIntFind

def matrixToList(mfind: MatrixFind, M: Matrix) -> [[Dyn]] = {
  def workRow(i: Int, j: Int, a: [Dyn]) -> [Dyn] = {
    if j > 0 then workRow i (j - 1) ((mfind (i, j) M)::a) else a
  };

  def work(i: Int, a: [[Dyn]]) -> [[Dyn]] = {
    if i > 0 then work (i - 1) ((workRow i (cdim M) [])::a) else a
  };

  work (rdim M) []
}

def listToMatrix(madd: MatrixAdd, l: [[Dyn]], M: Matrix) -> Matrix = {
  def workRow(l: [Dyn], i: Int, j: Int, a: Matrix) -> Matrix = {
    match l with
    | x::xs -> workRow xs i (j + 1) (madd (i, j) x a)
    | [] -> a
  };

  def work(l: [[Dyn]], i: Int, a: Matrix) -> Matrix = {
    match l with
    | xs::xss -> work xss (i + 1) (workRow xs i 1 a)
    | [] -> a
  };

  work l 1 M
}
def listToMatrix(l: [[Int]], M: MatrixMapInt) -> MatrixMapInt = { listToMatrix mmIntAdd l M }

def dp(mfind: MatrixFind, M: Matrix) -> Matrix = {
  def _ = println("[");
  def _ = iter (fun r: [Dyn] -> {
      def _ = print("  "); def _ = dprint(r); ()
    }) (matrixToList mfind M);
  def _ = print("] d = ");
  def _ = dprint(dim M);
  M
}

def forij(mfind: MatrixFind, f: (Pos -> Dyn -> Bool), M: Matrix) -> Bool = {
  def work(c: Int) -> Bool = {
    def p = (c / (cdim M) + 1, c mod (cdim M) + 1);
    if (c + 1 > ((rdim M) * (cdim M))) then true
    else { if !(f p (mfind p M)) then false else work (c + 1) }
  };
  work 0
}

def matrixEq(mfind: MatrixFind, eq: (Dyn -> Dyn -> Bool), lM: Matrix, rM: Matrix) -> Bool = {
  def f(p: Pos, v: Dyn) -> Bool = { eq (mfind p lM) (mfind p rM) };
  if (dim lM) != (dim rM) then error DIMENSION_MISSMATCH
  else forij mfind f lM
}
def matrixEq(lM: MatrixMapInt, rM: MatrixMapInt) -> Bool = { matrixEq mmIntFind eqInt lM rM }
def (==): MatrixMapInt -> MatrixMapInt -> Bool = matrixEq

def matrixNEq(mfind: MatrixFind, eq: (Dyn -> Dyn -> Bool), lM: Matrix, rM: Matrix) -> Bool = { !(matrixEq mfind eq lM rM) }
def matrixNEq(lM: MatrixMapInt, rM: MatrixMapInt) -> Bool = { matrixNEq mmIntFind eqInt lM rM }
def (!=): MatrixMapInt -> MatrixMapInt -> Bool = matrixNEq

def mapij(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, f: (Pos -> Dyn -> Dyn), M: Matrix) -> Matrix = {
  def work(c: Int, a: Matrix) -> Matrix = {
    def p = (c / (cdim M) + 1, c mod (cdim M) + 1);
    if c + 1 > ((rdim M) * (cdim M)) then a
    else work (c + 1) ( madd p (f p (mfind p M)) a)
  };
  work 0 (mzero (dim M))
}
def mapij(f: (Pos -> Dyn -> Int), M: Matrix) -> MatrixMapInt = { mapij mmIntFind mmIntAdd mmIntZero f M }

def matrixAdd(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, add: (Dyn -> Dyn -> Dyn), lM: Matrix, rM: Matrix) -> Matrix = {
  def f(ij: Pos, v: Dyn) -> Dyn = { add (mfind ij lM) (mfind ij rM) };
  if (dim lM) != (dim rM) then error DIMENSION_MISSMATCH
  else mapij mfind madd mzero f rM
}
def matrixAdd(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = { matrixAdd mmIntFind mmIntAdd mmIntZero addInt lM rM }
def (+): MatrixMapInt -> MatrixMapInt -> MatrixMapInt = matrixAdd

def matrixChsgn(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, cs: (Dyn -> Dyn), M: Matrix) -> Matrix = {
  def f(ij: Pos, v: Dyn) -> Dyn = { cs v };
  mapij mfind madd mzero f M
}
def matrixChsgn(M: MatrixMapInt) -> MatrixMapInt = { matrixChsgn mmIntFind mmIntAdd mmIntZero chsgnInt M }
def (--): MatrixMapInt -> MatrixMapInt = matrixChsgn

def matrixSubst(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, add: (Dyn -> Dyn -> Dyn), cs: (Dyn -> Dyn), lM: Matrix, rM: Matrix) -> Matrix = {
  matrixAdd mfind madd mzero add lM (matrixChsgn mfind madd mzero cs rM)
}
def matrixSubst(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = { matrixSubst mmIntFind mmIntAdd mmIntZero addInt chsgnInt lM rM }
def (-): MatrixMapInt -> MatrixMapInt -> MatrixMapInt = matrixSubst

def matrixScalarProd(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, prod: (Dyn -> Dyn -> Dyn), s: Dyn, M: Matrix) -> Matrix = {
  def f(ij: Pos, v: Dyn) -> Dyn = { prod s (mfind ij M) };
  mapij mfind madd mzero f M
}
def matrixScalarProd(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, prod: (Dyn -> Dyn -> Dyn), M: Matrix, s: Dyn) -> Matrix = { matrixScalarProd mfind madd mzero prod s M }
def matrixScalarProd(s: Int, M: MatrixMapInt) -> MatrixMapInt = { matrixScalarProd mmIntFind mmIntAdd mmIntZero prodInt s M }
def (*): Int -> MatrixMapInt -> MatrixMapInt = matrixScalarProd
def matrixScalarProd(M: MatrixMapInt, s: Int) -> MatrixMapInt = { matrixScalarProd mmIntFind mmIntAdd mmIntZero prodInt s M }
def (*): MatrixMapInt -> Int -> MatrixMapInt = matrixScalarProd

def matrixProd(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, add: (Dyn -> Dyn -> Dyn), prod: (Dyn -> Dyn -> Dyn), lM : Matrix, rM: Matrix) -> Matrix = {
  def f(ij: Pos, v: Dyn) -> Dyn = {
    def work(i: Int, a: Dyn) -> Dyn = {
      if i > 0 then {
        def lpos = (fst ij, i);
        def rpos = (i, snd ij);
        work (i - 1) (add a (prod (mfind lpos lM) (mfind rpos rM)))
      } else a
    };

    def lpos = (fst ij, cdim lM);
    def rpos = (rdim rM, snd ij);
    work ((cdim lM) - 1) (prod (mfind lpos lM) (mfind rpos rM))
  };
  if (cdim lM) != (rdim rM) then error DIMENSION_MISSMATCH
  else mapij mfind madd mzero f (mzero (rdim lM, cdim rM))
}
def matrixProd(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = { matrixProd mmIntFind mmIntAdd mmIntZero addInt prodInt lM rM }
def (*): MatrixMapInt -> MatrixMapInt -> MatrixMapInt = matrixProd

def matrixTranspose(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, M: Matrix) -> Matrix = {
  def f(ij: Pos, v: Dyn) -> Dyn = { mfind (snd ij, fst ij) M };
  mapij mfind madd mzero f (mzero (cdim M, rdim M))
}
def tr(M: MatrixMapInt) -> MatrixMapInt = { matrixTranspose mmIntFind mmIntAdd mmIntZero M }

def matrixSub(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, s: Pos, e: Pos, M: Matrix) -> Matrix = {
  def f(ij: Pos, v: Dyn) -> Dyn = { mfind (ij + s - (1, 1)) M};
  if s > e  || s <= (0, 0) || e > (dim M) then error DIMENSION_MISSMATCH
  else mapij mfind madd mzero f (mzero (e - s + (1, 1)))
}
def sub(s: Pos, e: Pos, M: MatrixMapInt) -> MatrixMapInt = { matrixSub mmIntFind mmIntAdd mmIntZero s e M }

def matrixConcat(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, lM: Matrix, rM: Matrix) -> Matrix = {
  def f(ij: Pos, v: Dyn) -> Dyn = {
    if ij <= (dim lM) then mfind ij lM else mfind (fst ij, snd ij - cdim lM) rM
  };
  if (rdim lM) != (rdim rM) then error DIMENSION_MISSMATCH
  else mapij mfind madd mzero f (mzero (rdim lM, (cdim lM) + (cdim rM)))
}
def vconcat(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = { matrixConcat mmIntFind mmIntAdd mmIntZero lM rM }
def hconcat(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = { tr (vconcat (tr lM) (tr rM)) }
