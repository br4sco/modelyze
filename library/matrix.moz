/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Base

def EPSILON = 1.e-15

type Pos = (Int, Int)
type Matrix = (Dyn, Pos)
type MatrixFind = Pos -> Dyn -> Dyn
type MatrixAdd = Pos -> Dyn -> Dyn -> Matrix
type MatrixZero = (Int, Int) -> Matrix

// Data structures to hold sparse matrices
type MMap = (Int => (Int => Dyn))
type MatrixMap = (MMap, Pos)
type MatrixMapInt = (Int => (Int => Int), Pos)
type MatrixMapReal = (Int => (Int => Real), Pos)

def DIMENSION_MISSMATCH = "Dimension missmatch"
def BAD_MATRIX = "Bad matrix"

// Operators and functions for Ints (in lack of type polymorphism)
def iszInt(v: Int) -> Bool = { v == 0 }
def eqInt(l: Int, r: Int) -> Bool = { l == r }
def addInt(l: Int, r: Int) -> Int = { l + r }
def prodInt(l: Int, r: Int) -> Int = { l * r }
def chsgnInt(v: Int) -> Int = { -v }
def gtInt(l: Int, r: Int) -> Bool = { l > r }

// Operators and functions for Reals (in lack of type polymorphism)
def iszReal(v: Real) -> Bool = { v == 0. }
def eqReal(l: Real, r: Real) -> Bool = { l == r }
def addReal(l: Real, r: Real) -> Real = { l + r }
def prodReal(l: Real, r: Real) -> Real = { l * r }
def chsgnReal(v: Real) -> Real = { -v }
def gtReal(l: Real, r: Real) -> Bool = { l > r }

def _mem(ij: Pos, Mm: MMap) -> Bool = {
  def (i, j) = ij;
  if Map.mem i Mm then Map.mem j (Map.find i Mm) else false
}

def _find(ij: Pos, Mm: MMap) -> Dyn = {
  def (i, j) = ij;
  Map.find j (Map.find i Mm)
}

def _add(ij: Pos, v: Dyn, Mm: MMap) -> MMap = {
  def (i, j) = ij;
  Map.add i (Map.add j v (Map.find i Mm)) Mm
}

def _remove(ij: Pos, Mm: MMap) -> MMap = {
  def (i, j) = ij;
  Map.add i (Map.remove j (Map.find i Mm)) Mm
}

def posEq(lhs: Pos, rhs: Pos) -> Bool = {
  ((fst lhs) == (fst rhs)) && ((snd lhs) == (snd rhs))
}
def (==): Pos -> Pos -> Bool = posEq

def posEq(lhs: Pos, rhs: Pos) -> Bool = { !(lhs == rhs) }
def (!=): Pos -> Pos -> Bool = posEq

def posLT(lhs: Pos, rhs: Pos) -> Bool = {
  (fst rhs > fst lhs || snd rhs > snd lhs)
}
def (<): Pos -> Pos -> Bool = posLT

def posLTorEq(lhs: Pos, rhs: Pos) -> Bool = {
  (lhs == rhs) || (lhs < rhs)
}
def (<=): Pos -> Pos -> Bool = posLTorEq

def posGT(lhs: Pos, rhs: Pos) -> Bool = { rhs < lhs }
def (>): Pos -> Pos -> Bool = posGT

def posGTorEq(lhs: Pos, rhs: Pos) -> Bool = { rhs <= lhs }
def (>=): Pos -> Pos -> Bool = posGTorEq

def posAdd(lhs: Pos, rhs: Pos) -> Pos = {
  (fst lhs + fst rhs, snd lhs + snd rhs)
}
def (+): Pos -> Pos -> Pos = posAdd

def posSub(lhs: Pos, rhs: Pos) -> Pos = {
  (fst lhs - fst rhs, snd lhs - snd rhs)
}
def (-): Pos -> Pos -> Pos = posSub

def _nextpos(ij: Pos, mn: Pos) -> Pos = {
  if ij > mn then error DIMENSION_MISSMATCH
  else { if snd ij == snd mn then (fst ij + 1, 1) else (fst ij, snd ij + 1) }
}

def mmZero(d: (Int, Int)) -> MatrixMap = {
  def (n, _) = d;
  def work(i: Int, a: MMap) -> MMap = {
    if i > 0 then work (i - 1) (Map.add i (Map.empty) a) else a
  };

  if (0, 0) > d then error "Dimensions need to be greater or equal to zero"
  else (work n (Map.empty), d)
}
def mmIntZero(d: (Int, Int)) -> MatrixMapInt = { mmZero d }
def mmRealZero(d: (Int, Int)) -> MatrixMapReal = { mmZero d }

def mmId(id: Dyn, n: Int) -> MatrixMap = {
  def work(i: Int, a: MMap) -> MMap = {
    if i > 0 then work (i - 1) (_add (i, i) id a) else a
  };
  (work n (fst (mmZero (n, n))), (n, n))
}
def mmIntId(n: Int) -> MatrixMapInt = { mmId 1 n }
def mmRealId(n: Int) -> MatrixMapReal = { mmId 1. n }

def dim(M: Matrix) -> (Int, Int) = { snd M }
def rdim(M: Matrix) -> Int = { fst (dim M) }
def cdim(M: Matrix) -> Int = { snd (dim M) }

def mmAdd(z: Dyn, isz: (Dyn -> Bool), ij: Pos, v: Dyn, M: MatrixMap)
  -> MatrixMap = {

  def (Mm, d) = M;
  if (ij <= (0, 0) || ij > d) then error DIMENSION_MISSMATCH
  else {
    if isz v then {
      if _mem d Mm then (_remove ij Mm, d) else M
    } else (_add ij v Mm, d)
  }
}
def mmIntAdd(ij: Pos, v: Int, M: MatrixMapInt) -> MatrixMapInt = {
  mmAdd 0 iszInt ij v M
}
def add: Pos -> Int -> MatrixMapInt -> MatrixMapInt = mmIntAdd
def mmRealAdd(ij: Pos, v: Real, M: MatrixMapReal) -> MatrixMapReal = {
  mmAdd 0. iszReal ij v M
}
def add: Pos -> Real -> MatrixMapReal -> MatrixMapReal = mmRealAdd

def mmFind(z: Dyn, ij: Pos, M: MatrixMap) -> Dyn = {
  def (Mm, d) = M;
  def (i, j) = ij;
  if (ij <= (0, 0) || ij > d) then error DIMENSION_MISSMATCH
  else {
    if (_mem ij Mm) then (_find ij Mm)
    else z
  }
}
def mmIntFind(ij: Pos, M: MatrixMapInt) -> Int = { mmFind 0 ij M }
def find: Pos -> MatrixMapInt -> Int = mmIntFind
def mmRealFind(ij: Pos, M: MatrixMapReal) -> Real = { mmFind 0. ij M }
def find: Pos -> MatrixMapReal -> Real = mmRealFind

def matrixToList(mfind: MatrixFind, M: Matrix) -> [[Dyn]] = {
  def workRow(i: Int, j: Int, a: [Dyn]) -> [Dyn] = {
    if j > 0 then workRow i (j - 1) ((mfind (i, j) M)::a) else a
  };

  def work(i: Int, a: [[Dyn]]) -> [[Dyn]] = {
    if i > 0 then work (i - 1) ((workRow i (cdim M) [])::a) else a
  };

  work (rdim M) []
}

def listToMatrix(madd: MatrixAdd, l: [[Dyn]], M: Matrix) -> Matrix = {
  def workRow(l: [Dyn], i: Int, j: Int, a: Matrix) -> Matrix = {
    match l with
    | x::xs -> workRow xs i (j + 1) (madd (i, j) x a)
    | [] -> a
  };

  def work(l: [[Dyn]], i: Int, a: Matrix) -> Matrix = {
    match l with
    | xs::xss -> work xss (i + 1) (workRow xs i 1 a)
    | [] -> a
  };

  work l 1 M
}
def listToMatrix(l: [[Int]], M: MatrixMapInt) -> MatrixMapInt = {
  listToMatrix mmIntAdd l M
}
def listToMatrix(l: [[Real]], M: MatrixMapReal) -> MatrixMapReal = {
  listToMatrix mmRealAdd l M
}

def dp(mfind: MatrixFind, M: Matrix) -> Matrix = {
  def _ = println("[");
  def _ = iter (fun r: [Dyn] -> {
      def _ = print("  "); def _ = dprint(r); ()
    }) (matrixToList mfind M);
  def _ = print("] d = ");
  def _ = dprint(dim M);
  M
}
def dp(M: MatrixMapReal) -> MatrixMapReal = { dp mmRealFind M }

def forij(f: (Pos -> Bool), M: Matrix) -> Bool = {
  def work(c: Int) -> Bool = {
    def p = (c / (cdim M) + 1, c mod (cdim M) + 1);
    if (c + 1 > ((rdim M) * (cdim M))) then true
    else { if !(f p) then false else work (c + 1) }
  };
  work 0
}

def matrixEq(mfind: MatrixFind, eq: (Dyn -> Dyn -> Bool),
  lM: Matrix, rM: Matrix)-> Bool = {

  if (dim lM) != (dim rM) then error DIMENSION_MISSMATCH
  else forij (fun ij: Pos -> { eq (mfind ij lM) (mfind ij rM) }) lM
}
def matrixEq(lM: MatrixMapInt, rM: MatrixMapInt) -> Bool = {
  matrixEq mmIntFind eqInt lM rM
}
def (==): MatrixMapInt -> MatrixMapInt -> Bool = matrixEq
def matrixEq(lM: MatrixMapReal, rM: MatrixMapReal) -> Bool = {
  matrixEq mmRealFind eqReal lM rM
}
def (==): MatrixMapReal -> MatrixMapReal -> Bool = matrixEq

def matrixNEq(mfind: MatrixFind, eq: (Dyn -> Dyn -> Bool),
  lM: Matrix, rM: Matrix) -> Bool = { !(matrixEq mfind eq lM rM) }
def matrixNEq(lM: MatrixMapInt, rM: MatrixMapInt) -> Bool = {
  matrixNEq mmIntFind eqInt lM rM
}
def (!=): MatrixMapInt -> MatrixMapInt -> Bool = matrixNEq
def matrixNEq(lM: MatrixMapReal, rM: MatrixMapReal) -> Bool = {
  matrixNEq mmRealFind eqReal lM rM
}
def (!=): MatrixMapReal -> MatrixMapReal -> Bool = matrixNEq

def mapij(madd: MatrixAdd, mzero: MatrixZero, f: (Pos -> Dyn), M: Matrix)
  -> Matrix = {

  def work(ij: Pos, a: Matrix) -> Matrix = {
    if dim M < ij then a
    else work (_nextpos ij (dim M)) (madd ij (f ij) a)
  };
  work (1, 1) (mzero (dim M))
}
def mapij(f: (Pos -> Int), M: Matrix) -> MatrixMapInt = {
  mapij mmIntAdd mmIntZero f M
}
def mapij(f: (Pos -> Real), M: Matrix) -> MatrixMapReal = {
  mapij mmRealAdd mmRealZero f M
}

def foldij(f: (Dyn -> Pos -> Dyn), a: Dyn, M: Matrix) -> Dyn = {
  def work(ij: Pos, a: Dyn) -> Dyn = {
    if ij > dim M then a else work (_nextpos ij (dim M)) (f a ij)
  };
  work (1, 1) a
}

def matrixAddition(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero,
  add: (Dyn -> Dyn -> Dyn), lM: Matrix, rM: Matrix) -> Matrix = {

if (dim lM) != (dim rM) then error DIMENSION_MISSMATCH
  else mapij madd mzero (fun ij: Pos -> { add (mfind ij lM) (mfind ij rM) }) rM
}
def matrixAddition(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = {
  matrixAddition mmIntFind mmIntAdd mmIntZero addInt lM rM
}
def (+): MatrixMapInt -> MatrixMapInt -> MatrixMapInt = matrixAddition
def matrixAddition(lM: MatrixMapReal, rM: MatrixMapReal) -> MatrixMapReal = {
  matrixAddition mmRealFind mmRealAdd mmRealZero addReal lM rM
}
def (+): MatrixMapReal -> MatrixMapReal -> MatrixMapReal = matrixAddition

def matrixChsgn(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero,
  cs: (Dyn -> Dyn), M: Matrix) -> Matrix = {

  mapij madd mzero (fun ij: Pos -> cs (mfind ij M)) M
}
def matrixChsgn(M: MatrixMapInt) -> MatrixMapInt = {
  matrixChsgn mmIntFind mmIntAdd mmIntZero chsgnInt M
}
def (--): MatrixMapInt -> MatrixMapInt = matrixChsgn
def matrixChsgn(M: MatrixMapReal) -> MatrixMapReal = {
  matrixChsgn mmRealFind mmRealAdd mmRealZero chsgnReal M
}
def (--): MatrixMapReal -> MatrixMapReal = matrixChsgn

def matrixSubst(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero,
  add: (Dyn -> Dyn -> Dyn), cs: (Dyn -> Dyn), lM: Matrix, rM: Matrix)
  -> Matrix = {

  matrixAddition mfind madd mzero add lM (matrixChsgn mfind madd mzero cs rM)
}
def matrixSubst(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = {
  matrixSubst mmIntFind mmIntAdd mmIntZero addInt chsgnInt lM rM
}
def (-): MatrixMapInt -> MatrixMapInt -> MatrixMapInt = matrixSubst
def matrixSubst(lM: MatrixMapReal, rM: MatrixMapReal) -> MatrixMapReal = {
  matrixSubst mmRealFind mmRealAdd mmRealZero addReal chsgnReal lM rM
}
def (-): MatrixMapReal -> MatrixMapReal -> MatrixMapReal = matrixSubst

def matrixScalarProd(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero,
  prod: (Dyn -> Dyn -> Dyn), s: Dyn, M: Matrix) -> Matrix = {

  mapij madd mzero (fun ij: Pos -> { prod s (mfind ij M) }) M
}
def matrixScalarProd(s: Int, M: MatrixMapInt) -> MatrixMapInt = {
  matrixScalarProd mmIntFind mmIntAdd mmIntZero prodInt s M
}
def (*): Int -> MatrixMapInt -> MatrixMapInt = matrixScalarProd
def matrixScalarProd(M: MatrixMapInt, s: Int) -> MatrixMapInt = {
  matrixScalarProd mmIntFind mmIntAdd mmIntZero prodInt s M
}
def (*): MatrixMapInt -> Int -> MatrixMapInt = matrixScalarProd
def matrixScalarProd(s: Real, M: MatrixMapReal) -> MatrixMapReal = {
  matrixScalarProd mmRealFind mmRealAdd mmRealZero prodReal s M
}
def (*): Real -> MatrixMapReal -> MatrixMapReal = matrixScalarProd
def matrixScalarProd(M: MatrixMapReal, s: Real) -> MatrixMapReal = {
  matrixScalarProd mmRealFind mmRealAdd mmRealZero prodReal s M
}
def (*): MatrixMapReal -> Real -> MatrixMapReal = matrixScalarProd

def matrixProd(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero,
  add: (Dyn -> Dyn -> Dyn), prod: (Dyn -> Dyn -> Dyn), lM : Matrix, rM: Matrix)
  -> Matrix = {

  def f(ij: Pos) -> Dyn = {
    def work(i: Int, a: Dyn) -> Dyn = {
      if i > 0 then {
        def lpos = (fst ij, i);
        def rpos = (i, snd ij);
        work (i - 1) (add a (prod (mfind lpos lM) (mfind rpos rM)))
      } else a
    };

    def lpos = (fst ij, cdim lM);
    def rpos = (rdim rM, snd ij);
    work ((cdim lM) - 1) (prod (mfind lpos lM) (mfind rpos rM))
  };
  if (cdim lM) != (rdim rM) then error DIMENSION_MISSMATCH
  else mapij madd mzero f (mzero (rdim lM, cdim rM))
}
def matrixProd(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = {
  matrixProd mmIntFind mmIntAdd mmIntZero addInt prodInt lM rM
}
def (*): MatrixMapInt -> MatrixMapInt -> MatrixMapInt = matrixProd
def matrixProd(lM: MatrixMapReal, rM: MatrixMapReal) -> MatrixMapReal = {
  matrixProd mmRealFind mmRealAdd mmRealZero addReal prodReal lM rM
}
def (*): MatrixMapReal -> MatrixMapReal -> MatrixMapReal = matrixProd

def matrixTranspose(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero,
  M: Matrix) -> Matrix = {

  mapij madd mzero (fun ij: Pos -> { mfind (snd ij, fst ij) M })
    (mzero (cdim M, rdim M))
}
def tr(M: MatrixMapInt) -> MatrixMapInt = {
  matrixTranspose mmIntFind mmIntAdd mmIntZero M
}
def tr(M: MatrixMapReal) -> MatrixMapReal = {
  matrixTranspose mmRealFind mmRealAdd mmRealZero M
}

def matrixSub(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero, s: Pos,
  e: Pos, M: Matrix) -> Matrix = {

  if s > e  || s <= (0, 0) || e > (dim M) then error DIMENSION_MISSMATCH
  else mapij madd mzero (fun ij: Pos -> { mfind (ij + s - (1, 1)) M})
    (mzero (e - s + (1, 1)))
}
def sub(s: Pos, e: Pos, M: MatrixMapInt) -> MatrixMapInt = {
  matrixSub mmIntFind mmIntAdd mmIntZero s e M
}
def sub(s: Pos, e: Pos, M: MatrixMapReal) -> MatrixMapReal = {
  matrixSub mmRealFind mmRealAdd mmRealZero s e M
}

def matrixConcat(mfind: MatrixFind, madd: MatrixAdd, mzero: MatrixZero,
  lM: Matrix, rM: Matrix) -> Matrix = {

  def f(ij: Pos) -> Dyn = {
    if snd ij <= (cdim lM) then mfind ij lM else mfind
      (fst ij, snd ij - cdim lM) rM
  };
  if (rdim lM) != (rdim rM) then error DIMENSION_MISSMATCH
  else mapij madd mzero f (mzero (rdim lM, (cdim lM) + (cdim rM)))
}
def vconcat(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = {
  matrixConcat mmIntFind mmIntAdd mmIntZero lM rM
}
def hconcat(lM: MatrixMapInt, rM: MatrixMapInt) -> MatrixMapInt = {
  tr (vconcat (tr lM) (tr rM))
}
def vconcat(lM: MatrixMapReal, rM: MatrixMapReal) -> MatrixMapReal = {
  matrixConcat mmRealFind mmRealAdd mmRealZero lM rM
}
def hconcat(lM: MatrixMapReal, rM: MatrixMapReal) -> MatrixMapReal = {
  tr (vconcat (tr lM) (tr rM))
}

def rowopj(madd: MatrixAdd, f: (Int -> Dyn), i: Int, M: Matrix) -> Matrix = {
  if i <= 0 || i > rdim M then error DIMENSION_MISSMATCH
  else {
    def work(j: Int, a: Matrix) -> Matrix = {
      if j > cdim M then a else work (j + 1) (madd (i, j) (f j) a)
    };
    work 1 M
  }
}
def rowopj(f: (Int -> Int), i: Int, M: MatrixMapInt) -> MatrixMapInt = {
  rowopj mmIntAdd f i M
}
def rowopj(f: (Int -> Real), i: Int, M: MatrixMapReal) -> MatrixMapReal = {
  rowopj mmRealAdd f i M
}

def swrows(i1: Int, i2: Int, M: MatrixMap) -> MatrixMap = {
  if i1 <= 0 || i2 <= 0 || i1 > rdim M || i2 > rdim M then
    error DIMENSION_MISSMATCH
  else {
    def (Mm, d) = M;
    if (Map.mem i1 Mm) && (Map.mem i2 Mm) then {
      (Map.add i1 (Map.find i2 Mm) (Map.add i2 (Map.find i1 Mm) Mm), d)
    } else error BAD_MATRIX
  }
}

def swcols(j1: Int, j2: Int, M: MatrixMap) -> MatrixMap = {
  def (Mm, d) = M;
  def work(i: Int, a: MMap) -> MMap = {
    if i > rdim M then a
    else if _mem (i, j1) Mm && _mem (i, j2) Mm then {
      work (i + 1) (_add (i, j1) (_find (i, j2) Mm)
        (_add (i, j2) (_find (i, j1) Mm) a))
    } else if _mem (i, j1) Mm then {
      work (i + 1) (_remove (i, j1) (_add (i, j2) (_find (i, j1) Mm) a))
    } else if _mem (i, j2) Mm then {
      work (i + 1) (_add (i, j1) (_find (i, j2) Mm) (_remove (i, j2) a))
    } else work (i + 1) a
  };

  if j1 <= 0 || j2 <= 0 || j1 > cdim M || j2 > cdim M then
    error DIMENSION_MISSMATCH
  else (work 1 Mm, snd M)
}

def argmax(mfind: (Pos -> Dyn), gt: (Dyn -> Dyn -> Bool), M: Matrix) -> Pos = {
  if dim M < (1, 1) then error DIMENSION_MISSMATCH
  else {
    def f(a: (Pos, Dyn), ij: Pos) -> (Pos, Dyn) = {
      def v = mfind ij M;
      if gt v (snd a) then (ij, v) else a
    };
    fst (foldij f ((1, 1), mfind (1, 1) M) M)
  }
}
def argmax(M: MatrixMapInt) -> Pos = { argmax mmIntFind gtInt M }
def argmax(M: MatrixMapReal) -> Pos = { argmax mmRealFind gtReal M }

def rowreduce(M: MatrixMapReal) -> MatrixMapReal = {
  def sub(hk: Pos, i: Int, M: MatrixMapReal) -> MatrixMapReal = {
    def (h, k) = hk;
    def lv = find (i, k) M;
    def work(j: Int, a: MatrixMapReal) -> MatrixMapReal = {
      if j > cdim M then a
      else {
        if j == h then work (j + 1) (add (i, j) 0. a)
        else work (j + 1)
          (add (i, j) ((find (i, j) M) - lv * (find (h, j) M)) a)
      }
    };
    work k M
  };

  def rowops(hk: Pos, M: MatrixMapReal) -> MatrixMapReal = {
    def (h, k) = hk;
    def work(i: Int, a: MatrixMapReal) -> MatrixMapReal = {
      if i > rdim M then a
      else {
        if i == h then work (i + 1) a
        else work (i + 1) (sub hk i a)
      }
    };
    work 1 M
  };

  def scale(hk: Pos, M: MatrixMapReal) -> MatrixMapReal = {
    def (h, k) = hk;
    def pv = find hk M;
    def work(j: Int, a: MatrixMapReal) -> MatrixMapReal = {
      if j > cdim M then a
      else {
        work (j + 1) (add (h, j) ((find (h, j) a) / pv) a)
      }
    };
    work (k + 1) (add (h, k) 1. M)
  };

  def find_i_max(hk: Pos, M: MatrixMapReal) -> Int = {
    def gt(l: Real, r: Real) -> Bool = { abs l > abs r };
    fst (argmax mmRealFind gt (sub hk (rdim M, snd hk) M)) + fst hk - 1
  };

  def work(hk: Pos, a: MatrixMapReal) -> MatrixMapReal = {
    if (hk > dim M) then a
    else {
      def (h, k) = hk;
      def i_max = find_i_max hk a;
      if abs (find (i_max, k) a) < EPSILON then work (h, k + 1) a
      else {
        work (h + 1, k + 1) (rowops hk (scale hk (swrows h i_max a)))
      }
    }
  };
  work (1, 1) M
}
