/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include EBMLANGHelpers
include EBMLANG

def reinit: <Real> -> Real -> Equations
def switch: Equations -> (() -> ?) -> [<Real>] -> Equations

def E_d(d: <Real>, mu: VMap) -> Real = {
  evalRealFromVMap d mu
}

def inside(L: Set(<Real>), mu: VMap) -> Bool = {
  def llog = logger "inside" DEBUG;
  def b = forAll (fun d: <Real> -> {
    def v = (E_d d mu);
    def _ = llog "expression" d;
    def _ = llog "value" v;
    v > 0.
  }) (Set.toList L);
  def _ = llog "inside?" b;
  b
}

def M_l(l: [<Real>]) -> Set(<Real>) = {
  listToSet l
}

def S_m(m: Equations, mu: VMap) -> Equations = {
  match m with
  | m_1; m_2 -> (S_m m_1 mu); (S_m m_2 mu)
  | d_1 = d_2 -> m
  | init _ _ -> m
  | reinit _ _ -> m
  | Branch _ _ _ _ -> m
  | RefBranch _ _ _ -> m
  | switch m_1 (lift m_2: (() -> ?)) (lift l: [<Real>]) -> {
      if inside (M_l l) mu then switch (S_m m_1 mu) m_2 l
      else m_2()
    }
  | nilp _ -> m
  | _ -> error "Unmatched pattern in S_m"
}

def R_m(m: Equations, mu: VMap) -> (Equations, [<Real>]) = {
  def llog = logger "R_m" DEBUG;
  match m with
  | m_1; m_2 -> {
      def (s_1, l_1) = (R_m m_1 mu);
      def (s_2, l_2) = (R_m m_2 mu);
      (s_1;s_2, concat l_1 l_2)
    }
  | init v d -> {
        if (Map.mem v mu) then (nilp (), [])
        else {
          def r = E_d d mu;
          (init v r, [])
        }
      }
  | reinit v d -> {
        if (Map.mem v mu) then {
          def r = E_d d mu;
          (init v r, [])
        } else (nilp (), [])
      }
  | switch m_1 _ (lift l: [<Real>]) -> {
      def (s, lp) = R_m m_1 mu;
      (s, concat l lp)
    }
  | d_1 = d_2 -> (m, [])
  | Branch _ _ _ _ -> (m, [])
  | RefBranch _ _ _ -> (m, [])
  | nilp _ -> (m, [])
  | _ -> {
      def _ = llog "unmatched patter" m;
      error "Unmatched pattern in R_m"
    }
}

def M_m_debug(t0: Real, m: Equations, mu: VMap, tau: T) -> M = {
  def llog = logger "M_m_debug" DEBUG;
  def _ = llog "the time is:" tau;
  def _ = llog "the model is:" m;
  def (t, n) = tau;
  def mp = { if t == t0 then m else S_m m mu };
  def _ = llog "after elaboration of switches we have:" mp;
  def (s, l) = R_m mp mu;
  def _ = llog "which is reduced to:" s;
  def _ = llog "and the boundaries are" l;
  def L = M_l l;
  def f = M_f s t;
  def (E, mup, tp) = f;
  (mp, f, L, (tp, n + 1))
}

def M_m(t0: Real, m: Equations, mu: VMap, tau: T) -> M = {
  def llog = logger "M_m" DEBUG;
  def mp = M_m_debug t0 m mu tau;
  def (mpp, f, L, taupp) = mp;
  def (_, mup, tp) = f;
  if inside L mup then mp
  else
  {
    def _ = llog "outside of:" L;
    M_m t0 mpp mup taupp
  }
}
