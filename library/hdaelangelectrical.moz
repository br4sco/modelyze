/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Physical
include HDAELANG

def CurrentSensor(i: Current, p: Electrical, n: Electrical) = {
  def u_S: Voltage;
  Branch i u_S p n;
  u_S = 0.
}

def VoltageSensor(u: Voltage, p: Electrical, n: Electrical) = {
  def i_S: Current;
  Branch i_S u n p;
  i_S = 0.
}

def Resistor(R: Real, p: Electrical, n: Electrical) = {
  def i_R: Current;
  def u_R: Voltage;
  Branch i_R u_R p n;
  u_R = R * i_R
}

def ConstantVoltageSource(V: Real, p: Electrical, n: Electrical) = {
  def i_V: Current;
  def u_V: Voltage;
  Branch i_V u_V p n;
  init u_V V;
  reinit u_V u_V;
  u_V = V
}

def Capacitor(C: Real, u0: Real, p: Electrical, n: Electrical) = {
  def i_C: Current;
  def u_C: Voltage;
  Branch i_C u_C p n;
  init u_C u0;
  reinit u_C u_C;
  C * (der u_C) = i_C
}

def Inductor(L: Real, i0: Real, p: Electrical, n: Electrical) = {
  def i_L: Current;
  def u_L: Voltage;
  Branch i_L u_L p n;
  init i_L i0;
  reinit i_L i_L;
  L * (der i_L) = u_L
}

def Diode2(forward: Bool, bias: Real, p: Electrical, n: Electrical) = {
  def i_D2: Current;
  def u_D2: Voltage;
  def d(forward: Bool) -> ? = {
    if forward then
        switch (u_D2 = bias) (fun t: () -> d(false)) (i_D2 - 0.0001)
    else
        switch (i_D2 = 0.) (fun t: () -> d(true)) (u_D2 - 0.0001)
  };
  reinit u_D2 u_D2;
  reinit i_D2 i_D2;
  Branch i_D2 u_D2 p n;
  d(forward)
}

def Clock(t: <Real>) = {
  init t 0.;
  reinit t t;
  der t = 1.
}

def TimedSwitch(closed: Bool, tb: Real, p: Electrical, n: Electrical) = {
  def i_TS: Current;
  def u_TS: Voltage;
  def t: Real;
  def s(closed: Bool) -> Equations = {
    if closed then switch (u_TS = 0.) (fun t: () -> i_TS = 0.) (t - tb)
    else switch (i_TS = 0.) (fun t: () -> u_TS = 0.) (t - tb)
  };
  Branch i_TS u_TS p n;
  Clock(t);
  s(closed)
}
