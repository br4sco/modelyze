/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se

*/

include MATRIX
include Equation

// def der: Real -> Real
// def (') = der

def mmSRealDer(M: MatrixMapSReal) -> MatrixMapSReal = {
  mapij (fun ij: Pos -> (find ij M)') M
}
// def (') = mmSRealDer

type Vector3
type Vector3UkMap = (Vector3 => Vector3)

def ii: Vector3
def jj: Vector3
def kk: Vector3
def vec3: Real -> Real -> Real -> Vector3
def (+): Vector3 -> Vector3 -> Vector3
def (-): Vector3 -> Vector3 -> Vector3
def (---): Vector3 -> Vector3
def (*): Real -> Vector3 -> Vector3
def dot: Vector3 -> Vector3 -> Real
def cross: Vector3 -> Vector3 -> Vector3
def ('): Vector3 -> Vector3

def mkVector3(x: <Real>, y: <Real>, z: <Real>) -> MatrixMapSReal = {
  listToMatrix [[x], [y], [z]] (mmSRealZero (3, 1))
}

def mkUkMap(e: <>) -> Vector3UkMap = {
  def work(e: <>, a: Vector3UkMap) -> Vector3UkMap = {
    match e with
    | e_1 e_2 -> work e_2 (work e_1 a)
    | sym: Vector3 -> {
          if Map.mem e a then a
          else {
            def x, y, z: Real;
            def v = vec3 x y z;
            Map.add e v a
          }
        }
    | _ -> a
  };
  work e (Map.empty)
}

def vector32Matrix(v: Vector3, ukm: Vector3UkMap) -> MatrixMapSReal = {
  def work(v: Vector3) -> MatrixMapSReal = {
    match v with
    | ii -> mkVector3 1. 0. 0.
    | jj -> mkVector3 0. 1. 0.
    | kk -> mkVector3 0. 0. 1.
    | sym: Vector3 -> {
        if Map.mem v ukm then work (Map.find v ukm)
        else error "Unkown of Vector3 type not in Vector3 uknown map"
      }
    | vec3 x y z -> mkVector3 x y z
    | l + r -> (work l) + (work r)
    | l - r -> (work l) - (work r)
    | r * v -> r *. (work v)
    | v' -> mmSRealDer (work v)
    | -v -> -(work v)
    | cross l r -> (ss (work l)) * (work r)
    | _ -> error "Unmatched"
  };
  work v
}

def applyDots(e: <Real>, ukm: Vector3UkMap) -> <Real> = {
  def work(e: <>) -> <> = {
    match e with
    | dot l r -> hd (concat (matrixToList ((tr (vector32Matrix l ukm)) * (vector32Matrix r ukm))))
    | e_1 e_2 -> (work e_1) (work e_2)
    | _ -> e
  };

  work e
}

type Equations
def (;): Equations -> Equations -> Equations
def (=): Real -> Real -> Equations
def (==): Vector3 -> Vector3 -> Equations
def NoEqn: Equations

def toR(r: Dyn) -> <Real> = { r }

def equations2residual(e: Equations) -> [<Real>] = {
  def work(e: Equations, a: [<Real>]) -> [<Real>] = {
    match e with
    | e_1; e_2 -> work e_1 (work e_2 a)
    | r_1 = r_2 -> ((toR r_1) - (toR r_2))::a
    | _ -> error "Expected only scalar equations"
  };

  work e []
}

def matrices2Equations(l: MatrixMapSReal, r: MatrixMapSReal, a: Equations) -> Equations = {
  def f(a: Equations, ij: Pos) -> Equations = { a; find ij l = find ij r };
  if dim l == dim r then foldij f a l else error DIMENSION_MISSMATCH
}

def elaborateDots(e: Equations, ukm: Vector3UkMap) -> Equations  = {
  match e with
  | e_1; e_2 -> (elaborateDots e_1 ukm); (elaborateDots e_2 ukm)
  | r_1 = r_2 -> applyDots r_1 ukm = applyDots r_2 ukm
  | NoEqn -> NoEqn
  | _ -> error "Expected only scalar equations"
}

def toScalarEquations(e: Equations) -> Equations = {
  def ukm = mkUkMap e;

  def work(e: Equations, a: Equations) -> Equations  = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | v_1 == v_2 -> matrices2Equations (vector32Matrix v_1 ukm) (vector32Matrix v_2 ukm) a
    | r_1 = r_2 -> a; (applyDots r_1 ukm) = (applyDots r_2 ukm)
    | _ -> error "Unexpected construct"
  };
  elaborateDots (work e NoEqn) ukm
}
