/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se

*/

include MATRIX
include Base

def der: Real -> Real
def (') = der

def mmSRealDer(M: MatrixMapSReal) -> MatrixMapSReal = {
  mapij (fun ij: Pos -> (find ij M)') M
}
// def (') = mmSRealDer

type RealVector3 = (Real, Real, Real)

def norm2(v: RealVector3) = {
  def (x, y, z) = v;
  x^2. + y^2. + z^2.
}

def chsgn(v: RealVector3) -> RealVector3 = {
  def (x, y, z) = v;
  (-x, -y, -z)
}
def (---) = chsgn

def multiply(s: Real, v: RealVector3) -> RealVector3 = {
  def (x, y, z) = v;
  (s * x, s * y, s * z)
}
def (*) = multiply

type Vector3
type Vector3UkMap = (Vector3 => Vector3)

def vec3: Real -> Real -> Real -> Vector3
def (+): Vector3 -> Vector3 -> Vector3
def (-): Vector3 -> Vector3 -> Vector3
def (---): Vector3 -> Vector3
def (*): Real -> Vector3 -> Vector3
def (*.): Vector3 -> Vector3 -> Vector3
def dot: Vector3 -> Vector3 -> Real
def norm2: Vector3 -> Real
def cross: Vector3 -> Vector3 -> Vector3
def ('): Vector3 -> Vector3

def ii = vec3 1. 0. 0.
def jj = vec3 0. 1. 0.
def kk = vec3 0. 0. 1.
def zero3 = vec3 0. 0. 0.

def _mkVector3(x: <Real>, y: <Real>, z: <Real>) -> MatrixMapSReal = {
  listToMatrix [[x], [y], [z]] (mmSRealZero (3, 1))
}

def mkVec3(v: RealVector3) -> Vector3 = { def (x, y, z) = v; vec3 x y z }

def isRealUk(e: <Real>) -> Bool = {
  match e with
  | sym: Real -> true
  | _ -> false
}

def evalReal(r: <Real>) -> Real = {
  def work(e: <?>) -> ? = {
    match e with
    | f e -> (work f) (work e)
    | sval v: ? -> v
    | _ -> e
    // | _ -> error ("Unable to evaluate: " ++ symstr(e))
  };
  work r
}

def mkVector3UkMap(e: <>) -> Vector3UkMap = {
  def work(e: <>, a: Vector3UkMap) -> Vector3UkMap = {
    match e with
    | e_1 e_2 -> work e_2 (work e_1 a)
    | sym: Vector3 -> {
          if Map.mem e a then a
          else {
            def x, y, z: Real;
            Map.add e (vec3 x y z) a
          }
        }
    | _ -> a
  };
  work e (Map.empty)
}

def vector32Matrix(v: Vector3) -> MatrixMapSReal = {
  def work(v: Vector3) -> MatrixMapSReal = {
    match v with
    | sym: Vector3 -> error "Unkown of Vector3 type not in Vector3 uknown map"
    | vec3 x y z -> _mkVector3 x y z
    | l + r -> (work l) + (work r)
    | l - r -> (work l) - (work r)
    | r * v -> r *. (work v)
    | l *. r -> {
        def l = work l;
        def r = work r;
        mapij (fun ij: Pos -> find ij l * find ij r) l
      }
    | v' -> mmSRealDer (work v)
    | -v -> -(work v)
    | cross l r -> (ss (work l)) * (work r)
    | _ -> error "Unmatched"
  };
  work v
}

def applyVec2RealOptrs(e: <>) -> <> = {
  def work(e: <>) -> <> = {
    match e with
    | dot l r -> work (hd (concat (matrixToList ((tr (vector32Matrix l)) * (vector32Matrix r)))))
    | norm2 (vec3 x y z) -> (work x)^2. + (work y)^2. + (work z)^2.
    | e_1 e_2 -> (work e_1) (work e_2)
    | _ -> e
  };

  work e
}

def evalVector3(v: Vector3) -> Vector3 = {
  def v = vector32Matrix (applyVec2RealOptrs v);
  def x = (find (1, 1) v);
  def y = (find (2, 1) v);
  def z = (find (3, 1) v);
  vec3 x y z
}

type Equations
def (;): Equations -> Equations -> Equations
def (=): Real -> Real -> Equations
def (<-): Real -> Real -> Equations
def (<~): Real -> Real -> Equations
def (~=): Real -> Real -> Equations

def (==): Vector3 -> Vector3 -> Equations
def (~==): Vector3 -> Vector3 -> Equations
def (<~~): Vector3 -> Vector3 -> Equations
def NoEqn: Equations

def matrices2Equations(l: MatrixMapSReal, r: MatrixMapSReal, a: Equations) -> Equations = {
  def f(a: Equations, ij: Pos) -> Equations = {
      def le = find ij l;
      def re = find ij r;
      match (le, re) with
      | (sval lr: Real, sval rr: Real) -> { if lr == rr then a
                                            else error (real2string lr ++ " != " ++ real2string rr) }
      | _ -> a; le = re
    };
  if dim l == dim r then foldij f a l else error DIMENSION_MISSMATCH
}

def matrices2InitEquations(l: MatrixMapSReal, r: MatrixMapSReal, a: Equations) -> Equations = {
  def f(a: Equations, ij: Pos) -> Equations = {
      def le = find ij l;
      def re = find ij r;
      match (le, re) with
      | (sval lr: Real, sval rr: Real) -> { if lr == rr then a
                                            else error (real2string lr ++ " != " ++ real2string rr) }
      | _ -> a; le ~= re
    };
  if dim l == dim r then foldij f a l else error DIMENSION_MISSMATCH
}


def matrices2Inits(l: MatrixMapSReal, r: MatrixMapSReal, a: Equations) -> Equations = {
  def f(a: Equations, ij: Pos) -> Equations = {
      def le = find ij l;
      def re = evalReal (find ij r);
      if isRealUk le then { a; le <~ re } else error ("Expected lhs " ++ symstr(le)  ++  " to be an uknown")
    };
  if dim l == dim r then foldij f a l else error DIMENSION_MISSMATCH
}

def toScalarEquations(e: Equations) -> Equations = {
  def ukm = mkVector3UkMap e;
  def e = subs e ukm;
  def e = applyVec2RealOptrs e;

  def work(e: Equations, a: Equations) -> Equations  = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | v_1 == v_2 -> matrices2Equations (vector32Matrix v_1) (vector32Matrix v_2) a
    | r_1 = r_2 -> a; r_1 = r_2
    | v_1 <~~ v_2 -> matrices2Inits (vector32Matrix v_1) (vector32Matrix v_2) a
    | r_1 <- r_2 -> {
        if isRealUk r_1 then a; r_1 <- evalReal r_2
        else error ("Expected lhs " ++ symstr(r_1)  ++  " to be an uknown")
      }
    | r_1 <~ r_2 -> {
        if isRealUk r_1 then a; r_1 <~ evalReal r_2
        else error ("Expected lhs " ++ symstr(r_1)  ++  " to be an uknown")
      }
    | v_1 ~== v_2 -> matrices2InitEquations (vector32Matrix v_1) (vector32Matrix v_2) a
    | r_1 ~= r_2 -> a; r_1 ~= r_2
    | NoEqn -> a
    | _ -> { def _ = dprintln e; error "Unexpected construct"}
  };

  work e NoEqn
}
