/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Graph

def zero1 = mmSRealZero (1, 1)
def zero3 = mmSRealZero (3, 1)
def idq = (1., 0., 0., 0.)
def id3 = mmSRealId 3
def xhat = (1., 0., 0.)
def yhat = (0., 1., 0.)
def zhat = (0., 0., 1.)

def EXPECTED_VECTOR3 = "Expected vector3"
def EXPECTED_QUATERNION = "Expected quaternion"

def der: Real -> Real
def (') = der

type Equations
def (;): Equations -> Equations -> Equations
def (=): Real -> Real -> Equations
def (<-): Real -> Real -> Equations
def (<~): Real -> Real -> Equations
def (~=): Real -> Real -> Equations
def probe: Real -> Equations
def NoEqn: Equations

type Frame = Node

def sw(a: {Dyn}, i: Int, j: Int) -> () = {
  def n = (Array.length a);
  if i < n && 0 <= i && j < n && 0 <= j then {
    def t = (Array.get a i);
    def _ = (Array.set a i (Array.get a j));
    Array.set a j t
  } else error DIMENSION_MISSMATCH
}

def mapToIdx(l: [Dyn]) -> [Int] = {
  def f(i: Int, e: Dyn) -> Int = { i };
  mapi f l
}

type SRMatrix = MatrixMapSReal
type RealVector3 = (Real, Real, Real)
type RealQuaternion = (Real, Real, Real, Real)

def mkVector3(x: <Real>, y: <Real>, z: <Real>) -> SRMatrix = {
  listToMatrix [[x], [y], [z]] (mmSRealZero (3, 1))
}

def mkVector3(t: ()) -> SRMatrix = {
  def x, y, z: <Real>;
  mkVector3 x y z
}

def mkVector3(v: RealVector3) -> SRMatrix = {
  def (x, y, z) = v;
  mkVector3 x y z
}

def mkQuaternion(w: <Real>, i: <Real>, j: <Real>, k: <Real>) -> SRMatrix = {
  listToMatrix [[w], [i], [j], [k]] (mmSRealZero (4, 1))
}

def mkQuaternion(q: RealQuaternion) -> SRMatrix = {
  def (w, i, j, k) = q;
  mkQuaternion w i j k
}

def mkQuaternion(t: ()) -> SRMatrix = {
  def w, i, j, k: <Real>;
  mkQuaternion w i j k
}

def vec3ToTuple(v: SRMatrix) -> (<Real>, <Real>, <Real>) = {
  if dim v != (3, 1) then error EXPECTED_VECTOR3
  else (find (1, 1) v, find (2, 1) v, find (3, 1) v)
}

def quatToTuple(q: SRMatrix) -> (<Real>, <Real>, <Real>, <Real>) = {
  if dim q != (4, 1) then error EXPECTED_QUATERNION
  else (find (1, 1) q, find (2, 1) q, find (3, 1) q, find (4, 1) q)
}

def q2M(q: SRMatrix) = {
  if dim q != (4, 1) then error EXPECTED_QUATERNION
  else {
    def (q0, q1, q2, q3) = quatToTuple q;
    listToMatrix [
                  [ q0, -q1, -q2, -q3],
                  [ q1,  q0, -q3,  q2],
                  [ q2,  q3,  q0, -q1],
                  [ q3, -q2,  q1,  q0]
                 ] (mmSRealZero (4, 4))
  }
}

def M2q(M: SRMatrix) = {
  if dim M != (4, 4) then error DIMENSION_MISSMATCH
  else {
    def q0 = find (1, 1) M;
    def q1 = find (2, 1) M;
    def q2 = find (3, 1) M;
    def q3 = find (4, 1) M;
    mkQuaternion q0 q1 q2 q3
  }
}

def qprod(p: SRMatrix, q: SRMatrix) = { M2q ((q2M p) * (q2M q)) }

def qconj(q: SRMatrix) = { M2q (tr (q2M q)) }

def norm2(v: SRMatrix) = {
  def f(a: <Real>, ij: Pos) -> <Real> = {
    a + (find ij v)^2.
  };
  def z: <Real> = 0.;

  if cdim v != 1 && rdim v <= 0 then error DIMENSION_MISSMATCH
  else {
    foldij f z v
  }
}

def dot(l: SRMatrix, r: SRMatrix) -> <Real> = {
  if dim l != dim r then error DIMENSION_MISSMATCH
  else hd (hd (matrixToList (l * (tr r))))
}

def ea2quat(th: Real, u: RealVector3) = {
  def (x, y, z) = u;
  def n = sqrt(x^2. + y^2. + z^2.);
  (cos (th / 2.), (x / n) * sin (th / 2.), (y / n) * sin (th / 2.), (z / n) * sin (th / 2.))
}

def vectorFold2(f: (Dyn -> <Real> -> <Real> -> Dyn), a: Dyn, v1: SRMatrix, v2: SRMatrix) -> Dyn = {
  if dim v1 != dim v2 || rdim v1 < 1 || cdim v1 > 1 then error DIMENSION_MISSMATCH
  else {
    def ff(a: Dyn, ij: Pos) -> Dyn = { f a (find ij v1) (find ij v2) };
    foldij ff a v1
  }
}

def vectorFoldHead2(fa: (Dyn -> Dyn -> Dyn), f: (<Real> -> <Real> -> Dyn), v1: SRMatrix, v2: SRMatrix) -> Dyn = {
  if dim v1 != dim v2 || rdim v1 < 1 || cdim v1 > 1 then error DIMENSION_MISSMATCH
  else {
    def h = f (find (1, 1) v1) (find (1, 1) v2);
    if dim v2 == (1, 1) then h
    else {
      def lt = sub (2, 1) (dim v1) v1;
      def rt = sub (2, 1) (dim v2) v2;
      def ff(a: Equations, ij: Pos) -> Equations = { fa a (f (find ij lt) (find ij rt)) };
      foldij ff h lt
    }
  }
}

def vectorEqual(l: SRMatrix, r: SRMatrix) -> Equations = {
  def fa(a: Equations, e: Equations) -> Equations = { a; e };
  def f(l: <Real>, r: <Real>) -> Equations = { l = r };
  vectorFoldHead2 fa f l r
}
def (==) = vectorEqual

def vectorInitEqual(l: SRMatrix, r: SRMatrix) -> Equations = {
  def fa(a: Equations, e: Equations) -> Equations = { a; e };
  def f(l: <Real>, r: <Real>) -> Equations = { l ~= r };
  vectorFoldHead2 fa f l r
}
def (~==) = vectorInitEqual

def vectorInit(l: SRMatrix, r: SRMatrix) -> Equations = {
  def fa(a: Equations, e: Equations) -> Equations = { a; e };
  def f(l: <Real>, r: <Real>) -> Equations = { l <~ r };
  vectorFoldHead2 fa f l r
}
def (<~~) = vectorInit

def matrixDer(M: SRMatrix) -> SRMatrix = {
  def f(e: <Real>) -> <Real> = { e' };
  map f M
}
def (') = matrixDer

def translationEdge: Frame -> Frame -> SRMatrix -> SRMatrix -> Equations
def angularVelocityEdge: Frame -> Frame -> SRMatrix -> SRMatrix -> Equations
def initialRotationEdge: Frame -> Frame -> SRMatrix -> Equations

type VectorPairEdge = (Edge, (SRMatrix, SRMatrix))
type VectorEdge = (Edge, SRMatrix)

def mkGraph(mes: [VectorPairEdge]) -> [Edge] = {
  map (fun me: VectorPairEdge -> fst me) mes
}

def mkVarsList(mes: [VectorPairEdge]) -> [(SRMatrix, SRMatrix)] = {
  map (fun me: VectorPairEdge -> snd me) mes
}

def getTranslationEdges(e: Equations) -> ([VectorPairEdge], Equations) = {
  def work(e: Equations, a: ([VectorPairEdge], Equations)) -> ([VectorPairEdge], Equations) = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | translationEdge n_1 n_2 (sval x: SRMatrix) (sval y: SRMatrix) -> (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoEqn)
}

def getAngularVelocityEdges(e: Equations) -> ([VectorPairEdge], Equations) = {
  def work(e: Equations, a: ([VectorPairEdge], Equations)) -> ([VectorPairEdge], Equations) = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | angularVelocityEdge n_1 n_2 (sval x: SRMatrix) (sval y: SRMatrix) -> (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoEqn)
}

def getRotationInitEdges(e: Equations) -> ([VectorEdge], Equations) = {
  def work(e: Equations, a: ([VectorEdge], Equations)) -> ([VectorEdge], Equations) = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | initialRotationEdge n_1 n_2 (sval x: SRMatrix) -> (((n_1, n_2), x)::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoEqn)
}

def mkCutsetMatrix(mes: [Dyn]) -> (MatrixMapInt, (Dyn, Dyn)) = {
  if isEmpty mes then error "Edge list empty" else {
    def G = mkGraph mes;
    if hasSelfLoop G then error "Model graph contains self loop"
    else {
      def IM = mkIncidenceMatrix G;
      def _ = logg 2 "IM" (fun t: () -> def _ = dp IM; ());
      def _ = logg 2 "X" (fun t: () -> def _ = map (fun e: (SRMatrix, SRMatrix) -> dp (fst e)) (mkVarsList mes); ());

      def vs = listToArray (mkVarsList mes);

      def work(i: Int, a: MatrixMapInt) -> MatrixMapInt = {
        if i > rdim a then a
        else {
          def j_max = snd (argfind (fun v: Int -> v != 0)
                        (sub (i, 1) (i, cdim a) a));
          if i == j_max then work (i + 1) a
          else {
            def _ = sw vs (i - 1) (j_max - 1);
            work (i + 1) (swcols i j_max a)
          }
        }
      };

      def IMrr = rowreduce IM;
      def _ = logg 2 "IMrr" (fun t: () -> def _ = dp IMrr; ());

      def IMrrt = trimrows IMrr;
      def _ = logg 2 "IMrrt" (fun t: () -> def _ = dp IMrrt; ());

      if rdim IMrrt > cdim IMrrt then error BAD_MATRIX
      else {
        def IA = work 1 (real2int IMrrt);
        def _ = logg 2 "IA" (fun t: () -> def _ = dp IA; ());

        def (I, A) = vsplit (rdim IA) IA;
        def T = (if dim A < (1, 1) then arrayToList vs
                 else arrayToList (sub vs 0 (rdim A)));
        def C = (if dim A < (1, 1) then []
                 else arrayToList (sub vs (rdim A) (Array.length vs)));
        (A, (T, C))
      }
    }
  }
}

def mkPriScndVarsRel(uop: (Int -> Dyn -> Dyn), bop: (Int -> Dyn -> Dyn -> Dyn), zero: Dyn, C: MatrixMapInt, svs: [Dyn], pvs: [Dyn]) -> [(Dyn, Dyn)] = {
  def isvs = zip (mapToIdx svs) svs;
  def jpvs = zip (mapToIdx pvs) pvs;

  map (fun isv: (Int, Dyn) -> {
        def (i, sv) = isv;

        def cpvs = map (fun jpv: (Int, Dyn) -> { def (j, pv) = jpv; (find (i + 1, j + 1) C, pv) }) jpvs;
        def cpvs = filter (fun jpv: (Int, Dyn) -> fst jpv != 0) cpvs;

        def f(a: Dyn, cpv: (Int, Dyn)) -> Dyn = {
          def (c, pv) = cpv;
          if c == 0 then a else bop c a pv
        };

        match cpvs with
        | (c, pv)::cpvs -> (sv, foldLeft f (uop c pv) cpvs)
        | [] -> (sv, zero)

      }) isvs
}

def mkPriScndVarsRelVector3(C: MatrixMapInt, svs: [SRMatrix], pvs: [SRMatrix]) -> [(SRMatrix, SRMatrix)] = {
  def uop(c: Int, v: SRMatrix) -> SRMatrix = { - (int2real c) *. v };
  def bop(c: Int, l: SRMatrix, r: SRMatrix) -> SRMatrix = { l - (int2real c) *. r };
  mkPriScndVarsRel uop bop zero3 C svs pvs
}

def mkPriScndVarsRelQuaternion(C: MatrixMapInt, sqs: [SRMatrix], pqs: [SRMatrix]) -> [(SRMatrix, SRMatrix)] = {
  def uop(c: Int, q: SRMatrix) -> SRMatrix = { if c < 0 then q else qconj q };
  def bop(c: Int, l: SRMatrix, r: SRMatrix) -> SRMatrix = { qprod l (uop c r) };
  mkPriScndVarsRel uop bop (mkQuaternion idq) C sqs pqs
}

def mkVector3CutsetRelation(Ays: (MatrixMapInt, ([SRMatrix], [SRMatrix]))) -> [(SRMatrix, SRMatrix)] = {
  def (A, (y_t, y_c)) = Ays;
  mkPriScndVarsRelVector3 A y_t y_c
}

def mkVector3CircuitRelation(Bxs: (MatrixMapInt, ([SRMatrix], [SRMatrix]))) -> [(SRMatrix, SRMatrix)] = {
  def (B, (x_t, x_c)) = Bxs;
  mkPriScndVarsRelVector3 B x_c x_t
}

def mkCutsetCircuitData(mes: [VectorPairEdge]) -> ((MatrixMapInt, ([SRMatrix], [SRMatrix])), (MatrixMapInt, ([SRMatrix], [SRMatrix]))) = {
  def (A, (T, C)) = mkCutsetMatrix mes;
  def B = -tr A;
  def _ = logg 2 "A" (fun t: () -> def _ = dp A; ());

  def (x_t, y_t) = unzip T;
  def (x_c, y_c) = unzip C;

  def _ = logg 2 "x_t" (loggprint x_t);
  def _ = logg 2 "x_c" (loggprint x_c);
  ((A, (y_t, y_c)), (B, (x_t, x_c)))
}

def mkCircuitData(mies: [VectorEdge]) -> (MatrixMapInt, ([Dyn], [Dyn])) = {
  def (A, (t, c)) = mkCutsetMatrix mies;
  def B = -tr A;
  (B, (t, c))
}

type MkEqsFun = (MatrixMapInt, ([Dyn], [Dyn])) -> Equations -> Equations
def mkTopolEquations(f_a: MkEqsFun, f_t: MkEqsFun, mes: [VectorPairEdge], a: Equations) -> Equations = {
  if isEmpty mes then a else {
    def ((A, (y_t, y_c)), (B, (x_t, x_c))) = mkCutsetCircuitData mes;
    f_t (A, (y_t, y_c)) (f_a (B, (x_c, x_t)) a)
  }
}

def mkTopolInitEquations(f_a: MkEqsFun, mies: [VectorEdge], a: Equations) -> Equations = {
  if isEmpty mies then a else {
    def (B, (x_t, x_c)) = mkCircuitData mies;
    f_a (B, (x_c, x_t)) a
  }
}

def mkVector3TopolEquations(Cvs: (MatrixMapInt, ([SRMatrix], [SRMatrix])), a: Equations) -> Equations = {
  def (C, (svs, pvs)) = Cvs;
  def rs = mkPriScndVarsRelVector3 C svs pvs;

  def work(rs: [(SRMatrix, SRMatrix)], a: Equations) -> Equations = {
    match rs with
    | [] -> a
    | r::rs -> work rs (a; fst r == snd r)
    | _ -> error "Unmatched"
  };

  work rs a
}

def mkQuaternionTopolInitEquations(Cvs: (MatrixMapInt, ([SRMatrix], [SRMatrix])), a: Equations) -> Equations = {
  def (C, (svs, pvs)) = Cvs;
  def rs = mkPriScndVarsRelQuaternion C svs pvs;

  def work(rs: [(SRMatrix, SRMatrix)], a: Equations) -> Equations = {
    match rs with
    | [] -> a
    | r::rs -> work rs (a; fst r ~== snd r)
    | _ -> error "Unmatched"
  };

  work rs a
}

def elaborate(e: Equations) -> Equations = {
  def (tes, e) = getTranslationEdges e;
  def (aves, e) = getAngularVelocityEdges e;
  def (ries, e) = getRotationInitEdges e;
  def e = mkTopolEquations mkVector3TopolEquations mkVector3TopolEquations tes e;
  def e = mkTopolEquations mkVector3TopolEquations mkVector3TopolEquations aves e;
  // def e = mkTopolInitEquations mkQuaternionTopolInitEquations ries e;
  e
}

def mkE(q: SRMatrix) = {
  def (q0, q1, q2, q3) = quatToTuple q;
  listToMatrix [
                [-q1,  q0, -q3,  q2],
                [-q2,  q3,  q0, -q1],
                [-q3, -q2,  q1,  q0]
               ] (mmSRealZero (3, 4))
}

def mkG(q: SRMatrix) = {
  def (q0, q1, q2, q3) = quatToTuple q;
  listToMatrix [
                [-q1,  q0,  q3, -q2],
                [-q2, -q3,  q0,  q1],
                [-q3,  q2, -q1,  q0]
               ] (mmSRealZero (3, 4))
}

def mkR(q: SRMatrix) = (mkE q) * (tr (mkG q))
def mkH(q: SRMatrix) = 0.5 *. (tr (mkE q))

def mkJ(d: RealVector3) = {
  def (Jxx, Jyy, Jzz) = d;
  add (1, 1) Jxx (add (2, 2) Jyy (add (3, 3) Jzz (mmSRealZero (3, 3))))
}

def mkOrthogonalBasis(u: RealVector3) -> (SRMatrix, SRMatrix, SRMatrix) = {
  def findNonParallelVector(v: SRMatrix) = {
    def (sval x: Real, sval y: Real, sval z: Real) = vec3ToTuple v;
    if x == 0. then mkVector3 1. y z
    else if y == 0. then mkVector3 x 1. z
    else if z == 0. then mkVector3 x y 1.
    else mkVector3 x (2. * y) (3. * z)
  };

  def u1 = mkVector3 u;
  def v = findNonParallelVector u1;
  def u2 = ss u1 * v;
  def u3 = ss u1 * u2;
  (u1, u2, u3)
}

def GRAVITATIONAL_CONSTANT = 9.81
def EPSILON = 1.e-10

// === Edge-less Physical Components ===

def clock(t0: Real, t: <Real>) -> Equations = {
  t' = 1.;
  // t' <- 1.;
  t <- t0
}

def mkCuboidInertia(m: Real, x: Real, y: Real, z: Real) -> RealVector3 = {
  ((m / 12.) * (y^2. + z^2.), (m / 12.) * (x^2. + z^2.), (m / 12.) * (y^2. + x^2.))
}

// === Single Edge Components ===

def forceActuator(f: SRMatrix, x: SRMatrix, f1: Frame, f2: Frame) -> Equations = {
  translationEdge f1 f2 x f
}

def forceActuator(f: SRMatrix, f1: Frame, f2: Frame) -> Equations = {
  def xfa1, xfa2, xfa3: Real;
  def x = mkVector3 xfa1 xfa2 xfa3;
  forceActuator f x f1 f2
}

def translationActuator(f: SRMatrix, F: SRMatrix, f1: Frame, f2: Frame) -> Equations = {
  translationEdge f1 f2 f F
}

def translationActuator(f: SRMatrix, f1: Frame, f2: Frame) -> Equations = {
  def Fta1, Fta2, Fta3: Real;
  def F = mkVector3 Fta1 Fta2 Fta3;
  translationActuator f F f1 f2
}

def angularVelocityActuator(f: SRMatrix, T: SRMatrix, f1: Frame, f2: Frame) -> Equations = {
  angularVelocityEdge f1 f2 f T
}

def angularVelocityActuator(f: SRMatrix, f1: Frame, f2: Frame) -> Equations = {
  def Tra1, Tra2, Tra3: Real;
  def T = mkVector3 Tra1 Tra2 Tra3;
  angularVelocityActuator f T f1 f2
}

def torqueActuator(f: SRMatrix, om: SRMatrix, f1: Frame, f2: Frame) -> Equations = {
  angularVelocityEdge f1 f2 om f
}

def torqueActuator(f: SRMatrix, f1: Frame, f2: Frame) -> Equations = {
  def omta1, omta2, omta3: Real;
  def om = mkVector3 omta1 omta2 omta3;
  torqueActuator f om f1 f2
}

def rotationSensor(q: SRMatrix, f1: Frame, f2: Frame) -> Equations = {
  if seq f1 f2 then q == mkQuaternion idq
  else {
    def oms1, oms2, oms3: Real;
    def om = mkVector3 oms1 oms2 oms3;
    def H = mkH q;
    q' == H * om;
    initialRotationEdge f1 f2 q;
    torqueActuator zero3 om f1 f2
  }
}

def angularVelocitySensor(om: SRMatrix, f1: Frame, f2: Frame) -> Equations = {
  torqueActuator zero3 om f1 f2
}

def translationSensor(x: SRMatrix, f1: Frame, f2: Frame) -> Equations = {
  if seq f1 f2 then x == zero3
  else forceActuator zero3 x f1 f2
}

def bodyT(m: Real, v: SRMatrix, x: SRMatrix, F: SRMatrix, world: Frame, fm: Frame) -> Equations = {
  translationEdge world fm x F;
  x' == v;
  F == m *. v';
}

def bodyT(m: Real, x: SRMatrix, world: Frame, fm: Frame) -> Equations = {
  def vm1, vm2, vm3, Fm1, Fm2, Fm3: Real;
  def v = mkVector3 vm1 vm2 vm3;
  def F = mkVector3 Fm1 Fm2 Fm3;
  bodyT m v x F world fm
}

def bodyR(Jd: RealVector3, om: SRMatrix, q: SRMatrix, T: SRMatrix, world: Frame, fm: Frame) -> Equations = {
  def R = mkR q;
  def H = mkH q;
  def J = mkJ Jd;
  def Jw = R * J * (tr R);
  angularVelocityEdge world fm om T;
  initialRotationEdge world fm q;
  q' == H * om;
  T == Jw * om' + (ss om) * Jw * om
}

def bodyR(Jd: RealVector3, q: SRMatrix, world: Frame, fm: Frame) -> Equations = {
  def omm1, omm2, omm3, Tm1, Tm2, Tm3: Real;
  def om = mkVector3 omm1 omm2 omm3;
  def T = mkVector3 Tm1 Tm2 Tm3;
  bodyR Jd om q T world fm
}

def rigidArm1T(r: RealVector3, F: SRMatrix, q2: SRMatrix, fm: Frame, fe: Frame) -> Equations = {
  translationActuator ((mkR q2) * (mkVector3 r)) F fm fe
}

def rigidArm1R(T: SRMatrix, fm: Frame, fe: Frame) -> Equations = {
  initialRotationEdge fm fe (mkQuaternion idq);
  angularVelocityActuator zero3 T fm fe
}

def rigidArm1R(fm: Frame, fe: Frame) -> Equations = {
  def Tr11, Tr12, Tr13: Real;
  def T = mkVector3 Tr11 Tr12 Tr13;
  rigidArm1R T fm fe
}

def rigidArm2R(r: RealVector3, F1: SRMatrix, om: SRMatrix, q: SRMatrix, T: SRMatrix, world: Frame, fm: Frame) -> Equations = {
  angularVelocityEdge world fm om T;
  initialRotationEdge world fm q;
  q' == (mkH q) * om;
  T == -(ss ((mkR q) * (mkVector3 r))) * F1
}

def rigidArm2R(r: RealVector3, F1: SRMatrix, q: SRMatrix, world: Frame, fm: Frame) -> Equations = {
  def omr21, omr22, omr23, Tr21, Tr22, Tr23: Real;
  def om = mkVector3 omr21 omr22 omr23;
  def T = mkVector3 Tr21 Tr22 Tr23;
  rigidArm2R r F1 om q T world fm
}

def gravity(m: Real, world: Frame, fm: Frame) -> Equations = {
  forceActuator ((m * GRAVITATIONAL_CONSTANT) *. mkVector3 zhat) world fm
}

def sphericalJoint(f1: Frame, f2: Frame) -> Equations = {
  translationActuator zero3 f1 f2
}

def revoluteJointR(u1: SRMatrix, u2: SRMatrix, u3: SRMatrix, om: SRMatrix, T: SRMatrix, f1: Frame, f2: Frame) -> Equations = {
  angularVelocityEdge f1 f2 om T;
  (tr u1) * T == zero1;
  (tr u2) * om == zero1;
  (tr u3) * om == zero1
}

def revoluteJointR(u1: SRMatrix, u2: SRMatrix, u3: SRMatrix, f1: Frame, f2: Frame) -> Equations = {
  def omhr1, omhr2, omhr3, Thr1, Thr2, Thr3: Real;
  def om = mkVector3 omhr1 omhr2 omhr3;
  def T = mkVector3 Thr1 Thr2 Thr3;
  revoluteJointR u1 u2 u3 om T f1 f2
}

def damperR(D: Real, f1: Frame, f2: Frame) -> Equations = {
  def omd1, omd2, omd3, Td1, Td2, Td3: Real;
  def om = mkVector3 omd1 omd2 omd3;
  def T = mkVector3 Td1 Td2 Td3;
  angularVelocityEdge f1 f2 om T;
  T == D *. om
}

// === Composed Components ===

def body(m: Real, Jd: RealVector3, x: SRMatrix, q: SRMatrix, world: Frame, fm: Frame) -> Equations = {
  bodyT m x world fm;
  bodyR Jd q world fm
}

def rigidArm(r: RealVector3, q: SRMatrix, world: Frame, fe: Frame, fm: Frame) -> Equations = {
  def Fr11, Fr12, Fr13: Real;
  def Fr1 = mkVector3 Fr11 Fr12 Fr13;
  rigidArm1T r Fr1 q fm fe;
  rigidArm1R fm fe;
  rigidArm2R r Fr1 q world fm
}

def revoluteJoint(u: RealVector3, q: SRMatrix, world: Frame, f1: Frame, f2: Frame) -> Equations = {
  def (u1, u2, u3) = mkOrthogonalBasis u;
  def R = mkR q;
  rotationSensor q world f1;
  revoluteJointR (R * u1) (R * u2) (R * u3) f1 f2
}

def angularVelocitySensorU(u: SRMatrix, omu: <Real>, f1: Frame, f2: Frame) -> Equations = {
  def oms1, oms2, oms3: Real;
  def om = mkVector3 oms1 oms2 oms3;
  angularVelocitySensor om f1 f2;
  omu = dot u om
}

def angularVelocitySensorU(u: RealVector3, omu: <Real>, q: SRMatrix, world: Frame, f1: Frame, f2: Frame) -> Equations = {
  def R = mkR q;
  def uu = mkVector3 u;
  rotationSensor q world f1;
  angularVelocitySensorU (R * uu) omu f1 f2
}
