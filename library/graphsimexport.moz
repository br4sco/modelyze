/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se

*/

include GRAPHSIMCORE
include Base

def MODEL_FILENAME = "/tmp/model.mo"
def NAME = "Model"

type InitValMap = (<Real> => (Real, Bool))
type VarNameMap = (<Real> => String)
type ParamsMap = (<Real> => Real)

def getUknowns(e: Model, ps: ParamsMap) -> Set(<Real>) = {
  def work(e: <?>, a: Set(<Real>)) -> Set(<Real>) = {
    match e with
    | e_1 e_2 -> work e_2 (work e_1 a)
    | sym: Real -> if Map.mem e ps then a else Set.add e a
    | _ -> a
  };

  work e (Set.empty)
}

def getInitalValMap(e: Model) -> InitValMap = {
  def work(e: Model, a: InitValMap) -> InitValMap = {
    match e with
    | Comp e_1 e_2 -> work e_2 (work e_1 a)
    | IVal u r -> {
        match (u, r) with
        | (sym: Real, sval r: Real) -> {
            if Map.mem u a then {
                def r_old = fst (Map.find u a);
                if r == r_old then a
                else error ("Inconsisent initial guesses for unknown: " ++ symstr(u))
            } else Map.add u (r, true) a
          }
        | _ -> error "Invalid initial value assignment"
      }
    | IValGuess u r -> {
        match (u, r) with
        | (sym: Real, sval r: Real) -> {
            if Map.mem u a then {
              if snd (Map.find u a) then a
              else {
                def r_old = fst (Map.find u a);
                if r == r_old then a
                else error ("Inconsisent initial guesses for unknown: " ++ symstr(u))
              }
            }
            else Map.add u (r, false) a
          }
        | _ -> error "Invalid initial value guess"
      }
    | _ -> a
  };

  work e (Map.empty)
}

def getProbedUknowns(e: Model) -> Set(<Real>) = {
  def work(e: Model, a: Set(<Real>)) -> Set(<Real>) = {
    match e with
    | probe x -> Set.add x a
    | Comp e_1 e_2 -> work e_2 (work e_1 a)
    | _ -> a
  };
  work e (Set.empty)
}

def getParameters(e: Model) -> ParamsMap = {
  def work(e: Model, a: ParamsMap) -> ParamsMap = {
    match e with
    | param p (sval v: Real) -> {
          match p with
          | sym: Real -> Map.add p v a
          | _ -> { def _ = dprintln p; error "Is not an unknown" }
        }
    | param _ _ -> { def _ = dprintln e; error "Invalid paramater defintion" }
    | Comp e_1 e_2 -> work e_2 (work e_1 a)
    | _ -> a
  };
  work e (Map.empty)
}

def r2mr(r: Real) -> String = {
    if r < 0. then "(" ++ real2string r  ++ ")"
    else real2string r
}

def pprintExpr(e: <Real>) -> String = {
  def work(e: <Real>) -> String = {
      match e with
      | e1 + e2 -> "(" ++ work e1 ++ " + " ++ work e2 ++ ")"
      | e1 - e2 -> "(" ++ work e1 ++ " - " ++ work e2 ++ ")"
      | e1 * e2 -> work e1 ++ " * " ++ work e2
      | e1 / e2 -> work e1 ++ " / " ++ work e2
      | -e -> "(-" ++ work e ++ ")"
      | e1^e2 -> work e1 ++ " ^ " ++ "(" ++ work e2 ++ ")"
      | der e -> "der(" ++ work e ++ ")"
      | ~sin e -> "sin(" ++ work e ++ ")"
      | ~cos e -> "cos(" ++ work e ++ ")"
      | ~tan e -> "tan(" ++ work e ++ ")"
      | ~asin e -> "asin(" ++ work e ++ ")"
      | ~acos e -> "acos(" ++ work e ++ ")"
      | ~atan e -> "atan(" ++ work e ++ ")"
      | ~sinh e -> "sinh(" ++ work e ++ ")"
      | ~cosh e -> "cosh(" ++ work e ++ ")"
      | ~tanh e -> "tanh(" ++ work e ++ ")"
      | ~sqrt e -> "sqrt(" ++ work e ++ ")"
      | ~exp e -> "exp(" ++ work e ++ ")"
      | ~log e -> "log(" ++ work e ++ ")"
      | ~log10 e -> "log10(" ++ work e ++ ")"
      | sym: Real -> symstr(e)
      | sval r: Real -> r2mr r
      | _ -> { def _ = dprintln e;  error "Unmatched" }
  };

  work e
}

def mkIVString(u: <Real>, ivm: InitValMap) = {
  if Map.mem u ivm then {
    def (u_0, fix) = (Map.find u ivm);
    " (start=" ++ r2mr u_0 ++ (if fix then ", fixed=true)" else ")")
  } else ""
}

def pprintUnknown(u: <Real>, ivm: InitValMap, probed: Set(<Real>)) -> String = {
  def iv = mkIVString u ivm;

  def show = (if Set.mem u probed then " annotation(HideResult=false)"
              else  " annotation(HideResult=true)");

  "Real " ++ symstr(u) ++ iv ++ show
}

def pprintUnknowns(ivm: InitValMap, probed: Set(<Real>), us: Set(<Real>)) -> String = {
  def f(a: String, u: <Real>) -> String = {
    a ++ " " ++ pprintUnknown u ivm probed ++ ";\n"
  };
  foldLeft f "" us
}

def pprintParameter(p: <Real>, v: Real) -> String = {
  "parameter Real " ++ symstr(p) ++ " = " ++ r2mr v
}

def pprintParameters(ps: ParamsMap) -> String  = {
  def f(a: String, pv: (<Real>, Real)) -> String = {
    def (p, v) = pv;
    a ++ " " ++ pprintParameter p v ++ ";\n"
  };
  foldLeft f "" (Map.toList ps)
}

def pprintInitEqs(e: Model) -> String = {
  match e with
  | Comp e_1 e_2 -> pprintInitEqs e_1 ++ pprintInitEqs e_2
  | IEq e_1 e_2 -> " " ++ pprintExpr e_1 ++ " = " ++ pprintExpr e_2 ++ ";\n"
  | _ -> ""
}

def pprintEqs(e: Model) -> String  = {
  match e with
  | Comp e_1 e_2 -> pprintEqs e_1 ++ pprintEqs e_2
  | Eq e_1 e_2 -> " " ++ pprintExpr e_1 ++ " = " ++ pprintExpr e_2 ++ ";\n"
  | _ -> ""
}

def export2ModelicaDebug(name: String, e: Model) -> String = {
  def ivm = getInitalValMap e;
  def ps = getParameters e;
  def us = getUknowns e ps;

  "model " ++ name ++ "\n"
  ++ pprintParameters ps
  ++ pprintUnknowns ivm us us
  ++ "initial equation\n"
  ++ pprintInitEqs e
  ++ "equation\n"
  ++ pprintEqs e
  ++ "end " ++ name ++ ";\n"
}

def export2ModelicaDebug(e: Model) -> String = {
  export2ModelicaDebug NAME e
}

def export2ModelicaFileDebug(file: String, name: String, e: Model) -> () = {
  writeFile file (export2ModelicaDebug name e ++ "\n");
}

def export2ModelicaFileDebug(e: Model) -> () = {
  export2ModelicaFileDebug MODEL_FILENAME NAME e
}

def export2Modelica(name: String, e: Model) -> String = {
  def probed = getProbedUknowns e;
  def ivm = getInitalValMap e;
  def ps = getParameters e;
  def us = getUknowns e ps;

  "model " ++ name ++ "\n"
  ++ pprintParameters ps
  ++ "protected\n"
  ++ pprintUnknowns ivm probed us
  ++ "initial equation\n"
  ++ pprintInitEqs e
  ++ "equation\n"
  ++ pprintEqs e
  ++ "end " ++ name ++ ";\n"
}

def export2Modelica(e: Model) -> String = {
  export2Modelica NAME e
}

def export2ModelicaFile(e: Model) -> () = {
  writeFile MODEL_FILENAME (export2Modelica e ++ "\n");
}

def export2Matlab(e: Model) -> String = {

  def r2mr(r: Real) -> String = {
      if r < 0. then "(" ++ real2string r  ++ ")"
      else real2string r
  };

  def ppSymFun(u: <Real>) -> String = { symstr(u) ++ "(t)" };
  def ppSym(u: <Real>) -> String = { symstr(u) };

  def ppSymFuns(us: Set(<Real>)) -> String = {
    def f(a: String, u: <Real>) -> String = {
      a ++ " " ++ ppSymFun u
    };

    foldLeft f "" us
  };

  def pprintSymbols(ss: Set(<Real>)) -> String = {
    def f(a: String, s: <Real>) -> String = {
      a ++ " " ++ ppSym s
    };

    foldLeft f "" ss
  };

  def pprintExpr(e: <>, us: Set(<Real>)) -> String = {
    def work(e: <>) -> String = {
      match e with
        | e1 + e2 -> "(" ++ work e1 ++ " + " ++ work e2 ++ ")"
        | e1 - e2 -> "(" ++ work e1 ++ " - " ++ work e2 ++ ")"
        | e1 * e2 -> work e1 ++ " * " ++ work e2
        | e1 / e2 -> work e1 ++ " / " ++ work e2
        | -e -> "(-" ++ work e ++ ")"
        | e1^e2 -> work e1 ++ " ^ " ++ "(" ++ work e2 ++ ")"
        | der e -> "diff(" ++ work e ++ ")"
        | ~sin e -> "sin(" ++ work e ++ ")"
        | ~cos e -> "cos(" ++ work e ++ ")"
        | ~tan e -> "tan(" ++ work e ++ ")"
        | ~asin e -> "asin(" ++ work e ++ ")"
        | ~acos e -> "acos(" ++ work e ++ ")"
        | ~atan e -> "atan(" ++ work e ++ ")"
        | ~sinh e -> "sinh(" ++ work e ++ ")"
        | ~cosh e -> "cosh(" ++ work e ++ ")"
        | ~tanh e -> "tanh(" ++ work e ++ ")"
        | ~sqrt e -> "sqrt(" ++ work e ++ ")"
        | ~exp e -> "exp(" ++ work e ++ ")"
        | ~log e -> "log(" ++ work e ++ ")"
        | ~log10 e -> "log10(" ++ work e ++ ")"
        | sym: Real -> if Set.mem e us then symstr(e) ++ "(t)" else symstr(e)
        | sval r: Real -> r2mr r
        | _ -> error "Unmatched"
    };
    work e
  };

  def pprintEqs(e: Model, us: Set(<Real>)) -> String  = {
    match e with
    | Comp e_1 e_2 -> pprintEqs e_1 us ++ "\n" ++ pprintEqs e_2 us
    | Eq e_1 e_2 -> pprintExpr e_1 us ++ " == " ++ pprintExpr e_2 us
    | _ -> ""
  };

  def probed = getProbedUknowns e;
  def ivm = getInitalValMap e;
  def ps = getParameters e;
  def us = getUknowns e ps;

  // "syms t " ++ pprintUnknowns e ++ "\n\n" ++
  // "vars = [" ++pprintUnknowns e ++ " ];\n\n" ++
  // "eqns = [" ++ pprintEqs e ++ "];\n\n"
  ""
}
