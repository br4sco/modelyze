/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include LGTF

type Vector
def (--) : Vector -> Vector
def (+) : Vector -> Vector -> Vector
def (*) : Vector -> Vector -> Vector
def (-) : Vector -> Vector -> Vector
def (*) : Real -> Vector -> Vector
def (*) : Vector -> Real -> Vector
def der : Vector -> Vector
def (') = der

type VectorTransMap = (Vector => Vector)
type Topology = (IMatrix, IMatrix, [Vector], [Vector])
def zero: Vector

def apply(fs: [(Dyn -> Dyn)], l: [Dyn]) -> [Dyn] = {
  def work(fs: [Dyn -> Dyn], l: [Dyn], a: [Dyn]) -> [Dyn] = {
    match fs with
    | f::fs -> {
        match l with
        | e::es -> work fs es ((f e)::a)
        | [] -> error "Uneven list lengths"
      }
    | [] -> {
        match l with
        | [] -> a
        | _ -> error "Uneven list lengths"
      }
  };
  reverse (work fs l [])
}

def vectorize(tm: TransMap) -> VectorTransMap = {
  def f(e: (Int, <Dyn>)) -> <Vector> = {
    if (fst e) < 0 then (snd e)
    else -(snd e)
  };

  def sum(l: [<Vector>]) -> <Vector> = {
    match l with
    | [] -> zero
    | t::[] -> t
    | t::ts -> t + (sum ts)
  };

  def work(a: VectorTransMap, e: (Dyn, [(Int, Dyn)])) -> VectorTransMap = {
    def v = fst e;
    def l = (map f (snd e));
    Map.add (fst e) (sum l) a
  };

  foldLeft work (Map.empty) (Map.toList tm)
}

def primaryVars(vtm: VectorTransMap, vs: [Vector]) -> [Vector] = {
  filter (fun v: Vector -> !(Map.mem v vtm)) vs
}

def equationGeneration(tv: [Vector], av: [Vector], ter: VectorTransMap, tran: VectorTransMap) -> ([Vector], [Vector]) = {

  def tv = map (fun t: Vector -> subs t ter) tv;
  def av = map (fun a: Vector -> subs a ter) av;

  def _ = dprint("=== SUBS TER  ===");
  def _ = dprint(tv);
  def _ = dprint(av);

  def tv = map (fun t: Vector -> subs t tran) tv;
  def av = map (fun a: Vector -> subs a tran) av;

  def _ = dprint("=== SUBS TM  ===");
  def _ = dprint(tv);
  def _ = dprint(av);


  if(
      (exists (fun t: Vector -> canSub t ter) tv) ||
      (exists (fun a: Vector -> canSub a ter) av) ||
      (exists (fun t: Vector -> canSub t tran) tv) ||
      (exists (fun a: Vector -> canSub a tran) av)
    ) then equationGeneration tv av ter tran
  else (tv, av)
}
