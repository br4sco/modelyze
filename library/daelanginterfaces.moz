/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include ModelyzeDAE
type VMap = (<Real> => Real)
type VMapElm = (<Real>, Real)
type Sigma = (Real, Set(Equations), VMap)
type SigmaT = (Real, Set(Equations), VMap, Set(?))
type Omega = (Equations, Real, Set(Equations), VMap, Set(<Real>))
type ZCMap = (<Real> => Int)

def makeZMapList(Z: Set(<Real>)) -> (ZCMap, [<Real>]) = {
  def f(i: Int, z: <Real>) -> (<Real>, Int) = { (z, i) };
  def Zl = (Set.toList Z);
  def Zm = list_to_map (mapi f Zl);
  (Zm, Zl)
}

def simple_assert(pred: Bool) = {
  if pred then println("OK!") else println("Fail! ");
}

def is_equal(lhs: <Real>, rhs: <Real>) -> Bool = Set.mem rhs (Set.add lhs (Set.empty))

def is_equal(lhs: Set(?), rhs: Set(?)) -> Bool = {
  def subsetleft = for_all (fun e: ? -> (Set.mem e rhs)) (Set.toList lhs);
  def subsetright = for_all (fun e: ? -> (Set.mem e lhs)) (Set.toList rhs);
  subsetleft && subsetright
}

def eval_from_vmap(a: <?>, f: VMap) -> ? = {
  def eval(a: <Real>) -> Real = {
    if (Map.mem a f) then (Map.find a f) else error "Undefined in eval from vmap"
  };
  match a with
  | der x -> eval a
  | sym: Real -> eval a
  | a_1 a_2 ->  (eval_from_vmap a_1 f) (eval_from_vmap a_2 f)
  | lift op: ? -> op
  | _ ->  error "Unsupported model construct"
}

def eval_from_arrays_with_default_val(expr: <Real>, ukm: UkMap, yy: VarArray,
  yp: VarArray, default: Real) -> Real = {
  def undefined_vars_in(expr: <?>) -> Bool = {
    // def _ = dprint(expr);
    match expr with
    | sym: Real -> !(Map.mem expr ukm)
    | der x -> undefined_vars_in x
    | f e -> (undefined_vars_in f) || (undefined_vars_in e)
    | lift v: ? -> false
    | _ -> error "Unmatched pattern in undefined_vars_in"
  };
  if undefined_vars_in expr then default
  else evalFromArray expr ukm yy yp
}

def cont_to_set(cont: ?) -> Set(?) = {
  def work(cont: ?, acc: Set(?)) -> Set(?) = {
    match cont with
    | this; that -> work that (work this acc)
    | last -> (Set.add last acc)
  };
  work cont (Set.empty)
}

def set_to_cont_impl(set: Set(?)) -> ? = {
   def work(l: [?], acc: ?) -> ? = {
      match l with
      | e::es -> work es (acc;e)
      | [] -> acc
   };
   def l = (Set.toList set);
   if (length l) == 0 then error "Empty set" else
   if (length l) == 1 then (hd l) else work (tl l) (hd l)
}

def set_to_cont(set: Set(?)) -> ? = {
  set_to_cont_impl set
}

def set_to_cont(set: Set(Equations)) -> Equations = {
  if (Set.size set) == 0 then NoEqn else set_to_cont_impl set
}

def E_vmap_to_ukmap_yy_yp(E: Set(Equations), vmap: VMap, undefval: Real) ->
  (UkMap, VarArray, VarArray) = {
  def (n, ukm) = realUnknowns (set_to_cont E);
  def yy = (Array.make n undefval);
  def yp = (Array.make n undefval);
  def work(gvlist: [VMapElm]) -> () = {
    def get_uk_and_arr(e: <Real>) -> (<Real>, VarArray) = {
      match e with
      | der x -> (x, yp)
      | x -> (x, yy)
      | _ -> error "expected variables and derivatives"
    };
    match gvlist with
    | e::es -> {
        def (ee, v) = e;
        def (x, a) = get_uk_and_arr ee;
        def (i, _) = (Map.find x ukm);
        def _ = (Array.set a i v);
        work es
      }
    | [] -> ()
  };
  def _ = work (Map.toList vmap);
  (ukm, yy, yp)
}

def ukmap_yy_yp_to_vmap(ukm: UkMap, yy: VarArray, yp: VarArray) -> VMap = {
  def f(acc: VMap,  e: (<Real>, (Int, Bool))) -> VMap = {
    def (x, (i, _)) = e;
    Map.add x (Array.get yy i) (Map.add (der x) (Array.get yp i) acc)
  };
  fold_left f (Map.empty) (Map.toList ukm)
}

def get_dae_solver_input(sigma: Sigma, Z: Set(<Real>), undefval: Real)
  -> (Residual, Int, Residual, VarArray, VarArray, VarArray, UkMap, ZCMap) = {

  def makeRootFun(zcbl: [<Real>], ukm: UkMap, t: Real, yy: VarArray, yp: VarArray) -> [Real] = {
    def f = (fun e: <Real> -> evalFromArray e ukm yy yp);
    map f zcbl
  };

  def (t, E, vmap) = sigma;
  def (ukm, yy, yp) = E_vmap_to_ukmap_yy_yp E vmap undefval;
  def vids = initConditionCorrection ukm;
  def resf = makeResidual ukm (set_to_cont E);
  def (zcbm, zcbl) = makeZMapList Z;
  def rootf = makeRootFun zcbl ukm;
  def nroots = (Map.size zcbm);
  (resf, nroots, rootf, yy, yp, vids, ukm, zcbm)
}

def get_dae_find_ic_input(sigma: Sigma, undefval: Real) ->
  (Residual, VarArray, VarArray, VarArray, UkMap) = {
  def (resf, _, _, yy, yp, vids, ukm, _) =
    get_dae_solver_input sigma (Set.empty) undefval;
  (resf, yy, yp, vids, ukm)
}
