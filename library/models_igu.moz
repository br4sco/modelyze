/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se

*/

include IGIVEUP

type Through = <Real>
type Across = <Real>
type Time = <Real>
type Signal = <Real>
type Current = Through
type Voltage = Across
type Torque = Through
type AngularVelocity = Across

def Clock(t_0: Real, t: Time) = {
  init t t_0 ++
  model (
    der t = 1.
  )
}

def UnitStep(t_s: Real, t: Time, s: Signal) = {
  switch
    (init s 0. ++ model (s = 0.))
    (t_s - t)
    (fun thk: () -> (init s 1. ++ model (s = 1.)))
}

def Dissipator(C: Real, t: Through, a: Across, p: Node, n: Node) = {
  model (
    Branch t a p n;
    C * a = t
  )
}

def Damper = Dissipator
def Resistor = (fun R: Real -> Dissipator (1. / R))

def AcrossGenerator(C: Real, t: Through, a: Across, p: Node, n: Node) = {
  model (
    Branch t a p n;
    a = C
  )
}

def VoltageSource = AcrossGenerator
def Motor = AcrossGenerator
def Conductor = AcrossGenerator 0.
def FixedAxis = AcrossGenerator 0.

def ThroughGenerator(C: Real, t: Through, a: Across, p: Node, n: Node) = {
  model (
    Branch t a p n;
    t = C
  )
}

def CurrentSource = ThroughGenerator
def ConstantForceSpring = ThroughGenerator
def Insulator = ThroughGenerator 0.
def FreeAxis = ThroughGenerator 0.

def AcrossStorage(C: Real, t: Through, a: Across, p: Node, n: Node) = {
  model (
    Branch t a p n;
    C * (der a) = t
  )  
}

def Mass = AcrossStorage
def Capacitor = AcrossStorage

def ThroughStorage(C: Real, t: Through, a: Across, p: Node, n: Node) = {
  model (
    Branch t a p n;
    C * (der t) = a
  )  
}

def Spring =  ThroughStorage
def Inductor = ThroughStorage

def OneWayThroughStop(bias: Real, t: Through, a: Across, p: Node, n: Node) = {
  def d(open: Bool) -> MModel = {
    if open then switch (AcrossGenerator bias t a p n) (t) (fun thnk: () -> d (!open))
    else switch (ThroughGenerator 0. t a p n) (bias - a) (fun thnk: () -> d (!open))
  };
  d true
}

def Diode = OneWayThroughStop

def Switch(s: Signal, p: Node, n: Node) = {
  def t: Through;
  def a: Across;
  def sw(open: Bool) -> MModel = {
    if open then switch (model (mnil ())) (s) (fun thk: () -> sw (!open))
    // if open then switch (ThroughGenerator 0. t a p n) (s) (fun thk: () -> sw (!open))
    else switch (AcrossGenerator 0. t a p n) (1. - s) (fun thk: () -> sw (!open))
  };
  sw true
}

def ElectricalSwitch = Switch
def Clutch = Switch
