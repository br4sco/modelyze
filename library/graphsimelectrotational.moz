/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include GRAPHSIMROTATIONAL
include GRAPHSIMELECTRICAL

type PointFun2NodeFun2 = Point -> Point -> Node -> Node -> Model
type PointFun1NodeFun2 = Point -> Node -> Node -> Model

def inParallel(l: PointFun2NodeFun2, r: PointFun2NodeFun2) -> PointFun2NodeFun2 = {
  fun f1: Point -> fun f2: Point -> fun n1: Node -> fun n2: Node ->
    l f1 f2 n1 n2;
    r f1 f2 n1 n2
}
def (||) = inParallel

def inSeries(l: Point, r: PointFun1NodeFun2) -> NodeFun2 = {
  r l
}
def (--) = inSeries

def inSeries(l: PointFun1NodeFun2, r: Point) -> NodeFun2 = {
  l r
}
def (--) = inSeries

def inSeries(f: Point, r: PointFun2NodeFun2) -> PointFun1NodeFun2 = {
  r f
}
def (--) = inSeries

def inSeries(l: PointFun1NodeFun2, r: PointFun2NodeFun2) -> PointFun1NodeFun2 = {
  fun f2: Point -> fun n1: Node -> fun n2: Node ->
    def f1: Point;
    l f1 n1 n2;
    r f1 f2 n1 n2
}
def (--) = inSeries

def inParallel(l: PointFun2NodeFun2, r: PointFun2) -> PointFun2NodeFun2 = {
  fun f1: Point -> fun f2: Point -> fun n1: Node -> fun n2: Node ->
    l f1 f2 n1 n2;
    r f1 f2
}
def (||) = inParallel

def inParallel(l: PointFun2, r: PointFun2NodeFun2) -> PointFun2NodeFun2 = inParallel r l
def (||) = inParallel

def inSeries(l: PointFun1, r: PointFun2NodeFun2) -> PointFun1NodeFun2 = {
  fun f2: Point -> fun n1: Node -> fun n2: Node ->
    def f1: Point;
    l f1;
    r f1 f2 n1 n2
}
def (--) = inSeries

def inSeries(l: PointFun1NodeFun2, r: PointFun2) -> PointFun1NodeFun2 = {
  fun f2: Point -> fun n1: Node -> fun n2: Node ->
    def f1: Point;
    l f1 n1 n2;
    r f1 f2
}
def (--) = inSeries

def inSeries(l: PointFun2NodeFun2, r: PointFun2) -> PointFun2NodeFun2 = {
  fun f1: Point -> fun f3: Point -> fun n1: Node -> fun n2: Node ->
    def f2: Point;
    l f1 f2 n1 n2;
    r f2 f3
}
def (--) = inSeries

def inSeries(l: PointFun2, r: PointFun2NodeFun2) -> PointFun2NodeFun2 = {
  fun f1: Point -> fun f3: Point -> fun n1: Node -> fun n2: Node ->
    def f2: Point;
    l f1 f2;
    r f2 f3 n1 n2
}
def (--) = inSeries

def inSeries(l: PointFun2NodeFun2, r: PointFun2NodeFun2) -> PointFun2NodeFun2 = {
  fun f1: Point -> fun f3: Point -> fun n1: Node -> fun n2: Node ->
    def f2: Point;
    l f1 f2 n1 n2;
    r f2 f3 n1 n2
}
def (--) = inSeries

def EMFE(k: Real, u: Voltage, i: Current, w: AngularVelocity) -> NodeFun2 = {
  fun n1: Node -> fun n2: Node ->
    electricalEdge n1 n2 u i;
    u = k * w
}

def EMFE(k: Real, i: Current, w: AngularVelocity) -> NodeFun2 = {
  fun n1: Node -> fun n2: Node ->
    def u_EMF: Voltage;
    n1 -- EMFE k u_EMF i w -- n2
}

def EMFM(k: Real, w: AngularVelocity, T: Torque, i: Current) -> PointFun2 = {
  fun f1: Point -> fun f2: Point ->
    def th_EMF: Angle;
    rotationEdge f1 f2 th_EMF  T;
    th_EMF' = w;
    T = k * i
}

def EMFM(k: Real, w: AngularVelocity, i: Current) -> PointFun2 = {
  fun f1: Point -> fun f2: Point ->
    def T_EMF: Torque;
    f1 -- EMFM k w T_EMF i -- f2
}
