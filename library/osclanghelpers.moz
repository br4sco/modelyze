/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include ModelyzeDAE
type VMap = (<Real> => Real)
type IVP = (Set(Equations), VMap, Real)
type Sysfun = ({Real} -> [Real])

// def EPSILON = 1.0e-10
def EPSILON = 0.

def isEqual(lhs: <Real>, rhs: <Real>) -> Bool =
  (Set.mem rhs (Set.add lhs (Set.empty)))

def isEqual(lhs: Set(?), rhs: Set(?)) -> Bool = {
  def subsetleft = forAll (fun e: ? -> (Set.mem e rhs)) (Set.toList lhs);
  def subsetright = forAll (fun e: ? -> (Set.mem e lhs)) (Set.toList rhs);
  subsetleft && subsetright
}

def checkStateVar(x: <Real>) -> () = {
  match x with
  | sym: Real -> ()
  | _ -> error "Not a state variable"
}

def find(x: <Real>, vmap: VMap) -> Real = {
  def _ = checkStateVar x;
  if (Map.mem x vmap) then (Map.find x vmap)
  else error "State variable undefined"
}

def add(x: <Real>, v: Real, vmap: VMap) -> VMap = {
  def _ = checkStateVar x;
  Map.add x v vmap
}

def isDefined(x: <Real>, vmap: VMap) -> Bool = {
  def _ = checkStateVar x;
  Map.mem x vmap
}

def evalRealFromVMap(a: <?>, mu: VMap) -> Real = {
  def yyfun(x: <Real>) -> <Real> = { (find x mu) };
  def ypfun(x: <Real>) -> <Real> = { error "we do not allow derivatives in vmap" };
  eval a yyfun ypfun
}

def evalBoolFromVMap(expr: <?>, vmap: VMap) -> Bool = {
  def llog = logger "evalBoolFromVMap";
  def _ = llog TRACE "expression" expr;
  def _ = llog TRACE "vmap" vmap;
  def evalReal(expr: <?>) -> Real = (evalRealFromVMap expr vmap);
  def evalBool(expr: <?>) -> Bool = {
    match expr with
    | e1 == e2 -> error "Not allowed to compare for equality in transitions."
    | e1 != e2 -> error "Not allowed to compare for equality in transitions."
    | e1 >= e2 -> evalReal(e1) >=  evalReal(e2)
    | e1 >  e2 -> evalReal(e1) >  evalReal(e2)
    | e1 <= e2 -> evalReal(e1) <=  evalReal(e2)
    | e1 <  e2 -> evalReal(e1) <  evalReal(e2)
    | !e1 -> !(evalBool(e1))
    | e1 && e2 -> evalBool(e1) && evalBool(e2)
    | e1 || e2 -> evalBool(e1) || evalBool(e2)
    | lift b: Bool -> b
    | _ -> error "The value is not a boolean type."
  };
  evalBool(expr);
}

def mkRootFuns(P: Set(<Bool>), ukm: UkMap, t: Real, yy: {Real}, yp: {Real}) -> [Real] = {

  def evalReal(e: <?>) -> Real = { (evalFromArrays e ukm yy yp) };

  def f(p: <Bool>) -> Real = {
    match p with
    | e_1 == e_2 -> error "Equality not allowed in root functions"
    | e_1 != e_2 -> error "Inequality not allowed in root functions"
    | e_1 >= e_2 -> (evalReal e_1) - (evalReal e_2)
    | e_1 >  e_2 -> (evalReal e_1) - (evalReal e_2) - EPSILON
    | e_1 <= e_2 -> (evalReal e_1) - (evalReal e_2)
    | e_1 <  e_2 -> (evalReal e_1) - (evalReal e_2) + EPSILON
    | _ -> error "We only allow operators <, <=, > and >="
  };

  map f (Set.toList P)
}

def splitAndAndOrs(P: Set(<Bool>)) -> Set(<Bool>) = {

  def f(P: Set(<Bool>), e: <Bool>) -> Set(<Bool>) = {
    match e with
    | e_1 && e_2 -> f (f P e_1) e_2
    | e_1 || e_2 -> error "We only allow && operator"
    | _ -> Set.add e P
  };

  foldLeft f (Set.empty) (Set.toList P)
}

def evalRealFromVMapWithDefaultVal(expr: <Real>, mu: VMap, default: Real)
  -> Real = {

  def hasUndefinedVars(expr: <?>) -> Bool = {
    match expr with
    | sym: Real -> !(isDefined expr mu)
    | der x -> !(Map.mem expr mu)
    | f e -> (hasUndefinedVars f) || (hasUndefinedVars e)
    | lift v: ? -> false
    | _ -> error "Unmatched pattern in hasUndefinedVars"
  };

  if hasUndefinedVars expr then default
  else evalRealFromVMap expr mu
}

def evalFromArraysWithDefaultVal(expr: <Real>, ukm: UkMap, yy: VarArray,
  yp: VarArray, default: Real) -> Real = {

  def hasUndefinedVars(expr: <?>) -> Bool = {
    match expr with
    | sym: Real -> !(Map.mem expr ukm)
    | der x -> hasUndefinedVars x
    | f e -> (hasUndefinedVars f) || (hasUndefinedVars e)
    | lift v: ? -> false
    | _ -> error "Unmatched pattern in hasUndefinedVars"
  };

  if hasUndefinedVars expr then default
  else evalFromArrays expr ukm yy yp
}

def contToSet(cont: ?) -> Set(?) = {
  def work(cont: ?, acc: Set(?)) -> Set(?) = {
    match cont with
    | this; that -> work that (work this acc)
    | last -> (Set.add last acc)
  };
  work cont (Set.empty)
}

def contToList(cont: ?) -> [?] = {
  reverse (Set.toList (contToSet cont))
}

def setToContImpl(set: Set(?)) -> ? = {
   def work(l: [?], acc: ?) -> ? = {
      match l with
      | e::es -> work es (acc;e)
      | [] -> acc
   };
   def l = (Set.toList set);
   if (length l) == 0 then error "Empty set" else
   if (length l) == 1 then (hd l) else work (tl l) (hd l)
}

def setToCont(set: Set(?)) -> ? = {
  setToContImpl set
}

def setToCont(set: Set(Equations)) -> Equations = {
  if (Set.size set) == 0 then NoEqn else setToContImpl set
}

def setArrayFromVMap(vm: VMap, udfv: Real, ukm: UkMap, yy: {Real}) -> () = {
  def f(u: (<Real>, (Int, Bool))) -> () = {
    def (x, (i, _)) = u;
    if !(isDefined x vm) then (Array.set yy i udfv)
    else (Array.set yy i (find x vm))
  };

  def _ = map f (Map.toList ukm);
  ()
}

def eVMapToUkMapYyYp(E: Set(Equations), vm: VMap, udfv: Real) ->
  (UkMap, VarArray, VarArray) = {
  def llog = logger "eVMapToUkMapYyYp" DEBUG;
  def (n, ukm) = realUnknowns (setToCont E);
  def yy = (Array.make n udfv);
  def yp = (Array.make n udfv);
  def _ = setArrayFromVMap vm udfv ukm yy;
  (ukm, yy, yp)
}

def eVMapToUkMapYy(E: Set(Equations), vm: VMap, udfv: Real) ->
  (UkMap, VarArray) = {
  def (n, ukm) = realUnknowns (setToCont E);
  def yy = (Array.make n udfv);
  def _ = setArrayFromVMap vm udfv ukm yy;
  (ukm, yy)
}

def ukMapYyToVMap(ukm: UkMap, yy: {Real}) -> VMap = {
  def f(acc: VMap, e: (<Real>, (Int, Bool))) -> VMap = {
    def (x, (i, _)) = e;
    Map.add x (Array.get yy i) acc
  };
  foldLeft f (Map.empty) (Map.toList ukm)
}

def ukMapYyYpToVMap(ukm: UkMap, yy: VarArray, yp: VarArray) -> VMap = {
  def f(acc: VMap,  e: (<Real>, (Int, Bool))) -> VMap = {
    def (x, (i, _)) = e;
    Map.add x (Array.get yy i) (Map.add (der x) (Array.get yp i) acc)
  };
  foldLeft f (Map.empty) (Map.toList ukm)
}

def getDAESolverInput(ivp: IVP, P: Set(<Bool>), undefval: Real)
  -> (Residual, Int, Residual, VarArray, VarArray, VarArray, UkMap) = {

  def (E, vmap, t) = ivp;
  def (ukm, yy, yp) = eVMapToUkMapYyYp E vmap undefval;
  def vids = initConditionCorrection ukm;
  def resf = makeResidual ukm (setToCont E);
  def PP = splitAndAndOrs P;
  def rootf = mkRootFuns PP ukm;
  def nroots = (Set.size PP);
  (resf, nroots, rootf, yy, yp, vids, ukm)
}

def getNLEQInput(E: Set(Equations), vm: VMap, udfv: Real)
  -> (Sysfun, UkMap, {Real}) = {

  def (ukm, yy) = eVMapToUkMapYy E vm udfv;
  def sysfun(yy: {Real}) -> [Real] = {
    def dummyYp = (Array.make 0 0.);
    def dummyt = 0.;
    makeResidual ukm (setToCont E) dummyt yy dummyYp
  };

  (sysfun, ukm, yy)
}

def solveNLEQ(E: Set(Equations), vm: VMap, udfv: Real) -> VMap = {
  def (sysfun, ukm, yy) = getNLEQInput E vm udfv;
  def s = (NLEQSolver.init sysfun yy);
  def _ = (NLEQSolver.solve s yy);
  ukMapYyToVMap ukm yy
}

// def makeBEulerFuns(eqs: Equations, ukm: UkMap, h: Real, yy0: {Real}, yy: {Real})
//   -> [Real] = {

//   def yyfun(x: <Real>) -> <Real> = { Array.get yy (fst (Map.find x ukm)) };
//   def ypfun(x: <Real>) -> <Real> = {
//     def i = (fst (Map.find x ukm));
//     ((Array.get yy i) - (Array.get yy0 i)) / h
//   };

//   def f(e: Equations) -> Real = {
//     match e with
//     | e1 = e2 -> (eval e1 yyfun ypfun) - (eval e2 yyfun ypfun)
//     | _ -> error "Expected only equations here"
//   };

//   map f (contToList eqs)
// }

// def interpolateOverZeroCrossing(zcm: ZCMap, zca: {Root}, ukm: UkMap,
//   t0: Real, yy0: {Real}, yp0: {Real}, t1: Real, yy1: {Real}, yp1: {Real}) -> Real = {

//   def f(a0: {Real}, a1: {Real}, t: Real, x: <Real>) -> <Real> = {
//     def i = (fst (Map.find x ukm));
//     def x0 = (Array.get a0 i);
//     def x1 = (Array.get a1 i);
//     (x1 - x0) / (t1 - t2) * (t - t0) + x0
//   };

//   def yyfun(t: Real, x: <Real>) = f yy0 yy1;
//   def ypfun(t: Real, x: <Real>) = f yp0 yp1;

//   def candidates =
//    map
//      (fun e: (<Real>, Int) -> fst e)
//      (filter
//        (fun b: (<Real>, Int) -> { def (e, i) = b; (Array.get zca i) != 0 })
//        (Map.toList zcm));

//   def sysf(ts: {Real}) -> [Real] = {
//     def f(i: Int, c: <Real>) -> Real = {
//       def t = (Array.get ts i);
//       eval c (yyfun t) (ypfun t)
//     };

//     mapi f candidates
//   };

//   def tt = (Array.mk )
// }
