/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include ModelyzeDAE
type VMap = (<Real> => Real)
type ZCMap = (Int => <Real>)
type IVP = (Set(Equations), VMap, Real)
type Sysfun = ({Real} -> [Real])

def CONSISTLIM = 0.01
def EPSILON = 1.0e-10
def EPSILON2 = 1.0e-15

def unmatched(llog: ((Int, String) -> String -> Dyn), pat: Dyn) = {
  def _ = llog INFO "Pattern:" pat;
  error "Unmatched pattern"
}

def isEqual(lhs: <Real>, rhs: <Real>) -> Bool =
  (Set.mem rhs (Set.add lhs (Set.empty)))

def isEqual(lhs: Set(?), rhs: Set(?)) -> Bool = {
  def subsetleft = forAll (fun e: ? -> (Set.mem e rhs)) (Set.toList lhs);
  def subsetright = forAll (fun e: ? -> (Set.mem e lhs)) (Set.toList rhs);
  subsetleft && subsetright
}

def checkStateVar(x: <Real>) -> () = {
  def llog = logger "checkStateVar" INFO;
  match x with
  | sym: Real -> ()
  | der xx -> checkStateVar xx
  | _ -> {
      def _ = llog "state var:" x;
      error "Not a state variable"
    }
}

def find(x: <Real>, vmap: VMap) -> Real = {
  def llog = logger "find" INFO;
  def _ = checkStateVar x;
  if (Map.mem x vmap) then (Map.find x vmap)
  else {
      def _ = llog "state var:" x;
      error "State variable undefined"
    }
}

def add(x: <Real>, v: Real, vmap: VMap) -> VMap = {
  def _ = checkStateVar x;
  Map.add x v vmap
}

def evalRealFromVMap(a: <?>, mu: VMap) -> Real = {
  def yyfun(x: <Real>) -> <Real> = { (find x mu) };
  def ypfun(x: <Real>) -> <Real> = { error "we do not allow derivatives in vmap" };
  eval a yyfun ypfun
}

def isDefined(map: VMap, e: <?>) -> Bool = {
  def llog = logger "isDefined";
  match e with
  | sym: Real -> (Map.mem e map)
  | der x -> (Map.mem e map)
  | e_1 e_2 -> (isDefined map e_1) && (isDefined map e_2)
  | lift v: ? -> true
  | _ -> unmatched llog e
}

def isDefinedUkMap(map: UkMap, e: <?>) -> Bool = {
  def llog = logger "isDefinedUkMap";
  match e with
  | sym: Real -> (Map.mem e map)
  | der x -> isDefinedUkMap map x
  | e_1 e_2 -> (isDefinedUkMap map e_1) && (isDefinedUkMap map e_2)
  | lift v: ? -> true
  | _ -> unmatched llog e
}


def isIEDerDefined(map: (<Real> => Real), e: <?>) -> Bool = {
  def llog = logger "isIEDerDefined";
  match e with
  | der x -> isDefined map x
  | e_1 e_2 -> (isIEDerDefined map e_1) && (isIEDerDefined map e_2)
  | sym: Real -> true
  | lift v: ? -> true
  | _ -> unmatched llog e
}

def evalBoolFromVMap(e: <?>, vmap: VMap) -> Bool = {
  def llog = logger "evalBoolFromVMap";
  def _ = llog TRACE "expression" e;
  def _ = llog TRACE "vmap" vmap;
  def evalReal(e: <?>) -> Real = (evalRealFromVMap e vmap);
  def evalBool(e: <?>) -> Bool = {
    match e with
    | e1 == e2 -> error "Not allowed to compare for equality in transitions."
    | e1 != e2 -> error "Not allowed to compare for equality in transitions."
    | e1 >= e2 -> evalReal(e1) >=  evalReal(e2)
    | e1 >  e2 -> evalReal(e1) >  evalReal(e2)
    | e1 <= e2 -> evalReal(e1) <=  evalReal(e2)
    | e1 <  e2 -> evalReal(e1) <  evalReal(e2)
    | !e1 -> !(evalBool(e1))
    | e1 && e2 -> evalBool(e1) && evalBool(e2)
    | e1 || e2 -> evalBool(e1) || evalBool(e2)
    | lift b: Bool -> b
    | _ -> unmatched llog e
  };
  evalBool(e);
}

def contToSet(cont: ?) -> Set(?) = {
  def work(cont: ?, acc: Set(?)) -> Set(?) = {
    match cont with
    | this; that -> work that (work this acc)
    | last -> (Set.add last acc)
  };
  work cont (Set.empty)
}

def contToList(cont: ?) -> [?] = {
  reverse (Set.toList (contToSet cont))
}

def setToContImpl(set: Set(?)) -> ? = {
   def work(l: [?], acc: ?) -> ? = {
      match l with
      | e::es -> work es (acc;e)
      | [] -> acc
   };
   def l = (Set.toList set);
   if (length l) == 0 then error "Empty set" else
   if (length l) == 1 then (hd l) else work (tl l) (hd l)
}

def setToCont(set: Set(?)) -> ? = {
  setToContImpl set
}

def setToCont(set: Set(Equations)) -> Equations = {
  if (Set.size set) == 0 then NoEqn else setToContImpl set
}

def updArr(x: <Real>, vm: VMap, i: Int, a: {Real}) -> () = {
  if !(isDefined vm x) then ()
  else (Array.set a i (find x vm))
}

def eVMapToUkMapYyYp(E: Set(Equations), vm: VMap, udfv: Real) ->
  (UkMap, {Real}, {Real}) = {
  def llog = logger "eVMapToUkMapYyYp" DEBUG;
  def (n, ukm) = realUnknowns (setToCont E);
  def yy = (Array.make n udfv);
  def yp = (Array.make n udfv);
  def _ = map
    (fun e: (<Real>, (Int, Bool)) ->
      { def (x, (i, _)) = e; updArr x vm i yy })
    (Map.toList ukm);
  def _ = map
    (fun e: (<Real>, (Int, Bool)) ->
      { def (x, (i, _)) = e; updArr (der x) vm i yp })
    (Map.toList ukm);
  (ukm, yy, yp)
}

def eVMapToUkMapYy(E: Set(Equations), vm: VMap, udfv: Real) ->
  (UkMap, {Real}) = {
  def (n, ukm) = realUnknowns (setToCont E);
  def yy = (Array.make n udfv);
  def _ = map
    (fun e: (<Real>, (Int, Bool)) ->
      { def (x, (i, _)) = e; updArr x vm i yy })
    (Map.toList ukm);
  (ukm, yy)
}

def ukMapYyYpToVMap(ukm: UkMap, yy: {Real}, yp: {Real}) -> VMap = {
  def f(acc: VMap,  e: (<Real>, (Int, Bool))) -> VMap = {
    def (x, (i, _)) = e;
    Map.add x (Array.get yy i) (Map.add (der x) (Array.get yp i) acc)
  };

  foldLeft f (Map.empty) (Map.toList ukm)
}


def ukMapYyToVMap(ukm: UkMap, yy: {Real}) -> VMap = {
  def f(acc: VMap,  e: (<Real>, (Int, Bool))) -> VMap = {
    def (x, (i, _)) = e;
    Map.add x (Array.get yy i) acc
  };

  foldLeft f (Map.empty) (Map.toList ukm)
}

def indexred(E: Set(Equations)) -> Set(Equations) = {
  def (Ep, dmap) = indexReducationPantelides (setToCont E) (Map.empty);
  contToSet Ep
}

def getDAESolverInput(ivp: IVP, P: Set(<Bool>), undefval: Real)
  -> (Residual, Int, Residual, {Real}, {Real}, {Real}, UkMap, ZCMap) = {

  def (E, vmap, t) = ivp;
  def (ukm, yy, yp) = eVMapToUkMapYyYp E vmap undefval;

  def mkRootExpr(P: Set(<Bool>)) -> [<Real>] = {
    def f(p: <Bool>) -> <Real> = {
      match p with
      | e_1 == e_2 -> error "Equality not allowed in root functions"
      | e_1 != e_2 -> error "Inequality not allowed in root functions"
      // | e_1 >= e_2 -> e_1 - e_2
      | e_1 >  e_2 -> e_1 - e_2
      // | e_1 <= e_2 -> e_2 - e_1
      | e_1 <  e_2 -> e_2 - e_1
      // | _ -> error "We only allow operators <, <=, > and >="
      | _ -> error "We only allow operators < and >"
    };

    map f (Set.toList P)
  };

  def mkRootFuns(re: [<Real>], ukm: UkMap, t: Real, yy: {Real}, yp: {Real})
    ->   [Real] = {

    def f(e: <Real>) -> Real = { (evalFromArrays e ukm yy yp) };
    map f re
  };

  def splitAndAndOrs(P: Set(<Bool>)) -> Set(<Bool>) = {

    def f(P: Set(<Bool>), e: <Bool>) -> Set(<Bool>) = {
      match e with
      | e_1 && e_2 -> f (f P e_1) e_2
      | e_1 || e_2 -> error "We only allow && operator"
      | _ -> Set.add e P
    };

    foldLeft f (Set.empty) (Set.toList P)
  };


  def mkZCMap(re: [<Real>]) -> ZCMap = {
    def f(i: Int, e: <Real>) -> (Int, <Real>) = { (i, e) };
    listToMap (mapi f re)
  };

  def vids = initConditionCorrection ukm;
  def resf = makeResidual ukm (setToCont E);
  def re = mkRootExpr (splitAndAndOrs P);
  def rootf = mkRootFuns re ukm;
  def zcm = mkZCMap re;
  def nroots = (Map.size zcm);
  (resf, nroots, rootf, yy, yp, vids, ukm, zcm)
}

def getDAEFindICInput(ivp: IVP, undefval: Real) ->
  (Residual, {Real}, {Real}, {Real}, UkMap) = {
  def (resf, _, _, yy, yp, vids, ukm, _) =
    getDAESolverInput ivp (Set.empty) undefval;
  (resf, yy, yp, vids, ukm)
}

def findiv(ivp: IVP) -> (VMap, Real) = {
  def dt = 0.00001;
  def (_, _, t0) = ivp;
  def (resf, yy0, yp0, vids, ukm) = getDAEFindICInput ivp 0.;
  def s = (DAESolver.init resf t0 yy0 yp0);
  def _ = (DAESolver.calcIcYaYdp s vids yy0 yp0 (t0 + dt));
  (ukMapYyYpToVMap ukm yy0 yp0, t0 +  dt)
}

def getNLEQInput(E: Set(Equations), vm: VMap, udfv: Real)
  -> (Sysfun, UkMap, {Real}) = {

  def (ukm, yy) = eVMapToUkMapYy E vm udfv;
  def sysfun(yy: {Real}) -> [Real] = {
    def dummyYp = (Array.make 0 0.);
    def dummyt = 0.;
    makeResidual ukm (setToCont E) dummyt yy dummyYp
  };

  (sysfun, ukm, yy)
}

def solveNLEQ(E: Set(Equations), vm: VMap, udfv: Real) -> VMap = {
  def (sysfun, ukm, yy) = getNLEQInput E vm udfv;
  def s = (NLEQSolver.init sysfun yy);
  def _ = (NLEQSolver.solve s yy);
  ukMapYyToVMap ukm yy
}

def linIpol(x0: Real, x1: Real, t0: Real, t1: Real, t: Real) -> Real = {
  (x1 - x0) / (t1 - t0) * (t - t0) + x0
}

def ipolArray(a0: {Real}, a1: {Real}, t0: Real, t1: Real, t: Real, aout: {Real})
  -> () = {

  def llog = logger "ipolArray" TRACE;
  def f(i: Int, e: Real) -> () = {
    (Array.set aout i (linIpol (Array.get a0 i) (Array.get a1 i) t0 t1 t))
  };
  def _ = llog "t0" t0;
  def _ = llog "t" t;
  def _ = llog "t1" t1;
  def _ = llog "a0" a0;
  def _ = llog "before interpolation" aout;
  def _ = iteri f aout;
  def _ = llog "after interpolation" aout;
  ()
}

def ipolZCTime(zcm: ZCMap, zca: {Root}, ukm: UkMap,
  t0: Real, yy0: {Real}, yp0: {Real}, t1: Real, yy1: {Real}, yp1: {Real})
  -> Real = {

  def eval(e: <Real>, t: Real) -> Real = {
    def f(a0: {Real}, a1: {Real}, t: Real, x: <Real>) -> <Real> = {
      def i = (fst (Map.find x ukm));
      linIpol (Array.get a0 i) (Array.get a1 i) t0 t1 t
    };

    def yyfun(t: Real, x: <Real>) = f yy0 yy1 t x;
    def ypfun(t: Real, x: <Real>) = f yp0 yp1 t x;

    eval e (yyfun t) (ypfun t) - EPSILON
  };

  def candidates =
   map
     (fun e: (Int, <Real>) -> snd e)
     (filter
       (fun b: (Int, <Real>) -> { def (i, e) = b; (Array.get zca i) != 0 })
       (Map.toList zcm));

  def sysf(ts: {Real}) -> [Real] = {
    def f(i: Int, c: <Real>) -> Real = {
      def t = (Array.get ts i);
      eval c t
    };

    mapi f candidates
  };

  def tt = (Array.make (length candidates) ((t1 - t0) / 2.));
  def s = (NLEQSolver.init sysf tt);
  def _ = (NLEQSolver.solve s tt);
  min tt
}

def trunc(a: {Real}, epsilon: Real) -> () = {
  def f(i: Int, e: Real) -> () = {
    if (abs e) < epsilon then (Array.set a i 0.) else ()
  };

  iteri f a
}

def trunc(vm: VMap, epsilon: Real) -> VMap = {
  def f(e: (<Real>, Real)) -> (<Real>, Real) = {
    def (x, v) = e;
    if (abs v) < epsilon then (x, 0.) else e
  };

  listToMap (map f (Map.toList vm))
}
