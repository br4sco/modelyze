/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Equation
include LGTF

def Branch : Dyn -> Dyn -> Dyn -> Dyn -> Equations

def contToSet(cont: ?) -> Set(?) = {
  def work(cont: ?, acc: Set(?)) -> Set(?) = {
    match cont with
    | this; that -> work that (work this acc)
    | last -> (Set.add last acc)
  };
  work cont (Set.empty)
}

def contToList(cont: ?) -> [?] = {
  reverse (Set.toList (contToSet cont))
}

def setToContImpl(set: Set(?)) -> ? = {
   def work(l: [?], acc: ?) -> ? = {
      match l with
      | e::es -> work es (acc;e)
      | [] -> acc
   };
   def l = (Set.toList set);
   if (length l) == 0 then error "Empty set" else
   if (length l) == 1 then (hd l) else work (tl l) (hd l)
}

def setToCont(set: Set(?)) -> ? = {
  setToContImpl set
}

def buildEquations(tm: TransMap) -> Set(Equations) = {
  def f(e: (Int, <Dyn>)) -> <Real> = {
    if (fst e) < 0 then (snd e)
    else -(snd e)
  };

  def sum(l: [<Real>]) -> <Real> = {
    def work(s: <Real>, t: <Real>) -> <Real> = {
      s + t
    };
    def zero: <Real> = 0.;
    foldLeft work zero l
  };

  def work(a: Set(Equations), e: (Dyn, [(Int, Dyn)])) -> Set(Equations) = {
    def v = fst e;
    def l = (map f (snd e));
    Set.add ((fst e) = (sum l)) a
  };

  foldLeft work (Set.empty) (Map.toList tm)
}

def elaboratetopology(T: Set(Equations)) -> Equations = {

  def getEdges(Tl: [Equations]) -> [Edge] = {

    def f(em: [Edge], e: Equations) -> [Edge] = {

      match e with
      | Branch t a p n -> (n, p, t, a)::em
      | _ -> error "Unrecognized element type in topological description"
    };

    foldLeft f [] Tl
  };

  if (Set.size T) == 0 then mnil ()
  else {
    def E = getEdges (Set.toList T);
    def (A, B, tv, av) = getCircAndCutMatrices(E);
    def (ct, bt) = getChordBranchTransMaps A B tv av;
    def cutseteqs = buildEquations ct;
    def circeqs = buildEquations bt;
    def E = union cutseteqs circeqs;
    setToCont E
  }
}
