/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Equation
include LGTF

def Branch : Dyn -> Dyn -> Dyn -> Dyn -> Equations

def contToSet(cont: ?) -> Set(?) = {
  def work(cont: ?, acc: Set(?)) -> Set(?) = {
    match cont with
    | this; that -> work that (work this acc)
    | last -> (Set.add last acc)
  };
  work cont (Set.empty)
}

def contToList(cont: ?) -> [?] = {
  reverse (Set.toList (contToSet cont))
}

def setToContImpl(set: Set(?)) -> ? = {
   def work(l: [?], acc: ?) -> ? = {
      match l with
      | e::es -> work es (acc;e)
      | [] -> acc
   };
   def l = (Set.toList set);
   if (length l) == 0 then error "Empty set" else
   if (length l) == 1 then (hd l) else work (tl l) (hd l)
}

def setToCont(set: Set(?)) -> ? = {
  setToContImpl set
}

def matrixVMapToEquations(IM: IMatrix, vm: (Int => <Dyn>)) -> Set(Equations) = {
  def (M, n, m) = IM;

  def vmapElmToSReal(e: (Int, Int)) -> <Dyn> = {
    def (i, c) = e;
    (int2real c)*(Map.find i vm)
  };

  def f(exp: <Dyn>, e: (Int, Int)) -> <Dyn> = { exp + (vmapElmToSReal e) };

  def work(i: Int, acc: Set(Equations)) -> Set(Equations) = {
    if i >= n then acc
    else {
      def r = (Map.find i M);
      if (Map.size r) < 1 then
        error "Did not expect a zero row here"
      else
        def rl = (Map.toList r);
        def h = vmapElmToSReal (hd rl);
        if (Map.size r) < 2 then work (i + 1) (Set.add (h = 0.) acc)
        else {
          def eq = (foldLeft f h (tl rl)) = 0.;
          work (i + 1) (Set.add eq acc)
        }
    }
  };

  if m != (Map.size vm) then
    error "The number of columns and variables doesn't match"
  else work 0 (Set.empty)
}

def elaboratetopology(T: Set(Equations)) -> Equations = {
  def llog = logger "elaboratetopology" DEBUG;

  def getEdges(Tl: [Equations]) -> [Edge] = {

    def f(em: [Edge], e: Equations) -> [Edge] = {

      match e with
      | Branch t a p n -> (n, p, t, a)::em
      | _ -> error "Unrecognized element type in topological description"
    };

    foldLeft f [] Tl
  };

  def getCircAndCutMatrices(T: Set(Equations)) ->
    (IMatrix, IMatrix, EdgeVarMap) = {

    def el = getEdges (Set.toList T);
    def _ = llog "edge list" el;

    // TODO: handle self loops
    def (IM, vm) = buildIncidenceMatrix el;
    def _ = llog "Incidence Matrix" (pp IM);
    def _ = llog "Variable Map" vm;

    def IMr = rowreduce IM;
    def (A, nvm) = getFCutsetMatrix IMr vm;
    def _ = llog "Cutset Matrix (A)" (pp A);
    def _ = llog "modified Variable Map" nvm;

    def B = getFCircuitMatrix A;
    def _ = llog "Circuit Matrix (B)" (pp B);

    (A, B, nvm)
  };

  if (Set.size T) == 0 then mnil ()
  else {
    def ff(ee: (Int, (<Dyn>, <Dyn>))) -> (Int, <Dyn>) = {
      def (i, (t, _)) = ee;
      (i, t)
    };

    def fe(ee: (Int, (<Dyn>, <Dyn>))) -> (Int, <Dyn>) = {
      def (i, (_, a)) = ee;
      (i, a)
    };

    def (A, B, vm) = getCircAndCutMatrices(T);

    def tvec = listToMap (map ff (Map.toList vm));
    def _ = llog "we have flow vec:" tvec;

    def cutseteqs = matrixVMapToEquations A tvec;
    def _ = llog "flow eqs:" cutseteqs;

    def (_, n, _) = B;
    if (n != 0) then {

      def avec = listToMap (map fe (Map.toList vm));
      def _ = llog "and effort vec:" avec;

      def circeqs = matrixVMapToEquations B avec;
      def _ = llog "circ eqs:" circeqs;

      def E = union cutseteqs circeqs;
      def _ = llog "topological equations" (setToCont E);

      setToCont E
    } else {
      def _ =
        llog "We only have one edge, topological equations" (setToCont cutseteqs);
      setToCont cutseteqs
    }
  }
}
