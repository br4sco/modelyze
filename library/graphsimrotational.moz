/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include GRAPHSIMCORE

type Point
type PointFun1 = Point -> Model
type PointFun2 = Point -> Point -> Model

def inParallel(l: PointFun2, r: PointFun2) -> PointFun2 = {
  fun f1: Point -> fun f2: Point ->
    l f1 f2;
    r f1 f2
}
def (||) = inParallel

def inSeries(l: PointFun1, r: PointFun1) -> PointFun1 = {
  fun f2: Point ->
    l f2;
    r f2
}
def (--) = inSeries

def inSeries(l: Point, r: PointFun1) -> Model = {
  r l
}
def (--) = inSeries

def inSeries(l: PointFun1, r: Point) -> Model = {
  l r
}
def (--) = inSeries

def inSeries(f: Point, r: PointFun2) -> PointFun1 = {
  r f
}
def (--) = inSeries

def inSeries(l: PointFun1, r: PointFun2) -> PointFun1 = {
  fun f2: Point ->
    def f1: Point;
    l f1;
    r f1 f2
}
def (--) = inSeries

def inSeriesExposeNode(l: PointFun2, f2: Point) -> (PointFun2, Point) = {
  (l, f2)
}
def (-.-) = inSeriesExposeNode

def inSeriesExposeNode(lf2: (PointFun2, Point), r: PointFun2) -> PointFun2 = {
  fun f1: Point -> fun p3: Point ->
    def (l, f2) = lf2;
    l f1 f2;
    r f2 p3
}
def (-.-) = inSeriesExposeNode

def inSeries(l: PointFun2, r: PointFun2) -> PointFun2 = {
  fun f1: Point -> fun f3: Point ->
    def f2: Point;
    l f1 f2;
    r f2 f3
}
def (--) = inSeries

def serializei(f: (Int -> PointFun2), n: Int) -> PointFun2 = {
  def work(a: PointFun2, i: Int) -> PointFun2 = {
    if n - i < 0 then error "n is not a positive number"
    else if n - i == 0 then a
    else work (a -- f (i + 1)) (i + 1)
  };
  work (f 1) 1
}

def serialize(f: PointFun2, n: Int) -> PointFun2 = {
  serializei (fun i: Int -> f) n
}

type Torque = <Real>
type Angle = <Real>
type AngularVelocity = <Real>

def rotationEdge: Point -> Point -> Angle -> Torque -> Model

def getRotationEdges(e: Model) -> ([ScalarPairEdge], Model) = {
  def work(e: Model, a: ([ScalarPairEdge], Model))
    -> ([ScalarPairEdge], Model) = {

    match e with
    | Comp e_1 e_2 -> work e_2 (work e_1 a)
    | rotationEdge n_1 n_2 x y ->
        (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)

  };

  work e ([], NoElement)
}

def TorqueActuator(f: Torque, th: Angle) -> PointFun2 = {
  fun f1: Point -> fun f2: Point ->
    rotationEdge f1 f2 th f;
}

def TorqueActuator(f: Torque) -> PointFun2 = {
  fun f1: Point -> fun f2: Point ->
    def th_A: Angle;
    f1 -- TorqueActuator f th_A -- f2
}

def RotationActuator(f: Angle, T: Torque) -> PointFun2 = {
  fun f1: Point -> fun f2: Point ->
    rotationEdge f1 f2 f T;
}

def RotationActuator(f: Angle) -> PointFun2 = {
  fun f1: Point -> fun f2: Point ->
    def F_A: Torque;
    f1 -- RotationActuator f F_A -- f2
}

def TorqueActuator(f: Torque) -> PointFun2 = {
  fun f1: Point -> fun f2: Point ->
    def th_A: Angle;
    f1 -- TorqueActuator f th_A -- f2
}

def TorqueSensor1d(s: Torque) -> PointFun2 = {
  fun f1: Point -> fun f2: Point ->
    f1 -- RotationActuator 0. s -- f2
}

def AngleSensor(s: Angle) -> PointFun2 = {
  fun f1: Point -> fun f2: Point ->
    def th_S: Angle;
    f1 -- TorqueActuator 0. th_S -- f2;
    th_S = s
}

def AngularVelocitySensor(w: AngularVelocity) -> PointFun2 = {
  fun f1: Point -> fun f2: Point ->
    def th_S: Angle;
    f1 -- AngleSensor th_S -- f2;
    th_S' = w
}

def SpringR(k: <Real>, th: Angle, T: Torque) -> PointFun2 = {
  fun f1: Point -> fun f2: Point ->
    rotationEdge f1 f2 th T;
    T = -k * th
}

def SpringR(k: <Real>) -> PointFun2 = {
  fun f1: Point -> fun f2: Point ->
    def th_K: Angle;
    def T_K: Torque;
    f1 -- SpringR k th_K T_K -- f2
}

def DamperR(d: <Real>, th: Angle, T: Torque) -> PointFun2 = {
  fun f1: Point -> fun f2: Point ->
    def w_D: AngularVelocity;
    rotationEdge f1 f2 th T;
    th' = w_D;
    T = -d * w_D
}

def DamperR(d: <Real>) -> PointFun2 = {
  fun f1: Point -> fun f2: Point ->
    def th_D: Angle;
    def T_D: Torque;
    f1 -- DamperR d th_D T_D -- f2
}


def FixedJoint = {
  fun p1: Point -> fun p2: Point ->
    def th, T: Real;
    rotationEdge p1 p2 th T;
    th = 0.
}

def Inertia(J: <Real>, th: Angle, T: Torque) -> PointFun2 = {
  fun f1: Point -> fun f2: Point ->
    def w_J: AngularVelocity;
    rotationEdge f1 f2 th T;
    th' = w_J;
    T = -J * w_J'
}

def Inertia(J: <Real>, th0: Real, w0: Real) -> PointFun2 = {
  fun f1: Point -> fun f2: Point ->
    def th_J: Angle;
    def T_J: Torque;
    def w_J: AngularVelocity;
    rotationEdge f1 f2 th_J T_J;
    th_J' = w_J;
    T_J = -J * w_J';
    th_J <- th0;
    w_J <- w0
}

def Inertia(world: Point, J: Real, th0: Real, w0: Real, p1: Point, p2: Point) -> Model = {
  world -- Inertia(J, th0, w0) -- p2;
  p1 -- FixedJoint -- p2
}

// def Inertia(J: <Real>) -> PointFun2 = {
//   fun f1: Point -> fun f2: Point ->
//     def th_J: Angle;
//     def T_J: Torque;
//     f1 -- Inertia(J, th_J, T_J) -- f2
// }
