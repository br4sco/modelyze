/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include GRAPHSIMCORE

type Flange
type FlangeFun1 = Flange -> Model
type FlangeFun2 = Flange -> Flange -> Model

def inParallel(l: FlangeFun2, r: FlangeFun2) -> FlangeFun2 = {
  fun f1: Flange -> fun f2: Flange ->
    l f1 f2;
    r f1 f2
}
def (||) = inParallel

def inSeries(l: FlangeFun1, r: FlangeFun1) -> FlangeFun1 = {
  fun f2: Flange ->
    l f2;
    r f2
}
def (--) = inSeries

def inSeries(l: Flange, r: FlangeFun1) -> Model = {
  r l
}
def (--) = inSeries

def inSeries(l: FlangeFun1, r: Flange) -> Model = {
  l r
}
def (--) = inSeries

def inSeries(f: Flange, r: FlangeFun2) -> FlangeFun1 = {
  r f
}
def (--) = inSeries

def inSeries(l: FlangeFun1, r: FlangeFun2) -> FlangeFun1 = {
  fun f2: Flange ->
    def f1: Flange;
    l f1;
    r f1 f2
}
def (--) = inSeries

def inSeriesExposeNode(l: FlangeFun2, f2: Flange) -> (FlangeFun2, Flange) = {
  (l, f2)
}
def (-.-) = inSeriesExposeNode

def inSeriesExposeNode(lf2: (FlangeFun2, Flange), r: FlangeFun2) -> FlangeFun2 = {
  fun f1: Flange -> fun p3: Flange ->
    def (l, f2) = lf2;
    l f1 f2;
    r f2 p3
}
def (-.-) = inSeriesExposeNode

def inSeries(l: FlangeFun2, r: FlangeFun2) -> FlangeFun2 = {
  fun f1: Flange -> fun f3: Flange ->
    def f2: Flange;
    l f1 f2;
    r f2 f3
}
def (--) = inSeries

def serializei(f: (Int -> FlangeFun2), n: Int) -> FlangeFun2 = {
  def work(a: FlangeFun2, i: Int) -> FlangeFun2 = {
    if n - i < 0 then error "n is not a positive number"
    else if n - i == 0 then a
    else work (a -- f (i + 1)) (i + 1)
  };
  work (f 1) 1
}

def serialize(f: FlangeFun2, n: Int) -> FlangeFun2 = {
  serializei (fun i: Int -> f) n
}

type Torque = <Real>
type Angle = <Real>
type AngularVelocity = <Real>

def rotationEdge: Flange -> Flange -> Angle -> Torque -> Model

def getRotationEdges(e: Model) -> ([ScalarPairEdge], Model) = {
  def work(e: Model, a: ([ScalarPairEdge], Model))
    -> ([ScalarPairEdge], Model) = {

    match e with
    | Comp e_1 e_2 -> work e_2 (work e_1 a)
    | rotationEdge n_1 n_2 x y ->
        (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)

  };

  work e ([], NoElement)
}

def TorqueActuator(f: Torque, th: Angle) -> FlangeFun2 = {
  fun f1: Flange -> fun f2: Flange ->
    rotationEdge f1 f2 th f;
}

def TorqueActuator(f: Torque) -> FlangeFun2 = {
  fun f1: Flange -> fun f2: Flange ->
    def th_A: Angle;
    f1 -- TorqueActuator f th_A -- f2
}

def RotationActuator(f: Angle, T: Torque) -> FlangeFun2 = {
  fun f1: Flange -> fun f2: Flange ->
    rotationEdge f1 f2 f T;
}

def RotationActuator(f: Angle) -> FlangeFun2 = {
  fun f1: Flange -> fun f2: Flange ->
    def F_A: Torque;
    f1 -- RotationActuator f F_A -- f2
}

def TorqueActuator(f: Torque) -> FlangeFun2 = {
  fun f1: Flange -> fun f2: Flange ->
    def th_A: Angle;
    f1 -- TorqueActuator f th_A -- f2
}

def TorqueSensor1d(s: Torque) -> FlangeFun2 = {
  fun f1: Flange -> fun f2: Flange ->
    f1 -- RotationActuator 0. s -- f2
}

def AngleSensor(s: Angle) -> FlangeFun2 = {
  fun f1: Flange -> fun f2: Flange ->
    def th_S: Angle;
    f1 -- TorqueActuator 0. th_S -- f2;
    th_S = s
}

def AngularVelocitySensor(w: AngularVelocity) -> FlangeFun2 = {
  fun f1: Flange -> fun f2: Flange ->
    def th_S: Angle;
    f1 -- AngleSensor th_S -- f2;
    th_S' = w
}

def SpringR(k: <Real>, th: Angle, T: Torque) -> FlangeFun2 = {
  fun f1: Flange -> fun f2: Flange ->
    rotationEdge f1 f2 th T;
    T = -k * th
}

def SpringR(k: <Real>) -> FlangeFun2 = {
  fun f1: Flange -> fun f2: Flange ->
    def th_K: Angle;
    def T_K: Torque;
    f1 -- SpringR k th_K T_K -- f2
}

def DamperR(d: <Real>, th: Angle, T: Torque) -> FlangeFun2 = {
  fun f1: Flange -> fun f2: Flange ->
    def w_D: AngularVelocity;
    rotationEdge f1 f2 th T;
    th' = w_D;
    T = -d * w_D
}

def DamperR(d: <Real>) -> FlangeFun2 = {
  fun f1: Flange -> fun f2: Flange ->
    def th_D: Angle;
    def T_D: Torque;
    f1 -- DamperR d th_D T_D -- f2
}

def Inertia(J: <Real>, th: Angle, T: Torque) -> FlangeFun2 = {
  fun f1: Flange -> fun f2: Flange ->
    def w_J: AngularVelocity;
    rotationEdge f1 f2 th T;
    th' = w_J;
    T = -J * w_J'
}

def Inertia(J: <Real>) -> FlangeFun2 = {
  fun f1: Flange -> fun f2: Flange ->
    def th_J: Angle;
    def T_J: Torque;
    f1 -- Inertia J th_J T_J -- f2
}
