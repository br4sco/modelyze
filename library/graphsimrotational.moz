/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include GRAPHSIMCORE

type PointR
type PointRFun1 = PointR -> Model
type PointRFun2 = PointR -> PointR -> Model

def inParallel(l: PointRFun2, r: PointRFun2) -> PointRFun2 = {
  fun p1: PointR -> fun p2: PointR ->
    l p1 p2;
    r p1 p2
}
def (||) = inParallel

def inSeries(l: PointR, r: PointRFun1) -> Model = {
  r l
}
def (--) = inSeries

def inSeries(l: PointRFun1, r: PointR) -> Model = {
  l r
}
def (--) = inSeries

def inSeries(f: PointR, r: PointRFun2) -> PointRFun1 = {
  r f
}
def (--) = inSeries

def inSeries(l: PointRFun1, r: PointRFun2) -> PointRFun1 = {
  fun p2: PointR ->
    def p1: PointR;
    l p1;
    r p1 p2
}
def (--) = inSeries

def inSeriesExposeNode(l: PointRFun2, p2: PointR) -> (PointRFun2, PointR) = {
  (l, p2)
}
def (-.-) = inSeriesExposeNode

def inSeriesExposeNode(lf2: (PointRFun2, PointR), r: PointRFun2) -> PointRFun2 = {
  fun p1: PointR -> fun p3: PointR ->
    def (l, p2) = lf2;
    l p1 p2;
    r p2 p3
}
def (-.-) = inSeriesExposeNode

def inSeries(l: PointRFun2, r: PointRFun2) -> PointRFun2 = {
  fun p1: PointR -> fun p3: PointR ->
    def p2: PointR;
    l p1 p2;
    r p2 p3
}
def (--) = inSeries

def serializei(f: (Int -> PointRFun2), n: Int) -> PointRFun2 = {
  def work(a: PointRFun2, i: Int) -> PointRFun2 = {
    if n - i < 0 then error "n is not a positive number"
    else if n - i == 0 then a
    else work (a -- f (i + 1)) (i + 1)
  };
  work (f 1) 1
}

def serialize(f: PointRFun2, n: Int) -> PointRFun2 = {
  serializei (fun i: Int -> f) n
}

type Torque = <Real>
type Angle = <Real>
type AngularVelocity = <Real>

def rotationEdge: PointR -> PointR -> Angle -> Torque -> Model

def getRotationEdges(e: Model) -> ([ScalarPairEdge], Model) = {
  def work(e: Model, a: ([ScalarPairEdge], Model))
    -> ([ScalarPairEdge], Model) = {

    match e with
    | Comp e_1 e_2 -> work e_2 (work e_1 a)
    | rotationEdge n_1 n_2 x y ->
        (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)

  };

  work e ([], NoElement)
}

def TorqueActuator1d(f: Torque, th: Angle) -> PointRFun2 = {
  fun p1: PointR -> fun p2: PointR ->
    rotationEdge p1 p2 th f;
}

def TorqueActuator1d(f: Torque) -> PointRFun2 = {
  fun p1: PointR -> fun p2: PointR ->
    def th_A: Angle;
    p1 -- TorqueActuator1d f th_A -- p2
}

def RotationActuator1d(f: Angle, T: Torque) -> PointRFun2 = {
  fun p1: PointR -> fun p2: PointR ->
    rotationEdge p1 p2 f T;
}

def RotationActuator1d(f: Angle) -> PointRFun2 = {
  fun p1: PointR -> fun p2: PointR ->
    def F_A: Torque;
    p1 -- RotationActuator1d f F_A -- p2
}

def TorqueActuator1d(f: Torque) -> PointRFun2 = {
  fun p1: PointR -> fun p2: PointR ->
    def th_A: Angle;
    p1 -- TorqueActuator1d f th_A -- p2
}

def TorqueSensor1d(s: Torque) -> PointRFun2 = {
  fun p1: PointR -> fun p2: PointR ->
    p1 -- RotationActuator1d 0. s -- p2
}

def AngleSensor1d(s: Angle) -> PointRFun2 = {
  fun p1: PointR -> fun p2: PointR ->
    def th_S: Angle;
    p1 -- TorqueActuator1d 0. th_S -- p2;
    th_S = s
}

def Spring1d(k: <Real>, th: Angle, T: Torque) -> PointRFun2 = {
  fun p1: PointR -> fun p2: PointR ->
    rotationEdge p1 p2 th T;
    T = -k * th
}

def Spring1d(k: <Real>) -> PointRFun2 = {
  fun p1: PointR -> fun p2: PointR ->
    def th_K: Angle;
    def T_K: Torque;
    p1 -- Spring1d k th_K T_K -- p2
}

def Damper1d(d: <Real>, th: Angle, T: Torque) -> PointRFun2 = {
  fun p1: PointR -> fun p2: PointR ->
    def w_D: AngularVelocity;
    rotationEdge p1 p2 th T;
    th' = w_D;
    T = -d * w_D
}

def Damper1d(d: <Real>) -> PointRFun2 = {
  fun p1: PointR -> fun p2: PointR ->
    def th_D: Angle;
    def T_D: Torque;
    p1 -- Damper1d d th_D T_D -- p2
}

def Inertia1d(J: <Real>, th: Angle, T: Torque) -> PointRFun2 = {
  fun p1: PointR -> fun p2: PointR ->
    def w_J: AngularVelocity;
    rotationEdge p1 p2 th T;
    th' = w_J;
    T = J * w_J'
}

def Inertia1d(J: <Real>) -> PointRFun2 = {
  fun p1: PointR -> fun p2: PointR ->
    def th_J: Angle;
    def T_J: Torque;
    p1 -- Inertia1d J th_J T_J -- p2
}
