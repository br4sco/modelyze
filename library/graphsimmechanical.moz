/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include GRAPHSIMCORE
include MATRIX

def DRIFT_ADJUST_QUATERNIONS = false
def QUATERNION_CORRECTION_CONSTANT = 2.0

def GRAVITATIONAL_CONSTANT = 9.81

type Frame
type FrameFun1 = Frame -> Model
type FrameFun2 = Frame -> Frame -> Model

def inParallel(l: FrameFun2, r: FrameFun2) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    l f1 f2;
    r f1 f2
}
def (||) = inParallel

def inSeries(l: Frame, r: FrameFun1) -> Model = {
  r l
}
def (--) = inSeries

def inSeries(l: FrameFun1, r: Frame) -> Model = {
  l r
}
def (--) = inSeries

def inSeries(f: Frame, r: FrameFun2) -> FrameFun1 = {
  r f
}
def (--) = inSeries

def inSeries(l: FrameFun1, r: FrameFun2) -> FrameFun1 = {
  fun f2: Frame ->
    def f1: Frame;
    l f1;
    r f1 f2
}
def (--) = inSeries

def inSeriesExposeNode(l: FrameFun2, f2: Frame) -> (FrameFun2, Frame) = {
  (l, f2)
}
def (-.-) = inSeriesExposeNode

def inSeriesExposeNode(lf2: (FrameFun2, Frame), r: FrameFun2) -> FrameFun2 = {
  fun f1: Frame -> fun f3: Frame ->
    def (l, f2) = lf2;
    l f1 f2;
    r f2 f3
}
def (-.-) = inSeriesExposeNode

def inSeries(l: FrameFun2, r: FrameFun2) -> FrameFun2 = {
  fun f1: Frame -> fun f3: Frame ->
    def f2: Frame;
    l f1 f2;
    r f2 f3
}
def (--) = inSeries

def serializei(f: (Int -> FrameFun2), n: Int) -> FrameFun2 = {
  def work(a: FrameFun2, i: Int) -> FrameFun2 = {
    if n - i < 0 then error "n is not a positive number"
    else if n - i == 0 then a
    else work (a -- f (i + 1)) (i + 1)
  };
  work (f 1) 1
}

def serialize(f: FrameFun2, n: Int) -> FrameFun2 = {
  serializei (fun i: Int -> f) n
}

def EXPECTED_VECTOR3 = "Expected vector3"
def EXPECTED_QUATERNION = "Expected quaternion"

def ZERO3_R = (0., 0., 0.)
def IDQ_R = (1., 0., 0., 0.)
def XHAT_R = (1., 0., 0.)
def YHAT_R = (0., 1., 0.)
def ZHAT_R = (0., 0., 1.)

type SRMatrix = MatrixMapSReal
type Vector = SRMatrix
type Quaternion = SRMatrix
type Vector3 = Vector
type RealVector3 = (Real, Real, Real)
type RealQuaternion = (Real, Real, Real, Real)

def vec3(x: <Real>, y: <Real>, z: <Real>) -> Vector3 = {
  listToMatrix [[x], [y], [z]] (mmSRealZero (3, 1))
}

def vec3(t: ()) -> Vector3 = {
  def x, y, z: <Real>;
  vec3 x y z
}

def vec3(v: RealVector3) -> Vector3 = {
  def (x, y, z) = v;
  vec3 x y z
}

def vec3T(t: ()) -> Vector3 = {
  def v1_test, v2_test, v3_test: Real;
  vec3 v1_test v2_test v3_test
}

def mkTestT(t: ()) -> Vector3 = {
  def T1_test, T2_test, T3_test: Real;
  vec3 T1_test T2_test T3_test
}

def mkTestOm(t: ()) -> Vector3 = {
  def om1_test, om2_test, om3_test: Real;
  vec3 om1_test om2_test om3_test
}

def quat(w: <Real>, i: <Real>, j: <Real>, k: <Real>) -> Quaternion = {
  listToMatrix [[w], [i], [j], [k]] (mmSRealZero (4, 1))
}

def quat(q: RealQuaternion) -> Quaternion = {
  def (w, i, j, k) = q;
  quat w i j k
}

def quat(t: ()) -> Quaternion = {
  def w, i, j, k: <Real>;
  quat w i j k
}

def quatT(t: ()) -> Quaternion = {
  def q1_test, q2_test, q3_test, q4_test: Real;
  quat q1_test q2_test q3_test q4_test
}

def ID3 = mmSRealId 3
def ZERO1 = mmSRealZero (1, 1)
def ZERO3 = vec3 ZERO3_R
def XHAT = vec3 XHAT_R
def YHAT = vec3 YHAT_R
def ZHAT = vec3 ZHAT_R
def IDQ = quat IDQ_R

def toRealVector3(v: Vector3) -> (<Real>, <Real>, <Real>) = {
  if dim v != (3, 1) then error EXPECTED_VECTOR3
  else (find (1, 1) v, find (2, 1) v, find (3, 1) v)
}

def toRealQauternion(q: Quaternion) -> (<Real>, <Real>, <Real>, <Real>) = {
  if dim q != (4, 1) then error EXPECTED_QUATERNION
  else (find (1, 1) q, find (2, 1) q, find (3, 1) q, find (4, 1) q)
}

def q2ea321(q: Quaternion) -> Vector3 = {
  def (w, i, j, k) = toRealQauternion q;
  vec3 (atan(2. * (w * i + j * k) / (1. - 2. * (i^2. + j^2.))))
       (asin(2. * (w * j - k * i)))
       (atan(2. * (w * k + i * j) / (1. - 2. * (j^2. + k^2.))))
}

def q2M(q: Quaternion) = {
  if dim q != (4, 1) then error EXPECTED_QUATERNION
  else {
    def (q0, q1, q2, q3) = toRealQauternion q;
    listToMatrix [
                  [ q0, -q1, -q2, -q3],
                  [ q1,  q0, -q3,  q2],
                  [ q2,  q3,  q0, -q1],
                  [ q3, -q2,  q1,  q0]
                 ] (mmSRealZero (4, 4))
  }
}

def M2q(M: Quaternion) = {
  if dim M != (4, 4) then error DIMENSION_MISSMATCH
  else {
    def q0 = find (1, 1) M;
    def q1 = find (2, 1) M;
    def q2 = find (3, 1) M;
    def q3 = find (4, 1) M;
    quat q0 q1 q2 q3
  }
}

def qprod(p: Quaternion, q: Quaternion) = { M2q ((q2M p) * (q2M q)) }

def qconj(q: Quaternion) = { M2q (tr (q2M q)) }

def qim(q: Quaternion) = {
  def (w, i, j, k) = toRealQauternion q;
  vec3 i j k
}

def qre(q: Quaternion) = {
  def (w, i, j, k) = toRealQauternion q;
  w
}

def norm2(m: SRMatrix) -> <Real> = {
  def f(a: <Real>, ij: Pos) -> <Real> = {
    a + (find ij m)^2.
  };
  def z: <Real> = 0.;

  foldij f z m
}

def dot(l: Vector, r: Vector) -> <Real> = {
  if dim l != dim r then error DIMENSION_MISSMATCH
  else hd (hd (matrixToList ((tr l) * r)))
}

def normalize(v: Vector) -> Vector = { (1. / sqrt(norm2 v)) *. v }

def vectorFold2(f: (Dyn -> <Real> -> <Real> -> Dyn), a: Dyn,
  v1: Vector, v2: Vector) -> Dyn = {

  if dim v1 != dim v2 || rdim v1 < 1 || cdim v1 > 1 then
    error DIMENSION_MISSMATCH
  else {
    def ff(a: Dyn, ij: Pos) -> Dyn = { f a (find ij v1) (find ij v2) };
    foldij ff a v1
  }
}

def vectorFoldHead2(fa: (Dyn -> Dyn -> Dyn), f: (<Real> -> <Real> -> Dyn),
  v1: Vector, v2: Vector) -> Dyn = {

  if dim v1 != dim v2 || rdim v1 < 1 || cdim v1 > 1 then
    error DIMENSION_MISSMATCH
  else {
    def h = f (find (1, 1) v1) (find (1, 1) v2);
    if dim v2 == (1, 1) then h
    else {
      def lt = sub (2, 1) (dim v1) v1;
      def rt = sub (2, 1) (dim v2) v2;
      def ff(a: Model, ij: Pos) -> Model = {
        fa a (f (find ij lt) (find ij rt))
      };
      foldij ff h lt
    }
  }
}

def eaa2quat(th: Real, u: RealVector3) = {
  def (x, y, z) = u;
  def n = sqrt(x^2. + y^2. + z^2.);
  (cos (th / 2.), (x / n) * sin (th / 2.), (y / n) * sin (th / 2.),
    (z / n) * sin (th / 2.))
}

def quat2eaa(q: Quaternion) -> (<Real>, Vector3) = {
  def (w, i, j, k) = toRealQauternion q;
  def d = sqrt(1. - w * w + EPSILON);
  (2. * acos w, vec3 (i / d) (j / d) (k /d))
}

def vectorEqual(l: Vector, r: Vector) -> Model = {
  def fa(a: Model, e: Model) -> Model = { a; e };
  def f(l: <Real>, r: <Real>) -> Model = { l = r };
  vectorFoldHead2 fa f l r
}
def (=) = vectorEqual

def vectorInitEqual(l: Vector, r: Vector) -> Model = {
  def fa(a: Model, e: Model) -> Model = { a; e };
  def f(l: <Real>, r: <Real>) -> Model = { l ~= r };
  vectorFoldHead2 fa f l r
}
def (~=) = vectorInitEqual

def vectorInit(l: Vector, r: Vector) -> Model = {
  def fa(a: Model, e: Model) -> Model = { a; e };
  def f(l: <Real>, r: <Real>) -> Model = { l <~ r };
  vectorFoldHead2 fa f l r
}
def (<~) = vectorInit

def matrixDer(M: SRMatrix) -> SRMatrix = {
  def f(e: <Real>) -> <Real> = { e' };
  map f M
}
def (') = matrixDer

type Position = Vector
type Velocity = Vector3
type Force = Vector3
type Orientation = Quaternion
type AngularVelocity = Vector3
type Torque = Vector3
type AngleU = <Real>
type AngularVelocityU = <Real>
type TorqueU = <Real>

def mkTestVars(t: ()) = {
  def xm1_test, xm2_test, xm3_test,
    qm1_test, qm2_test, qm3_test, qm4_test: Real;

  def x = vec3 xm1_test xm2_test xm3_test;
  def q = quat qm1_test qm2_test qm3_test qm4_test;
  (x, q)
}

def translationEdge: Frame -> Frame -> Position -> Force -> Model
def rotationalEdge: Frame -> Frame -> Orientation -> Torque -> Model
def angularVelocityEdge: Frame -> Frame -> AngularVelocity -> Torque -> Model
// def initialRotationEdge: Frame -> Frame -> SRMatrix -> Model

type VectorPairEdge = (Edge, (Vector, Vector))
type VectorEdge = (Edge, Vector)

def getTranslationEdges(e: Model) -> ([VectorPairEdge], Model) = {
  def work(e: Model, a: ([VectorPairEdge], Model))
    -> ([VectorPairEdge], Model) = {

    match e with
    | Comp e_1 e_2 -> work e_2 (work e_1 a)
    | translationEdge n_1 n_2 (sval x: Position) (sval y: Force) ->
        (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoElement)
}

def getAngularVelocityEdges(e: Model) -> ([VectorPairEdge], Model) = {
  def work(e: Model, a: ([VectorPairEdge], Model))
    -> ([VectorPairEdge], Model) = {

    match e with
    | Comp e_1 e_2 -> work e_2 (work e_1 a)
    | angularVelocityEdge n_1 n_2 (sval x: AngularVelocity) (sval y: Torque) ->
        (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoElement)
}

def getRotationalEdges(e: Model) -> ([VectorPairEdge], Model) = {
  def work(e: Model, a: ([VectorPairEdge], Model))
    -> ([VectorPairEdge], Model) = {

    match e with
    | Comp e_1 e_2 -> work e_2 (work e_1 a)
    | rotationalEdge n_1 n_2 (sval x: Orientation) (sval y: Torque) ->
        (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoElement)
}

// def getRotationInitEdges(e: Model) -> ([VectorEdge], Model) = {
//   def work(e: Model, a: ([VectorEdge], Model))
//     -> ([VectorEdge], Model) = {
//     match e with
//     | Comp e_1 e_2 -> work e_2 (work e_1 a)
//     | initialRotationEdge n_1 n_2 (sval x: SRMatrix) ->
//         (((n_1, n_2), x)::(fst a), snd a)
//     | _ -> (fst a, (snd a); e)
//   };

//   work e ([], NoElement)
// }

def mkPriScndVarsRelVector3(C: MatrixMapInt, svs: [Vector3], pvs: [Vector3])
  -> [(Vector3, Vector3)] = {

  def uop(c: Int, v: Vector3) -> Vector3 = { - (int2real c) *. v };
  def bop(c: Int, l: Vector3, r: Vector3) -> Vector3 = {
    l - (int2real c) *. r
  };

  mkPriScndVarsRel uop bop ZERO3 C svs pvs
}

def mkPriScndVarsRelQuaternion(C: MatrixMapInt, sqs: [Quaternion],
  pqs: [Quaternion]) -> [(Quaternion, Quaternion)] = {

  def uop(c: Int, q: Quaternion) -> Quaternion = { if c < 0 then q else qconj q };
  def bop(c: Int, l: Quaternion, r: Quaternion) -> Quaternion = { qprod l (uop c r) };
  mkPriScndVarsRel uop bop (IDQ) C sqs pqs
}

def mkVector3TopolEquations(Cvs: (MatrixMapInt, ([Vector3], [Vector3])),
  a: Model) -> Model = {

  def (C, (svs, pvs)) = Cvs;
  def rs = mkPriScndVarsRelVector3 C svs pvs;

  def work(rs: [(Vector3, Vector3)], a: Model) -> Model = {
    match rs with
    | [] -> a
    | r::rs -> work rs (a; fst r = snd r)
    | _ -> error "Unmatched"
  };

  work rs a
}

def mkQuaternionTopolInitEquations(Cvs: (MatrixMapInt,
  ([Quaternion], [Quaternion])), a: Model) -> Model = {

  def (C, (svs, pvs)) = Cvs;
  def rs = mkPriScndVarsRelQuaternion C svs pvs;

  def work(rs: [(Quaternion, Quaternion)], a: Model) -> Model = {
    match rs with
    | [] -> a
    | r::rs -> work rs (a; fst r ~= snd r)
    | _ -> error "Unmatched"
  };

  work rs a
}

def mkE(q: Quaternion) = {
  def (q0, q1, q2, q3) = toRealQauternion q;
  listToMatrix [
                [-q1,  q0, -q3,  q2],
                [-q2,  q3,  q0, -q1],
                [-q3, -q2,  q1,  q0]
               ] (mmSRealZero (3, 4))
}

def mkG(q: Quaternion) = {
  def (q0, q1, q2, q3) = toRealQauternion q;
  listToMatrix [
                [-q1,  q0,  q3, -q2],
                [-q2, -q3,  q0,  q1],
                [-q3,  q2, -q1,  q0]
               ] (mmSRealZero (3, 4))
}

def mkR(q: Orientation) = (mkE q) * (tr (mkG q))
def mkH(q: Orientation) = 0.5 *. (tr (mkE q))

def relateQtoOm(q: Orientation, om: AngularVelocity) = {
  def H = mkH q;
  if DRIFT_ADJUST_QUATERNIONS then
    q' = (H * om) + (QUATERNION_CORRECTION_CONSTANT * (1. - sqrt(norm2 q))) *. q
  else q' = H * om
}

def mkJ(d: RealVector3) = {
  def (Jxx, Jyy, Jzz) = d;
  add (1, 1) Jxx (add (2, 2) Jyy (add (3, 3) Jzz (mmSRealZero (3, 3))))
}

def mkCuboidInertia(m: Real, x: Real, y: Real, z: Real) -> RealVector3 = {
  ((m / 12.) * (y^2. + z^2.), (m / 12.) * (x^2. + z^2.),
    (m / 12.) * (y^2. + x^2.))
}

def mkSphericalInertia(m: Real, r: Real) -> RealVector3 = {
  (m * r^2. / 5., m * r^2. / 5., m * r^2. / 5.)
}

def ForceActuator(f: Vector3, x: Position, f1: Frame, f2: Frame)
  -> Model = {

  translationEdge f1 f2 x f
}

def ForceActuator(f: Vector3, f1: Frame, f2: Frame) -> Model = {
  def xfa1, xfa2, xfa3: Real;
  def x = vec3 xfa1 xfa2 xfa3;
  f1 -- ForceActuator f x -- f2
}

def TranslationActuator(f: Vector3, F: Force, f1: Frame, f2: Frame)
  -> Model = {

  translationEdge f1 f2 f F
}

def TranslationActuator(f: Vector3, f1: Frame, f2: Frame) -> Model = {
  def Fta1, Fta2, Fta3: Real;
  def F = vec3 Fta1 Fta2 Fta3;
  f1 -- TranslationActuator f F -- f2
}

def AngularVelocityActuator(f: Vector3, T: Torque, f1: Frame, f2: Frame)
  -> Model = {

  angularVelocityEdge f1 f2 f T
}

def AngularVelocityActuator(f: Vector3, f1: Frame, f2: Frame) -> Model = {
  def Tra1, Tra2, Tra3: Real;
  def T = vec3 Tra1 Tra2 Tra3;
  f1 -- AngularVelocityActuator f T -- f2
}

def TorqueActuator(f: Vector3, om: AngularVelocity, f1: Frame, f2: Frame)
  -> Model = {

  angularVelocityEdge f1 f2 om f
}

def TorqueActuator(f: Vector3, f1: Frame, f2: Frame) -> Model = {
  def omta1, omta2, omta3: Real;
  def om = vec3 omta1 omta2 omta3;
  f1 -- TorqueActuator f om -- f2
}

def RotationSensor(q: Orientation, f1: Frame, f2: Frame) -> Model = {
  if seq f1 f2 then q = IDQ
  else {
    def oms1, oms2, oms3: Real;
    def om = vec3 oms1 oms2 oms3;
    relateQtoOm q om;
    f1 -- TorqueActuator ZERO3 om -- f2
  }
}

def AngularVelocitySensor(om: AngularVelocity, f1: Frame, f2: Frame) -> Model = {
  TorqueActuator ZERO3 om f1 f2
}

def AngularVelocitySensorU(u: Vector3, omu: AngularVelocityU,
  f1: Frame, f2: Frame) -> Model = {

  def oms1, oms2, oms3: Real;
  def om = vec3 oms1 oms2 oms3;
  def n = normalize u;
  f1 -- AngularVelocitySensor om -- f2;
  omu = dot n om
}

def AngularVelocitySensorU(u: RealVector3, omu: AngularVelocityU,
  f1: Frame, f2: Frame) -> Model = {

  f1 -- AngularVelocitySensorU (vec3 u) omu -- f2
}

def AngularSensorU(u: Vector3, th0: Real, th: AngleU,
  f1: Frame, f2: Frame) -> Model = {

  def omu: AngularVelocityU;
  th' = omu;
  th <- th0;
  f1 -- AngularVelocitySensorU u omu -- f2
}

def AngularSensorU(u: RealVector3, th0: Real, th: AngleU,
  f1: Frame, f2: Frame) -> Model = {

  def omu: AngularVelocityU;
  th' = omu;
  th <- th0;
  f1 -- AngularVelocitySensorU u omu -- f2
}

def TorqueSensor(T: Torque) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    AngularVelocityActuator ZERO3 T f1 f2
}

def TranslationSensor(x: Position, f1: Frame, f2: Frame) -> Model = {
  if seq f1 f2 then x = ZERO3
  else ForceActuator ZERO3 x f1 f2
}

def BodyT(m: Real, v: Velocity, x: Position, F: Force,
  world: Frame, fm: Frame) -> Model = {

  translationEdge world fm x F;
  x' = v;
  F = m *. v';
}

def BodyT(world: Frame, m: Real, v: Velocity, x: Position, F: Force,
  fm: Frame) -> Model = {

  world -- BodyT m v x F -- fm
}

def BodyT(m: Real, x: Position, world: Frame, fm: Frame) -> Model = {
  def vm1, vm2, vm3, Fm1, Fm2, Fm3: Real;
  def v = vec3 vm1 vm2 vm3;
  def F = vec3 Fm1 Fm2 Fm3;
  world -- BodyT m v x F -- fm
}

def BodyT(fm: Frame, m: Real, x: Position, world: Frame) -> Model = {
  world -- BodyT m x -- fm
}

def BodyR(Jd: RealVector3, om: AngularVelocity, q: Orientation, T: Orientation,
  world: Frame, fm: Frame) -> Model = {

  def R = mkR q;
  def J = mkJ Jd;
  def Jw = R * J * (tr R);
  angularVelocityEdge world fm om T;
  relateQtoOm q om;
  T = Jw * om' + (ss om) * Jw * om
}

def BodyR(Jd: RealVector3, q: Orientation, world: Frame, fm: Frame)
  -> Model = {

  def omm1, omm2, omm3, Tm1, Tm2, Tm3: Real;
  def om = vec3 omm1 omm2 omm3;
  def T = vec3 Tm1 Tm2 Tm3;
  world -- BodyR Jd om q T -- fm
}

def RigidArm1T(r: RealVector3, F: Force, q2: Orientation, fm: Frame, fe: Frame)
  -> Model = {

  TranslationActuator ((mkR q2) * (vec3 r)) F fm fe
}

def RigidArm1R(T: Torque, fm: Frame, fe: Frame) -> Model = {
  AngularVelocityActuator ZERO3 T fm fe
}

def RigidArm1R(fm: Frame, fe: Frame) -> Model = {
  def Tr11, Tr12, Tr13: Real;
  def T = vec3 Tr11 Tr12 Tr13;
  fm -- RigidArm1R T -- fe
}

def RigidArm2R(r: RealVector3, F1: Force, om: AngularVelocity, q: Orientation,
  T: Torque, world: Frame, fm: Frame) -> Model = {

  angularVelocityEdge world fm om T;
  relateQtoOm q om;
  T = -(ss ((mkR q) * (vec3 r))) * F1
}

def RigidArm2R(r: RealVector3, F1: Force, q: Orientation,
  world: Frame, fm: Frame) -> Model = {

  def omr21, omr22, omr23, Tr21, Tr22, Tr23: Real;
  def om = vec3 omr21 omr22 omr23;
  def T = vec3 Tr21 Tr22 Tr23;
  world -- RigidArm2R r F1 om q T -- fm
}

def Gravity(m: Real, world: Frame, fm: Frame) -> Model = {
  ForceActuator ((m * GRAVITATIONAL_CONSTANT) *. ZHAT) world fm
}

def Gravity(world: Frame, m: Real, fm: Frame) -> Model = {
  world -- Gravity m -- fm
}

def SphericalJoint(f1: Frame, f2: Frame) -> Model = {
  TranslationActuator ZERO3 f1 f2
}

def RevoluteJointR(u: Vector3, om: AngularVelocity, T: Torque,
  f1: Frame, f2: Frame) -> Model = {

  def omu: AngularVelocityU;
  def n = normalize u;
  angularVelocityEdge f1 f2 om T;
  dot n T = 0.;
  om = omu *. n
}

def RevoluteJointR(u: Vector3, f1: Frame, f2: Frame) -> Model = {
  def omhr1, omhr2, omhr3, Thr1, Thr2, Thr3: Real;
  def om = vec3 omhr1 omhr2 omhr3;
  def T = vec3 Thr1 Thr2 Thr3;
  f1 -- RevoluteJointR u om T -- f2
}

def RevoluteJoint(u: RealVector3, q: Orientation, world: Frame,
  f1: Frame, f2: Frame) -> Model = {

  def R = mkR q;
  world -- RotationSensor q -- f1;
  f1 -- RevoluteJointR (R * (vec3 u)) -- f2
}

def RotationDamper(d: Real, f1: Frame, f2: Frame) -> Model = {
  def omd1, omd2, omd3, Td1, Td2, Td3: Real;
  def om = vec3 omd1 omd2 omd3;
  def T = vec3 Td1 Td2 Td3;
  angularVelocityEdge f1 f2 om T;
  T = d *. om
}

def Body(m: Real, Jd: RealVector3, x: Position, q: Orientation,
  world: Frame, fm: Frame) -> Model = {

  BodyT m x world fm;
  BodyR Jd q world fm
}

def RigidArm(r: RealVector3, q: Orientation, world: Frame,
  fe: Frame, fm: Frame) -> Model = {

  def Fr11, Fr12, Fr13: Real;
  def Fr1 = vec3 Fr11 Fr12 Fr13;
  fm -- RigidArm1T r Fr1 q -- fe;
  fm -- RigidArm1R -- fe;
  world -- RigidArm2R r Fr1 q -- fm
}

def RigidArm(world: Frame, r: RealVector3, q: Orientation,
  fe: Frame, fm: Frame) -> Model = {

  fe -- RigidArm r q world -- fm
}

def _mkRigidArmVar(t: ()) = {
  def qra1, qra2, qra3, qra4: Real;
  def q = quat qra1 qra2 qra3 qra4;
  q
}

def RigidArm(world: Frame, r: RealVector3, q0: RealQuaternion) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    def q = _mkRigidArmVar ();
    f1 -- RigidArm world r q -- f2;
    q <~ quat q0; norm2 q ~= 1.
}

def RigidArm(world: Frame, r: RealVector3) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    def q = _mkRigidArmVar ();
    f1 -- RigidArm world r q -- f2;
    norm2 q ~= 1.
}

def TranslationalSpring(k: Real, s: Real, x: Position, F: Force,
  f1: Frame, f2: Frame) -> Model = {

  translationEdge f1 f2 x F;
  F = (k * (1. - (s / (sqrt(norm2 x) + EPSILON)))) *. x;
}

def TranslationalSpring(k: Real, s: Real, f1: Frame, f2: Frame) -> Model = {
  def xk1, xk2, xk3, Fk1, Fk2, Fk3: Real;
  def x = vec3 xk1 xk2 xk3;
  def F = vec3 Fk1 Fk2 Fk3;
  f1 -- TranslationalSpring k s x F -- f2
}

def TranslationalDamper(d: Real, v: Velocity, x: Position, F: Force,
  f1: Frame, f2: Frame) -> Model = {

  translationEdge f1 f2 x F;
  x' = v;
  F = (d / ((norm2 x) + EPSILON) * (dot x v))  *. x
}

def TranslationalDamper(d: Real, f1: Frame, f2: Frame) -> Model = {
  def vd1, vd2, vd3, xd1, xd2, xd3, Fd1, Fd2, Fd3: Real;
  def v = vec3 vd1 vd2 vd3;
  def x = vec3 xd1 xd2 xd3;
  def F = vec3 Fd1 Fd2 Fd3;
  f1 -- TranslationalDamper d v x F -- f2
}

def RotationalSpring(k: Real, n: Vector3, om: AngularVelocity, T: Torque,
  f1: Frame, f2: Frame) -> Model = {

  def th: Real;
  angularVelocityEdge f1 f2 om T;
  th' = dot n om;
  th <- 0.;
  T = (k * th) *. n
}

def RotationalSpring(k: Real, u: RealVector3, q: Orientation,
  om: AngularVelocity, T: Torque, world: Frame, f1: Frame, f2: Frame)
  -> Model = {

  def R = mkR q;
  def n = normalize (vec3 u);
  world -- RotationSensor q -- f1;
  f1 -- RotationalSpring k (R * n) om T -- f2
}

def RotationalSpring(k: Real, u: RealVector3, q: Orientation,
  world: Frame, f1: Frame, f2: Frame) -> Model = {

  def omk1, omk2, omk3, Tk1, Tk2, Tk3: Real;
  def om = vec3 omk1 omk2 omk3;
  def T = vec3 Tk1 Tk2 Tk3;
  f1 -- RotationalSpring k u q om T world -- f2
}

def RotationalSpringEAA(k: Real, q: Orientation, om: AngularVelocity, T: Torque,
  world: Frame, f1: Frame, f2: Frame) -> Model = {

  def (th, n) = quat2eaa q;
  angularVelocityEdge f1 f2 om T;
  world -- RotationSensor q -- f2;
  T = (k * th) *. n
}

def RotationalSpringEAA(k: Real, q: Orientation, world: Frame,
  f1: Frame, f2: Frame) -> Model = {

  def omk1, omk2, omk3, Tk1, Tk2, Tk3: Real;
  def om = vec3 omk1 omk2 omk3;
  def T = vec3 Tk1 Tk2 Tk3;
  f1 -- RotationalSpringEAA k q world -- f2
}

def RotationalSpring(world: Frame, k: Real, u: RealVector3,
  q0: RealQuaternion) -> FrameFun2 = {

  fun f1: Frame -> fun f2: Frame ->
    def q = quat ();
    f1 -- RotationalSpring k u q world -- f2;
    norm2 q ~= 1.;
    q <~ quat q0
}
