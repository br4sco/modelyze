/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include GRAPHSIMCORE

def EXPECTED_VECTOR3 = "Expected vector3"
def EXPECTED_QUATERNION = "Expected quaternion"

def DRIFT_ADJUST_QUATERNIONS = false
def QUATERNION_CORRECTION_CONSTANT = 2.0

def GRAVITATIONAL_CONSTANT = 9.81

def ZERO3_R = (0., 0., 0.)
def IDQ_R = (1., 0., 0., 0.)
def XHAT_R = (1., 0., 0.)
def YHAT_R = (0., 1., 0.)
def ZHAT_R = (0., 0., 1.)

type Frame = Node
type FrameFun1 = Frame -> Model
type FrameFun2 = Frame -> Frame -> Model

type SRMatrix = MatrixMapSReal
type RealVector3 = (Real, Real, Real)
type RealQuaternion = (Real, Real, Real, Real)

def vec3(x: <Real>, y: <Real>, z: <Real>) -> SRMatrix = {
  listToMatrix [[x], [y], [z]] (mmSRealZero (3, 1))
}

def vec3(t: ()) -> SRMatrix = {
  def x, y, z: <Real>;
  vec3 x y z
}

def vec3(v: RealVector3) -> SRMatrix = {
  def (x, y, z) = v;
  vec3 x y z
}

def vec3T(t: ()) -> SRMatrix = {
  def v1_test, v2_test, v3_test: Real;
  vec3 v1_test v2_test v3_test
}

def quat(w: <Real>, i: <Real>, j: <Real>, k: <Real>) -> SRMatrix = {
  listToMatrix [[w], [i], [j], [k]] (mmSRealZero (4, 1))
}

def quat(q: RealQuaternion) -> SRMatrix = {
  def (w, i, j, k) = q;
  quat w i j k
}

def quat(t: ()) -> SRMatrix = {
  def w, i, j, k: <Real>;
  quat w i j k
}

def quatT(t: ()) -> SRMatrix = {
  def q1_test, q2_test, q3_test, q4_test: Real;
  quat q1_test q2_test q3_test q4_test
}

def ID3 = mmSRealId 3
def ZERO1 = mmSRealZero (1, 1)
def ZERO3 = vec3 ZERO3_R
def XHAT = vec3 XHAT_R
def YHAT = vec3 YHAT_R
def ZHAT = vec3 ZHAT_R
def IDQ = quat IDQ_R

def mkTestVars(t: ()) = {
  def xm1_test, xm2_test, xm3_test,
    qm1_test, qm2_test, qm3_test, qm4_test: Real;

  def x = vec3 xm1_test xm2_test xm3_test;
  def q = quat qm1_test qm2_test qm3_test qm4_test;
  (x, q)
}

def toRealVector3(v: SRMatrix) -> (<Real>, <Real>, <Real>) = {
  if dim v != (3, 1) then error EXPECTED_VECTOR3
  else (find (1, 1) v, find (2, 1) v, find (3, 1) v)
}

def toRealQauternion(q: SRMatrix) -> (<Real>, <Real>, <Real>, <Real>) = {
  if dim q != (4, 1) then error EXPECTED_QUATERNION
  else (find (1, 1) q, find (2, 1) q, find (3, 1) q, find (4, 1) q)
}

def q2ea321(q: SRMatrix) -> SRMatrix = {
  def (w, i, j, k) = toRealQauternion q;
  vec3 (atan(2. * (w * i + j * k) / (1. - 2. * (i^2. + j^2.))))
            (asin(2. * (w * j - k * i)))
            (atan(2. * (w * k + i * j) / (1. - 2. * (j^2. + k^2.))))
}

def q2M(q: SRMatrix) = {
  if dim q != (4, 1) then error EXPECTED_QUATERNION
  else {
    def (q0, q1, q2, q3) = toRealQauternion q;
    listToMatrix [
                  [ q0, -q1, -q2, -q3],
                  [ q1,  q0, -q3,  q2],
                  [ q2,  q3,  q0, -q1],
                  [ q3, -q2,  q1,  q0]
                 ] (mmSRealZero (4, 4))
  }
}

def M2q(M: SRMatrix) = {
  if dim M != (4, 4) then error DIMENSION_MISSMATCH
  else {
    def q0 = find (1, 1) M;
    def q1 = find (2, 1) M;
    def q2 = find (3, 1) M;
    def q3 = find (4, 1) M;
    quat q0 q1 q2 q3
  }
}

def qprod(p: SRMatrix, q: SRMatrix) = { M2q ((q2M p) * (q2M q)) }

def qconj(q: SRMatrix) = { M2q (tr (q2M q)) }

def qim(q: SRMatrix) = {
  def (w, i, j, k) = toRealQauternion q;
  vec3 i j k
}

def qre(q: SRMatrix) = {
  def (w, i, j, k) = toRealQauternion q;
  w
}

def norm2(v: SRMatrix) -> <Real> = {
  def f(a: <Real>, ij: Pos) -> <Real> = {
    a + (find ij v)^2.
  };
  def z: <Real> = 0.;

  if cdim v != 1 && rdim v <= 0 then error DIMENSION_MISSMATCH
  else {
    foldij f z v
  }
}

def dot(l: SRMatrix, r: SRMatrix) -> <Real> = {
  if dim l != dim r then error DIMENSION_MISSMATCH
  else hd (hd (matrixToList ((tr l) * r)))
}

def normalize(v: SRMatrix) -> SRMatrix = { (1. / sqrt(norm2 v)) *. v }

def mkOrthogonalBasis(u: RealVector3) -> (SRMatrix, SRMatrix, SRMatrix) = {
  def findNonParallelVector(v: SRMatrix) = {
    def (sval x: Real, sval y: Real, sval z: Real) = toRealVector3 v;
    if x == 0. then vec3 1. y z
    else if y == 0. then vec3 x 1. z
    else if z == 0. then vec3 x y 1.
    else vec3 x (2. * y) (3. * z)
  };

  def u1 = vec3 u;
  def v = findNonParallelVector u1;
  def u2 = ss u1 * v;
  def u3 = ss u1 * u2;
  (u1, u2, u3)
}

def eaa2quat(th: Real, u: RealVector3) = {
  def (x, y, z) = u;
  def n = sqrt(x^2. + y^2. + z^2.);
  (cos (th / 2.), (x / n) * sin (th / 2.), (y / n) * sin (th / 2.),
    (z / n) * sin (th / 2.))
}

def quat2eaa(q: SRMatrix) -> (<Real>, SRMatrix) = {
  def (w, i, j, k) = toRealQauternion q;
  def d = sqrt(1. - w * w + EPSILON);
  (2. * acos w, vec3 (i / d) (j / d) (k /d))
}

def vectorFold2(f: (Dyn -> <Real> -> <Real> -> Dyn), a: Dyn,
  v1: SRMatrix, v2: SRMatrix) -> Dyn = {

  if dim v1 != dim v2 || rdim v1 < 1 || cdim v1 > 1 then
    error DIMENSION_MISSMATCH
  else {
    def ff(a: Dyn, ij: Pos) -> Dyn = { f a (find ij v1) (find ij v2) };
    foldij ff a v1
  }
}

def vectorFoldHead2(fa: (Dyn -> Dyn -> Dyn), f: (<Real> -> <Real> -> Dyn),
  v1: SRMatrix, v2: SRMatrix) -> Dyn = {

  if dim v1 != dim v2 || rdim v1 < 1 || cdim v1 > 1 then
    error DIMENSION_MISSMATCH
  else {
    def h = f (find (1, 1) v1) (find (1, 1) v2);
    if dim v2 == (1, 1) then h
    else {
      def lt = sub (2, 1) (dim v1) v1;
      def rt = sub (2, 1) (dim v2) v2;
      def ff(a: Model, ij: Pos) -> Model = {
        fa a (f (find ij lt) (find ij rt))
      };
      foldij ff h lt
    }
  }
}

def vectorEqual(l: SRMatrix, r: SRMatrix) -> Model = {
  def fa(a: Model, e: Model) -> Model = { a; e };
  def f(l: <Real>, r: <Real>) -> Model = { l = r };
  vectorFoldHead2 fa f l r
}
def (==) = vectorEqual

def vectorInitEqual(l: SRMatrix, r: SRMatrix) -> Model = {
  def fa(a: Model, e: Model) -> Model = { a; e };
  def f(l: <Real>, r: <Real>) -> Model = { l ~= r };
  vectorFoldHead2 fa f l r
}
def (~==) = vectorInitEqual

def vectorInit(l: SRMatrix, r: SRMatrix) -> Model = {
  def fa(a: Model, e: Model) -> Model = { a; e };
  def f(l: <Real>, r: <Real>) -> Model = { l <~ r };
  vectorFoldHead2 fa f l r
}
def (<~~) = vectorInit

def matrixDer(M: SRMatrix) -> SRMatrix = {
  def f(e: <Real>) -> <Real> = { e' };
  map f M
}
def (') = matrixDer

// def eaa2quat(th: <Real>, n: SRMatrix) = {
//   def (n1, n2, n3) = toRealVector3 n;
//   quat (cos(th / 2.)) (sin(th / 2.) * n1) (sin(th /2.) * n2) (sin(th /2.) * n3)
// }

def translationEdge: Frame -> Frame -> SRMatrix -> SRMatrix -> Model
def rotationalEdge: Frame -> Frame -> SRMatrix -> SRMatrix -> Model
def angularVelocityEdge: Frame -> Frame -> SRMatrix -> SRMatrix -> Model
// def initialRotationEdge: Frame -> Frame -> SRMatrix -> Model

type VectorPairEdge = (Edge, (SRMatrix, SRMatrix))
type VectorEdge = (Edge, SRMatrix)

def getTranslationEdges(e: Model) -> ([VectorPairEdge], Model) = {
  def work(e: Model, a: ([VectorPairEdge], Model))
    -> ([VectorPairEdge], Model) = {

    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | translationEdge n_1 n_2 (sval x: SRMatrix) (sval y: SRMatrix) ->
        (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoElement)
}

def getAngularVelocityEdges(e: Model) -> ([VectorPairEdge], Model) = {
  def work(e: Model, a: ([VectorPairEdge], Model))
    -> ([VectorPairEdge], Model) = {

    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | angularVelocityEdge n_1 n_2 (sval x: SRMatrix) (sval y: SRMatrix) ->
        (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoElement)
}

def getRotationalEdges(e: Model) -> ([VectorPairEdge], Model) = {
  def work(e: Model, a: ([VectorPairEdge], Model))
    -> ([VectorPairEdge], Model) = {

    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | rotationalEdge n_1 n_2 (sval x: SRMatrix) (sval y: SRMatrix) ->
        (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoElement)
}

// def getRotationInitEdges(e: Model) -> ([VectorEdge], Model) = {
//   def work(e: Model, a: ([VectorEdge], Model))
//     -> ([VectorEdge], Model) = {
//     match e with
//     | e_1; e_2 -> work e_2 (work e_1 a)
//     | initialRotationEdge n_1 n_2 (sval x: SRMatrix) ->
//         (((n_1, n_2), x)::(fst a), snd a)
//     | _ -> (fst a, (snd a); e)
//   };

//   work e ([], NoElement)
// }

def mkPriScndVarsRelVector3(C: MatrixMapInt, svs: [SRMatrix], pvs: [SRMatrix])
  -> [(SRMatrix, SRMatrix)] = {

  def uop(c: Int, v: SRMatrix) -> SRMatrix = { - (int2real c) *. v };
  def bop(c: Int, l: SRMatrix, r: SRMatrix) -> SRMatrix = {
    l - (int2real c) *. r
  };

  mkPriScndVarsRel uop bop ZERO3 C svs pvs
}

def mkPriScndVarsRelQuaternion(C: MatrixMapInt, sqs: [SRMatrix],
  pqs: [SRMatrix]) -> [(SRMatrix, SRMatrix)] = {

  def uop(c: Int, q: SRMatrix) -> SRMatrix = { if c < 0 then q else qconj q };
  def bop(c: Int, l: SRMatrix, r: SRMatrix) -> SRMatrix = { qprod l (uop c r) };
  mkPriScndVarsRel uop bop (IDQ) C sqs pqs
}

def mkVector3TopolEquations(Cvs: (MatrixMapInt, ([SRMatrix], [SRMatrix])),
  a: Model) -> Model = {

  def (C, (svs, pvs)) = Cvs;
  def rs = mkPriScndVarsRelVector3 C svs pvs;

  def work(rs: [(SRMatrix, SRMatrix)], a: Model) -> Model = {
    match rs with
    | [] -> a
    | r::rs -> work rs (a; fst r == snd r)
    | _ -> error "Unmatched"
  };

  work rs a
}

def mkQuaternionTopolInitEquations(Cvs: (MatrixMapInt,
  ([SRMatrix], [SRMatrix])), a: Model) -> Model = {

  def (C, (svs, pvs)) = Cvs;
  def rs = mkPriScndVarsRelQuaternion C svs pvs;

  def work(rs: [(SRMatrix, SRMatrix)], a: Model) -> Model = {
    match rs with
    | [] -> a
    | r::rs -> work rs (a; fst r ~== snd r)
    | _ -> error "Unmatched"
  };

  work rs a
}

def mkE(q: SRMatrix) = {
  def (q0, q1, q2, q3) = toRealQauternion q;
  listToMatrix [
                [-q1,  q0, -q3,  q2],
                [-q2,  q3,  q0, -q1],
                [-q3, -q2,  q1,  q0]
               ] (mmSRealZero (3, 4))
}

def mkG(q: SRMatrix) = {
  def (q0, q1, q2, q3) = toRealQauternion q;
  listToMatrix [
                [-q1,  q0,  q3, -q2],
                [-q2, -q3,  q0,  q1],
                [-q3,  q2, -q1,  q0]
               ] (mmSRealZero (3, 4))
}

def mkR(q: SRMatrix) = (mkE q) * (tr (mkG q))
def mkH(q: SRMatrix) = 0.5 *. (tr (mkE q))

def relateQtoOm(q: SRMatrix, om: SRMatrix) = {
  def H = mkH q;
  if DRIFT_ADJUST_QUATERNIONS then
    q' == (H * om) + (QUATERNION_CORRECTION_CONSTANT * (1. - sqrt(norm2 q))) *. q
  else q' == H * om
}

def mkJ(d: RealVector3) = {
  def (Jxx, Jyy, Jzz) = d;
  add (1, 1) Jxx (add (2, 2) Jyy (add (3, 3) Jzz (mmSRealZero (3, 3))))
}

def mkCuboidInertia(m: Real, x: Real, y: Real, z: Real) -> RealVector3 = {
  ((m / 12.) * (y^2. + z^2.), (m / 12.) * (x^2. + z^2.),
    (m / 12.) * (y^2. + x^2.))
}

def mkSphericalInertia(m: Real, r: Real) -> RealVector3 = {
  (m * r^2. / 5., m * r^2. / 5., m * r^2. / 5.)
}

def ForceActuator(f: SRMatrix, x: SRMatrix, f1: Frame, f2: Frame)
  -> Model = {

  translationEdge f1 f2 x f
}

def ForceActuator(f: SRMatrix, f1: Frame, f2: Frame) -> Model = {
  def xfa1, xfa2, xfa3: Real;
  def x = vec3 xfa1 xfa2 xfa3;
  f1 -- ForceActuator f x -- f2
}

def TranslationActuator(f: SRMatrix, F: SRMatrix, f1: Frame, f2: Frame)
  -> Model = {

  translationEdge f1 f2 f F
}

def TranslationActuator(f: SRMatrix, f1: Frame, f2: Frame) -> Model = {
  def Fta1, Fta2, Fta3: Real;
  def F = vec3 Fta1 Fta2 Fta3;
  f1 -- TranslationActuator f F -- f2
}

def AngularVelocityActuator(f: SRMatrix, T: SRMatrix, f1: Frame, f2: Frame)
  -> Model = {

  angularVelocityEdge f1 f2 f T
}

def AngularVelocityActuator(f: SRMatrix, f1: Frame, f2: Frame) -> Model = {
  def Tra1, Tra2, Tra3: Real;
  def T = vec3 Tra1 Tra2 Tra3;
  f1 -- AngularVelocityActuator f T -- f2
}

def TorqueActuator(f: SRMatrix, om: SRMatrix, f1: Frame, f2: Frame)
  -> Model = {

  angularVelocityEdge f1 f2 om f
}

def TorqueActuator(f: SRMatrix, f1: Frame, f2: Frame) -> Model = {
  def omta1, omta2, omta3: Real;
  def om = vec3 omta1 omta2 omta3;
  f1 -- TorqueActuator f om -- f2
}

def RotationSensor(q: SRMatrix, f1: Frame, f2: Frame) -> Model = {
  if seq f1 f2 then q == IDQ
  else {
    def oms1, oms2, oms3: Real;
    def om = vec3 oms1 oms2 oms3;
    relateQtoOm q om;
    f1 -- TorqueActuator ZERO3 om -- f2
  }
}

def AngularVelocitySensor(om: SRMatrix, f1: Frame, f2: Frame) -> Model = {
  TorqueActuator ZERO3 om f1 f2
}

def TranslationSensor(x: SRMatrix, f1: Frame, f2: Frame) -> Model = {
  if seq f1 f2 then x == ZERO3
  else ForceActuator ZERO3 x f1 f2
}

def BodyT(m: Real, v: SRMatrix, x: SRMatrix, F: SRMatrix,
  world: Frame, fm: Frame) -> Model = {

  translationEdge world fm x F;
  x' == v;
  F == m *. v';
}

def BodyT(world: Frame, m: Real, v: SRMatrix, x: SRMatrix, F: SRMatrix,
  fm: Frame) -> Model = {

  world -- BodyT m v x F -- fm
}

def BodyT(m: Real, x: SRMatrix, world: Frame, fm: Frame) -> Model = {
  def vm1, vm2, vm3, Fm1, Fm2, Fm3: Real;
  def v = vec3 vm1 vm2 vm3;
  def F = vec3 Fm1 Fm2 Fm3;
  world -- BodyT m v x F -- fm
}

def BodyT(fm: Frame, m: Real, x: SRMatrix, world: Frame) -> Model = {
  world -- BodyT m x -- fm
}

def BodyR(Jd: RealVector3, om: SRMatrix, q: SRMatrix, T: SRMatrix,
  world: Frame, fm: Frame) -> Model = {

  def R = mkR q;
  def J = mkJ Jd;
  def Jw = R * J * (tr R);
  angularVelocityEdge world fm om T;
  relateQtoOm q om;
  T == Jw * om' + (ss om) * Jw * om
}

def BodyR(Jd: RealVector3, q: SRMatrix, world: Frame, fm: Frame)
  -> Model = {

  def omm1, omm2, omm3, Tm1, Tm2, Tm3: Real;
  def om = vec3 omm1 omm2 omm3;
  def T = vec3 Tm1 Tm2 Tm3;
  world -- BodyR Jd om q T -- fm
}

def RigidArm1T(r: RealVector3, F: SRMatrix, q2: SRMatrix, fm: Frame, fe: Frame)
  -> Model = {

  TranslationActuator ((mkR q2) * (vec3 r)) F fm fe
}

def RigidArm1R(T: SRMatrix, fm: Frame, fe: Frame) -> Model = {
  AngularVelocityActuator ZERO3 T fm fe
}

def RigidArm1R(fm: Frame, fe: Frame) -> Model = {
  def Tr11, Tr12, Tr13: Real;
  def T = vec3 Tr11 Tr12 Tr13;
  fm -- RigidArm1R T -- fe
}

def RigidArm2R(r: RealVector3, F1: SRMatrix, om: SRMatrix, q: SRMatrix,
  T: SRMatrix, world: Frame, fm: Frame) -> Model = {

  angularVelocityEdge world fm om T;
  relateQtoOm q om;
  T == -(ss ((mkR q) * (vec3 r))) * F1
}

def RigidArm2R(r: RealVector3, F1: SRMatrix, q: SRMatrix,
  world: Frame, fm: Frame) -> Model = {

  def omr21, omr22, omr23, Tr21, Tr22, Tr23: Real;
  def om = vec3 omr21 omr22 omr23;
  def T = vec3 Tr21 Tr22 Tr23;
  world -- RigidArm2R r F1 om q T -- fm
}

def Gravity(m: Real, world: Frame, fm: Frame) -> Model = {
  ForceActuator ((m * GRAVITATIONAL_CONSTANT) *. ZHAT) world fm
}

def Gravity(world: Frame, m: Real, fm: Frame) -> Model = {
  world -- Gravity m -- fm
}

def SphericalJoint(f1: Frame, f2: Frame) -> Model = {
  TranslationActuator ZERO3 f1 f2
}

def RevoluteJointR(u1: SRMatrix, u2: SRMatrix, u3: SRMatrix, om: SRMatrix,
  T: SRMatrix, f1: Frame, f2: Frame) -> Model = {

  angularVelocityEdge f1 f2 om T;
  (tr u1) * T == ZERO1;
  (tr u2) * om == ZERO1;
  (tr u3) * om == ZERO1
}

def RevoluteJointR(u1: SRMatrix, u2: SRMatrix, u3: SRMatrix,
  f1: Frame, f2: Frame) -> Model = {

  def omhr1, omhr2, omhr3, Thr1, Thr2, Thr3: Real;
  def om = vec3 omhr1 omhr2 omhr3;
  def T = vec3 Thr1 Thr2 Thr3;
  f1 -- RevoluteJointR u1 u2 u3 om T -- f2
}

def RevoluteJoint(u: RealVector3, q: SRMatrix, world: Frame,
  f1: Frame, f2: Frame) -> Model = {

  def (u1, u2, u3) = mkOrthogonalBasis u;
  def R = mkR q;
  world -- RotationSensor q -- f1;
  f1 -- RevoluteJointR (R * u1) (R * u2) (R * u3) -- f2
}

def RotationDamper(d: Real, f1: Frame, f2: Frame) -> Model = {
  def omd1, omd2, omd3, Td1, Td2, Td3: Real;
  def om = vec3 omd1 omd2 omd3;
  def T = vec3 Td1 Td2 Td3;
  angularVelocityEdge f1 f2 om T;
  T == d *. om
}

def Body(m: Real, Jd: RealVector3, x: SRMatrix, q: SRMatrix,
  world: Frame, fm: Frame) -> Model = {

  BodyT m x world fm;
  BodyR Jd q world fm
}

def RigidArm(r: RealVector3, q: SRMatrix, world: Frame,
  fe: Frame, fm: Frame) -> Model = {

  def Fr11, Fr12, Fr13: Real;
  def Fr1 = vec3 Fr11 Fr12 Fr13;
  fm -- RigidArm1T r Fr1 q -- fe;
  fm -- RigidArm1R -- fe;
  world -- RigidArm2R r Fr1 q -- fm
}

def RigidArm(world: Frame, r: RealVector3, q: SRMatrix,
  fe: Frame, fm: Frame) -> Model = {

  fe -- RigidArm r q world -- fm
}

def _mkRigidArmVar(t: ()) = {
  def qra1, qra2, qra3, qra4: Real;
  def q = quat qra1 qra2 qra3 qra4;
  q
}

def RigidArm(world: Frame, r: RealVector3, q0: RealQuaternion) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    def q = _mkRigidArmVar ();
    f1 -- RigidArm world r q -- f2;
    q <~~ quat q0; norm2 q ~= 1.
}

def RigidArm(world: Frame, r: RealVector3) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    def q = _mkRigidArmVar ();
    f1 -- RigidArm world r q -- f2;
    norm2 q ~= 1.
}

def AngularVelocitySensorU(u: SRMatrix, omu: <Real>,
  f1: Frame, f2: Frame) -> Model = {

  def oms1, oms2, oms3: Real;
  def om = vec3 oms1 oms2 oms3;
  def n = normalize u;
  f1 -- AngularVelocitySensor om -- f2;
  omu = dot n om
}

def AngularVelocitySensorU(u: RealVector3, omu: <Real>,
  f1: Frame, f2: Frame) -> Model = {

  f1 -- AngularVelocitySensorU (vec3 u) omu -- f2
}

def AngularSensorU(u: SRMatrix, th0: Real, th: <Real>,
  f1: Frame, f2: Frame) -> Model = {

  def omu: Real;
  th' = omu;
  th <- th0;
  f1 -- AngularVelocitySensorU u omu -- f2
}

def AngularSensorU(u: RealVector3, th0: Real, th: <Real>,
  f1: Frame, f2: Frame) -> Model = {

  def omu: Real;
  th' = omu;
  th <- th0;
  f1 -- AngularVelocitySensorU u omu -- f2
}

def TranslationalSpring(k: Real, s: Real, x: SRMatrix, F: SRMatrix,
  f1: Frame, f2: Frame) -> Model = {

  translationEdge f1 f2 x F;
  F == (k * (1. - (s / (sqrt(norm2 x) + EPSILON)))) *. x;
}

def TranslationalSpring(k: Real, s: Real, f1: Frame, f2: Frame) -> Model = {
  def xk1, xk2, xk3, Fk1, Fk2, Fk3: Real;
  def x = vec3 xk1 xk2 xk3;
  def F = vec3 Fk1 Fk2 Fk3;
  f1 -- TranslationalSpring k s x F -- f2
}

def TranslationalDamper(d: Real, v: SRMatrix, x: SRMatrix, F: SRMatrix,
  f1: Frame, f2: Frame) -> Model = {

  translationEdge f1 f2 x F;
  x' == v;
  F == (d / ((norm2 x) + EPSILON) * (dot x v))  *. x
}

def TranslationalDamper(d: Real, f1: Frame, f2: Frame) -> Model = {
  def vd1, vd2, vd3, xd1, xd2, xd3, Fd1, Fd2, Fd3: Real;
  def v = vec3 vd1 vd2 vd3;
  def x = vec3 xd1 xd2 xd3;
  def F = vec3 Fd1 Fd2 Fd3;
  f1 -- TranslationalDamper d v x F -- f2
}

def RotationalSpring(k: Real, n: SRMatrix, om: SRMatrix, T: SRMatrix,
  f1: Frame, f2: Frame) -> Model = {

  def th: Real;
  angularVelocityEdge f1 f2 om T;
  th' = dot n om;
  th <- 0.;
  T == (k * th) *. n
}

def RotationalSpring(k: Real, u: RealVector3, q: SRMatrix,
  om: SRMatrix, T: SRMatrix, world: Frame, f1: Frame, f2: Frame)
  -> Model = {

  def R = mkR q;
  def n = normalize (vec3 u);
  world -- RotationSensor q -- f1;
  f1 -- RotationalSpring k (R * n) om T -- f2
}

def RotationalSpring(k: Real, u: RealVector3, q: SRMatrix,
  world: Frame, f1: Frame, f2: Frame) -> Model = {

  def omk1, omk2, omk3, Tk1, Tk2, Tk3: Real;
  def om = vec3 omk1 omk2 omk3;
  def T = vec3 Tk1 Tk2 Tk3;
  f1 -- RotationalSpring k u q om T world -- f2
}

def RotationalSpringEAA(k: Real, q: SRMatrix, om: SRMatrix, T: SRMatrix,
  world: Frame, f1: Frame, f2: Frame) -> Model = {

  def (th, n) = quat2eaa q;
  angularVelocityEdge f1 f2 om T;
  world -- RotationSensor q -- f2;
  T == (k * th) *. n
}

def RotationalSpringEAA(k: Real, q: SRMatrix, world: Frame,
  f1: Frame, f2: Frame) -> Model = {

  def omk1, omk2, omk3, Tk1, Tk2, Tk3: Real;
  def om = vec3 omk1 omk2 omk3;
  def T = vec3 Tk1 Tk2 Tk3;
  f1 -- RotationalSpringEAA k q world -- f2
}

def RotationalSpring(world: Frame, k: Real, u: RealVector3,
  q0: RealQuaternion) -> FrameFun2 = {

  fun f1: Frame -> fun f2: Frame ->
    def q = quat ();
    f1 -- RotationalSpring k u q world -- f2;
    norm2 q ~= 1.;
    q <~~ quat q0
}
