/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include GRAPHSIMCORE
include VECTOR

def DRIFT_ADJUST_QUATERNIONS = false
def QUATERNION_CORRECTION_CONSTANT = 2.0

def GRAVITATIONAL_CONSTANT = 9.81

type FrameFun1 = Frame -> Model
type FrameFun2 = Frame -> Frame -> Model

type Position = Vector
type Velocity = Vector3
type Force = Vector3
type Orientation = Quaternion
type AngularVelocity = Vector3
type Torque = Vector3
type AngleU = <Real>
type AngularVelocityU = <Real>
type TorqueU = <Real>

def mkTestVars(t: ()) = {
  def xm1_test, xm2_test, xm3_test,
    qm1_test, qm2_test, qm3_test, qm4_test: Real;

  def x = vec3 xm1_test xm2_test xm3_test;
  def q = quat qm1_test qm2_test qm3_test qm4_test;
  (x, q)
}

def translationEdge: Frame -> Frame -> Position -> Force -> Model
def rotationalEdge: Frame -> Frame -> Orientation -> Torque -> Model
def angularVelocityEdge: Frame -> Frame -> AngularVelocity -> Torque -> Model
// def initialRotationEdge: Frame -> Frame -> SRMatrix -> Model

type VectorPairEdge = (Edge, (Vector, Vector))
type VectorEdge = (Edge, Vector)

def getTranslationEdges(e: Model) -> ([VectorPairEdge], Model) = {
  def work(e: Model, a: ([VectorPairEdge], Model))
    -> ([VectorPairEdge], Model) = {

    match e with
    | Comp e_1 e_2 -> work e_2 (work e_1 a)
    | translationEdge n_1 n_2 (sval x: Position) (sval y: Force) ->
        (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoElement)
}

def getAngularVelocityEdges(e: Model) -> ([VectorPairEdge], Model) = {
  def work(e: Model, a: ([VectorPairEdge], Model))
    -> ([VectorPairEdge], Model) = {

    match e with
    | Comp e_1 e_2 -> work e_2 (work e_1 a)
    | angularVelocityEdge n_1 n_2 (sval x: AngularVelocity) (sval y: Torque) ->
        (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoElement)
}

def getRotationalEdges(e: Model) -> ([VectorPairEdge], Model) = {
  def work(e: Model, a: ([VectorPairEdge], Model))
    -> ([VectorPairEdge], Model) = {

    match e with
    | Comp e_1 e_2 -> work e_2 (work e_1 a)
    | rotationalEdge n_1 n_2 (sval x: Orientation) (sval y: Torque) ->
        (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoElement)
}

// def getRotationInitEdges(e: Model) -> ([VectorEdge], Model) = {
//   def work(e: Model, a: ([VectorEdge], Model))
//     -> ([VectorEdge], Model) = {
//     match e with
//     | Comp e_1 e_2 -> work e_2 (work e_1 a)
//     | initialRotationEdge n_1 n_2 (sval x: SRMatrix) ->
//         (((n_1, n_2), x)::(fst a), snd a)
//     | _ -> (fst a, (snd a); e)
//   };

//   work e ([], NoElement)
// }

def mkPriScndVarsRelVector3(C: MatrixMapInt, svs: [Vector3], pvs: [Vector3])
  -> [(Vector3, Vector3)] = {

  def uop(c: Int, v: Vector3) -> Vector3 = { - (int2real c) *. v };
  def bop(c: Int, l: Vector3, r: Vector3) -> Vector3 = {
    l - (int2real c) *. r
  };

  mkPriScndVarsRel uop bop ZERO3 C svs pvs
}

def mkPriScndVarsRelQuaternion(C: MatrixMapInt, sqs: [Quaternion],
  pqs: [Quaternion]) -> [(Quaternion, Quaternion)] = {

  def uop(c: Int, q: Quaternion) -> Quaternion = { if c < 0 then q else qconj q };
  def bop(c: Int, l: Quaternion, r: Quaternion) -> Quaternion = { qprod l (uop c r) };
  mkPriScndVarsRel uop bop (IDQ) C sqs pqs
}

def mkVector3TopolEquations(Cvs: (MatrixMapInt, ([Vector3], [Vector3])),
  a: Model) -> Model = {

  def (C, (svs, pvs)) = Cvs;
  def rs = mkPriScndVarsRelVector3 C svs pvs;

  def work(rs: [(Vector3, Vector3)], a: Model) -> Model = {
    match rs with
    | [] -> a
    | r::rs -> work rs (a; fst r = snd r)
    | _ -> error "Unmatched"
  };

  work rs a
}

def mkQuaternionTopolInitEquations(Cvs: (MatrixMapInt,
  ([Quaternion], [Quaternion])), a: Model) -> Model = {

  def (C, (svs, pvs)) = Cvs;
  def rs = mkPriScndVarsRelQuaternion C svs pvs;

  def work(rs: [(Quaternion, Quaternion)], a: Model) -> Model = {
    match rs with
    | [] -> a
    | r::rs -> work rs (a; fst r ~= snd r)
    | _ -> error "Unmatched"
  };

  work rs a
}

def mkE(q: Quaternion) = {
  def (q0, q1, q2, q3) = toRealQauternion q;
  listToMatrix [
                [-q1,  q0, -q3,  q2],
                [-q2,  q3,  q0, -q1],
                [-q3, -q2,  q1,  q0]
               ] (mmSRealZero (3, 4))
}

def mkG(q: Quaternion) = {
  def (q0, q1, q2, q3) = toRealQauternion q;
  listToMatrix [
                [-q1,  q0,  q3, -q2],
                [-q2, -q3,  q0,  q1],
                [-q3,  q2, -q1,  q0]
               ] (mmSRealZero (3, 4))
}

def mkR(q: Orientation) = (mkE q) * (tr (mkG q))
def mkH(q: Orientation) = 0.5 *. (tr (mkE q))

def relateQtoOm(q: Orientation, om: AngularVelocity) = {
  def H = mkH q;
  if DRIFT_ADJUST_QUATERNIONS then
    q' = (H * om) + (QUATERNION_CORRECTION_CONSTANT * (1. - sqrt(norm2 q))) *. q
  else q' = H * om
}

def mkJ(d: RealVector3) = {
  def (Jxx, Jyy, Jzz) = d;
  add (1, 1) Jxx (add (2, 2) Jyy (add (3, 3) Jzz (mmSRealZero (3, 3))))
}

def mkCuboidInertia(m: Real, x: Real, y: Real, z: Real) -> RealVector3 = {
  ((m / 12.) * (y^2. + z^2.), (m / 12.) * (x^2. + z^2.),
    (m / 12.) * (y^2. + x^2.))
}

def mkSphericalInertia(m: Real, r: Real) -> RealVector3 = {
  (m * r^2. / 5., m * r^2. / 5., m * r^2. / 5.)
}

def ForceActuator(f: Vector3, x: Position, f1: Frame, f2: Frame)
  -> Model = {

  translationEdge f1 f2 x f
}

def ForceActuator(f: Vector3, f1: Frame, f2: Frame) -> Model = {
  def xfa1, xfa2, xfa3: Real;
  def x = vec3 xfa1 xfa2 xfa3;
  f1 -- ForceActuator f x -- f2
}

def TranslationActuator(f: Vector3, F: Force, f1: Frame, f2: Frame)
  -> Model = {

  translationEdge f1 f2 f F
}

def TranslationActuator(f: Vector3, f1: Frame, f2: Frame) -> Model = {
  def Fta1, Fta2, Fta3: Real;
  def F = vec3 Fta1 Fta2 Fta3;
  f1 -- TranslationActuator f F -- f2
}

def AngularVelocityActuator(f: Vector3, T: Torque, f1: Frame, f2: Frame)
  -> Model = {

  angularVelocityEdge f1 f2 f T
}

def AngularVelocityActuator(f: Vector3, f1: Frame, f2: Frame) -> Model = {
  def Tra1, Tra2, Tra3: Real;
  def T = vec3 Tra1 Tra2 Tra3;
  f1 -- AngularVelocityActuator f T -- f2
}

def TorqueActuator(f: Vector3, om: AngularVelocity, f1: Frame, f2: Frame)
  -> Model = {

  angularVelocityEdge f1 f2 om f
}

def TorqueActuator(f: Vector3, f1: Frame, f2: Frame) -> Model = {
  def omta1, omta2, omta3: Real;
  def om = vec3 omta1 omta2 omta3;
  f1 -- TorqueActuator f om -- f2
}

def RotationSensor(q: Orientation, f1: Frame, f2: Frame) -> Model = {
  if seq f1 f2 then q = IDQ
  else {
    def oms1, oms2, oms3: Real;
    def om = vec3 oms1 oms2 oms3;
    relateQtoOm q om;
    f1 -- TorqueActuator ZERO3 om -- f2
  }
}

def AngularVelocitySensor(om: AngularVelocity, f1: Frame, f2: Frame) -> Model = {
  TorqueActuator ZERO3 om f1 f2
}

def TranslationSensor(x: Position, f1: Frame, f2: Frame) -> Model = {
  if seq f1 f2 then x = ZERO3
  else ForceActuator ZERO3 x f1 f2
}

def BodyT(m: Real, v: Velocity, x: Position, F: Force,
  world: Frame, fm: Frame) -> Model = {

  translationEdge world fm x F;
  x' = v;
  F = m *. v';
}

def BodyT(world: Frame, m: Real, v: Velocity, x: Position, F: Force,
  fm: Frame) -> Model = {

  world -- BodyT m v x F -- fm
}

def BodyT(m: Real, x: Position, world: Frame, fm: Frame) -> Model = {
  def vm1, vm2, vm3, Fm1, Fm2, Fm3: Real;
  def v = vec3 vm1 vm2 vm3;
  def F = vec3 Fm1 Fm2 Fm3;
  world -- BodyT m v x F -- fm
}

def BodyT(fm: Frame, m: Real, x: Position, world: Frame) -> Model = {
  world -- BodyT m x -- fm
}

def BodyR(Jd: RealVector3, om: AngularVelocity, q: Orientation, T: Orientation,
  world: Frame, fm: Frame) -> Model = {

  def R = mkR q;
  def J = mkJ Jd;
  def Jw = R * J * (tr R);
  angularVelocityEdge world fm om T;
  relateQtoOm q om;
  T = Jw * om' + (ss om) * Jw * om
}

def BodyR(Jd: RealVector3, q: Orientation, world: Frame, fm: Frame)
  -> Model = {

  def omm1, omm2, omm3, Tm1, Tm2, Tm3: Real;
  def om = vec3 omm1 omm2 omm3;
  def T = vec3 Tm1 Tm2 Tm3;
  world -- BodyR Jd om q T -- fm
}

def RigidArm1T(r: RealVector3, F: Force, q2: Orientation, fm: Frame, fe: Frame)
  -> Model = {

  TranslationActuator ((mkR q2) * (vec3 r)) F fm fe
}

def RigidArm1R(T: Torque, fm: Frame, fe: Frame) -> Model = {
  AngularVelocityActuator ZERO3 T fm fe
}

def RigidArm1R(fm: Frame, fe: Frame) -> Model = {
  def Tr11, Tr12, Tr13: Real;
  def T = vec3 Tr11 Tr12 Tr13;
  fm -- RigidArm1R T -- fe
}

def RigidArm2R(r: RealVector3, F1: Force, om: AngularVelocity, q: Orientation,
  T: Torque, world: Frame, fm: Frame) -> Model = {

  angularVelocityEdge world fm om T;
  relateQtoOm q om;
  T = -(ss ((mkR q) * (vec3 r))) * F1
}

def RigidArm2R(r: RealVector3, F1: Force, q: Orientation,
  world: Frame, fm: Frame) -> Model = {

  def omr21, omr22, omr23, Tr21, Tr22, Tr23: Real;
  def om = vec3 omr21 omr22 omr23;
  def T = vec3 Tr21 Tr22 Tr23;
  world -- RigidArm2R r F1 om q T -- fm
}

def Gravity(m: Real, world: Frame, fm: Frame) -> Model = {
  ForceActuator ((m * GRAVITATIONAL_CONSTANT) *. ZHAT) world fm
}

def Gravity(world: Frame, m: Real, fm: Frame) -> Model = {
  world -- Gravity m -- fm
}

def SphericalJoint(f1: Frame, f2: Frame) -> Model = {
  TranslationActuator ZERO3 f1 f2
}

def RevoluteJointR(u1: Vector3, u2: Vector3, u3: Vector, om: AngularVelocity,
  T: Torque, f1: Frame, f2: Frame) -> Model = {

  angularVelocityEdge f1 f2 om T;
  dot u1 T = 0.;
  dot u2 om = 0.;
  dot u3 om = 0.
}

def RevoluteJointR(u1: Vector3, u2: Vector3, u3: Vector3,
  f1: Frame, f2: Frame) -> Model = {

  def omhr1, omhr2, omhr3, Thr1, Thr2, Thr3: Real;
  def om = vec3 omhr1 omhr2 omhr3;
  def T = vec3 Thr1 Thr2 Thr3;
  f1 -- RevoluteJointR u1 u2 u3 om T -- f2
}

def RevoluteJoint(u: RealVector3, q: Orientation, world: Frame,
  f1: Frame, f2: Frame) -> Model = {

  def (u1, u2, u3) = mkOrthogonalBasis u;
  def R = mkR q;
  world -- RotationSensor q -- f1;
  f1 -- RevoluteJointR (R * u1) (R * u2) (R * u3) -- f2
}

def RotationDamper(d: Real, f1: Frame, f2: Frame) -> Model = {
  def omd1, omd2, omd3, Td1, Td2, Td3: Real;
  def om = vec3 omd1 omd2 omd3;
  def T = vec3 Td1 Td2 Td3;
  angularVelocityEdge f1 f2 om T;
  T = d *. om
}

def Body(m: Real, Jd: RealVector3, x: Position, q: Orientation,
  world: Frame, fm: Frame) -> Model = {

  BodyT m x world fm;
  BodyR Jd q world fm
}

def RigidArm(r: RealVector3, q: Orientation, world: Frame,
  fe: Frame, fm: Frame) -> Model = {

  def Fr11, Fr12, Fr13: Real;
  def Fr1 = vec3 Fr11 Fr12 Fr13;
  fm -- RigidArm1T r Fr1 q -- fe;
  fm -- RigidArm1R -- fe;
  world -- RigidArm2R r Fr1 q -- fm
}

def RigidArm(world: Frame, r: RealVector3, q: Orientation,
  fe: Frame, fm: Frame) -> Model = {

  fe -- RigidArm r q world -- fm
}

def _mkRigidArmVar(t: ()) = {
  def qra1, qra2, qra3, qra4: Real;
  def q = quat qra1 qra2 qra3 qra4;
  q
}

def RigidArm(world: Frame, r: RealVector3, q0: RealQuaternion) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    def q = _mkRigidArmVar ();
    f1 -- RigidArm world r q -- f2;
    q <~ quat q0; norm2 q ~= 1.
}

def RigidArm(world: Frame, r: RealVector3) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    def q = _mkRigidArmVar ();
    f1 -- RigidArm world r q -- f2;
    norm2 q ~= 1.
}

def AngularVelocitySensorU(u: Vector3, omu: AngularVelocityU,
  f1: Frame, f2: Frame) -> Model = {

  def oms1, oms2, oms3: Real;
  def om = vec3 oms1 oms2 oms3;
  def n = normalize u;
  f1 -- AngularVelocitySensor om -- f2;
  omu = dot n om
}

def AngularVelocitySensorU(u: RealVector3, omu: AngularVelocityU,
  f1: Frame, f2: Frame) -> Model = {

  f1 -- AngularVelocitySensorU (vec3 u) omu -- f2
}

def AngularSensorU(u: Vector3, th0: Real, th: AngleU,
  f1: Frame, f2: Frame) -> Model = {

  def omu: AngularVelocityU;
  th' = omu;
  th <- th0;
  f1 -- AngularVelocitySensorU u omu -- f2
}

def AngularSensorU(u: RealVector3, th0: Real, th: AngleU,
  f1: Frame, f2: Frame) -> Model = {

  def omu: AngularVelocityU;
  th' = omu;
  th <- th0;
  f1 -- AngularVelocitySensorU u omu -- f2
}

def TranslationalSpring(k: Real, s: Real, x: Position, F: Force,
  f1: Frame, f2: Frame) -> Model = {

  translationEdge f1 f2 x F;
  F = (k * (1. - (s / (sqrt(norm2 x) + EPSILON)))) *. x;
}

def TranslationalSpring(k: Real, s: Real, f1: Frame, f2: Frame) -> Model = {
  def xk1, xk2, xk3, Fk1, Fk2, Fk3: Real;
  def x = vec3 xk1 xk2 xk3;
  def F = vec3 Fk1 Fk2 Fk3;
  f1 -- TranslationalSpring k s x F -- f2
}

def TranslationalDamper(d: Real, v: Velocity, x: Position, F: Force,
  f1: Frame, f2: Frame) -> Model = {

  translationEdge f1 f2 x F;
  x' = v;
  F = (d / ((norm2 x) + EPSILON) * (dot x v))  *. x
}

def TranslationalDamper(d: Real, f1: Frame, f2: Frame) -> Model = {
  def vd1, vd2, vd3, xd1, xd2, xd3, Fd1, Fd2, Fd3: Real;
  def v = vec3 vd1 vd2 vd3;
  def x = vec3 xd1 xd2 xd3;
  def F = vec3 Fd1 Fd2 Fd3;
  f1 -- TranslationalDamper d v x F -- f2
}

def RotationalSpring(k: Real, n: Vector3, om: AngularVelocity, T: Torque,
  f1: Frame, f2: Frame) -> Model = {

  def th: Real;
  angularVelocityEdge f1 f2 om T;
  th' = dot n om;
  th <- 0.;
  T = (k * th) *. n
}

def RotationalSpring(k: Real, u: RealVector3, q: Orientation,
  om: AngularVelocity, T: Torque, world: Frame, f1: Frame, f2: Frame)
  -> Model = {

  def R = mkR q;
  def n = normalize (vec3 u);
  world -- RotationSensor q -- f1;
  f1 -- RotationalSpring k (R * n) om T -- f2
}

def RotationalSpring(k: Real, u: RealVector3, q: Orientation,
  world: Frame, f1: Frame, f2: Frame) -> Model = {

  def omk1, omk2, omk3, Tk1, Tk2, Tk3: Real;
  def om = vec3 omk1 omk2 omk3;
  def T = vec3 Tk1 Tk2 Tk3;
  f1 -- RotationalSpring k u q om T world -- f2
}

def RotationalSpringEAA(k: Real, q: Orientation, om: AngularVelocity, T: Torque,
  world: Frame, f1: Frame, f2: Frame) -> Model = {

  def (th, n) = quat2eaa q;
  angularVelocityEdge f1 f2 om T;
  world -- RotationSensor q -- f2;
  T = (k * th) *. n
}

def RotationalSpringEAA(k: Real, q: Orientation, world: Frame,
  f1: Frame, f2: Frame) -> Model = {

  def omk1, omk2, omk3, Tk1, Tk2, Tk3: Real;
  def om = vec3 omk1 omk2 omk3;
  def T = vec3 Tk1 Tk2 Tk3;
  f1 -- RotationalSpringEAA k q world -- f2
}

def RotationalSpring(world: Frame, k: Real, u: RealVector3,
  q0: RealQuaternion) -> FrameFun2 = {

  fun f1: Frame -> fun f2: Frame ->
    def q = quat ();
    f1 -- RotationalSpring k u q world -- f2;
    norm2 q ~= 1.;
    q <~ quat q0
}
