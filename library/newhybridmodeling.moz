/*
   Modeling Kernel Language (Modelyze) library
   Copyright (C) 2010-2012 David Broman

   Modelyze library is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Modelyze library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public License
   along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

Author: Oscar Eriksson oerikss@kth.se
 */

include Equation
include Elaboration
include ModelyzeDAE

def LOGLEVEL: String = "DEBUG"
// def LOGLEVEL: String = "NO_DEBUG"
// Debug categories
def SW: Int = 0 // Switches

def logdebug(id: Int, msg: String, obj: ?) -> () = {
  match LOGLEVEL with
    | "DEBUG" -> {
      def prefix: String = LOGLEVEL ++ ": [" ++ (int2string id) ++ "] " ++ msg ++ ": ";
      def _ = print(prefix);
      dprint(obj)
    }
  | _ -> ()
}

// Since parametric types are not yet supported a dynamic type is the next best thing for initial values
type InitVals = Dyn
// Supposed to be InitVals -> Equations but this does not typecheck atm
type TransFun = InitVals -> Dyn
type ZeroCrossing = Signal
type Switch = Equations -> ZeroCrossing -> TransFun -> Equations
// Type to relate ZeroCrossing's with the root finding array returned from IDA
type ZcMap = (ZeroCrossing => (Int, Bool))
type ZcList = [(ZeroCrossing, (Int, Bool))]

def _switch: Switch
def switch(eqs: Equations, zc: ZeroCrossing, tf: TransFun) -> Equations = {
  _switch eqs zc tf
} 

type State = (Time, SolverState, VarArray, UkMap, ZcMap)

def labelZcs(zcm: ZcMap) -> (ZcMap, [ZeroCrossing]) = {
  def work(zcl: ZcList, zcm: ZcMap, idx: Int) -> ZcMap = {  
    match zcl with
    | e::es -> {
        def (zc, (i, b)) = e;
        work es (Map.add zc (idx, b) zcm) (idx - 1)
        }
    | [] -> zcm
  };

  def f(e: (ZeroCrossing, (Int, Bool))) -> ZeroCrossing = {
    def (zc, _) = e;
    zc
  };
  
  def zcl = (Map.toList zcm);
  def zcm = work zcl zcm ((length zcl) - 1);
  (zcm, reverse (map zcl f))
}

def makeRootFuns(zcl: [ZeroCrossing], ukm: UkMap, t: Time, yy: VarArray, yp: VarArray) -> [Real] = {
  map zcl (fun zc: ZeroCrossing -> (evalFromArray zc ukm))      
}

def elaborateSwitches(eqs: Equations) -> Equations = {
  def _ = logdebug SW "Before sw elaboration" eqs;
  def elabSws(eqs: Equations, acc: Equations) -> Equations = {
    match eqs with
    | _switch es _ _ -> (elabSws es acc)
    | e; es -> (elabSws es ((elabSws e acc)))
    | e -> e; acc
  };
  def res = (elabSws eqs NoEqn);
  def _ = logdebug SW "After sw elaboration" res;
  res
}

