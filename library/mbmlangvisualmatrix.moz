/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include GRAPHSIMEXPORT
include GRAPHSIM

def SCENE_FILENAME = "/tmp/scene.json"

type Color = String
type Opacity = Real

type Material
def stdMaterial: Color -> Real -> Material

type Geometry3D
def cuboid: Real -> Real -> Real -> Geometry3D
def sphere: Real -> Geometry3D
def cylinder: Real -> Real -> RealVector3 -> Geometry3D

type VisualData
def invisible: VisualData
def visualSolid: Geometry3D -> Material -> VisualData
def visualAxes: Real -> VisualData

def visualObject: SRMatrix -> SRMatrix -> VisualData -> Model

def WHITE = "#ffffff"
def RED = "#ff0000"
def BLUE = "#0000ff"
def GREEN = "#00ff00"
def BLACK = "#000000"

def real2JSONString(r: Real) -> String = {
  if int2real (real2int r) == r then real2string r ++ "0"
  else real2string r
}

def geometry2JSON(g: Geometry3D) -> String = {
  match g with
  | cuboid (sval w: Real) (sval h: Real) (sval d: Real) ->
      "{ " ++
      "\"type\": \"Cuboid\", " ++
      "\"w\": " ++ real2JSONString w ++ ", " ++
      "\"h\": " ++ real2JSONString h ++ ", " ++
      "\"d\": " ++ real2JSONString d ++
      " }"

  | sphere (sval r: Real) ->
    "{ " ++
    "\"type\": \"Sphere\", " ++
    "\"radius\": " ++ real2JSONString r ++
    " }"

  | cylinder (sval r: Real) (sval h: Real) (sval u: RealVector3) -> {
      def (u1, u2, u3) = u;
      "{ " ++
      "\"type\": \"Cylinder\", " ++
      "\"radius\": " ++ real2JSONString r ++ ", " ++
      "\"height\": " ++ real2JSONString h ++ ", " ++
      "\"u1\": " ++ real2JSONString u1 ++ ", " ++
      "\"u2\": " ++ real2JSONString u2 ++ ", " ++
      "\"u3\": " ++ real2JSONString u3 ++
      " }"
    }

  | _ -> error "Unmatched Geometry3D"
}

def material2JSON(m: Material) -> String = {
  match m with
  | stdMaterial (sval s: String) (sval o: Real) -> {
      if o >= 0. && o <= 1. then {
        "{ " ++
        "\"type\": \"Standard\", " ++
        "\"color\": \"" ++ s ++ "\", " ++
        "\"opacity\": " ++ real2JSONString o ++
        " }"
      } else error INVALID_ARGUMENT
    }
  | _ -> error "Unmatched Material"
}

def visualData2Json(d: VisualData) -> String = {
  match d with
  | visualSolid g m -> "{ \"type\": \"Solid\"," ++
                       "\"geometry\": " ++ geometry2JSON g ++ ", " ++
                       "\"material\": " ++ material2JSON m ++
                       " }"
  | visualAxes (sval s: Real) -> "{ \"type\": \"Axes\", " ++
                                 "\"size\": " ++ real2JSONString s ++
                                 " }"
  | _ -> error "Unmatched visual data"
}

def visualObject2JSON(m: Model) -> String = {
  def work(m: Model) -> String = {
    match m with
    | m_1 ; m_2 -> work m_1 ++ ", " ++ work m_2
    | visualObject (sval v: SRMatrix)  (sval q: SRMatrix) vd -> {
        def (x, y, z) = toRealVector3 v;
        def (w, i, j, k) = toRealQauternion q;
        "{ " ++
        "\"xLabel\": \"" ++ symstr(x) ++ "\", " ++
        "\"yLabel\": \"" ++ symstr(y) ++ "\", " ++
        "\"zLabel\": \"" ++ symstr(z) ++ "\", " ++
        "\"wLabel\": \"" ++ symstr(w) ++ "\", " ++
        "\"iLabel\": \"" ++ symstr(i) ++ "\", " ++
        "\"jLabel\": \"" ++ symstr(j) ++ "\", " ++
        "\"kLabel\": \"" ++ symstr(k) ++ "\", " ++
        "\"data\": " ++ visualData2Json vd ++
        " }"
      }
    | _ -> { def _ = dprintln m; error "Expected only visualObject" }
  };
  "{ \"scene\": [ " ++ work m ++ " ] }"
}

def getVisibleVisualObjects(m: Model) -> Model = {
  def work(m: Model, a: Model) -> Model = {
    match m with
    | m_1 ; m_2 -> work m_2 (work m_1 a)
    | visualObject _ _ invisible -> a
    | visualObject _ _ _ -> a ; m
    | _ -> a
  };
  work m NoElement
}

def cleanupModel(m: Model) -> Model = {
    match m with
    | m_1 ; m_2 -> {
          match (cleanupModel m_1, cleanupModel m_2) with
          | (NoElement, NoElement) -> NoElement
          | (NoElement, m) -> m
          | (m, NoElement) -> m
          | (m_1b, m_2b) -> m_1b ; m_2b
       }
    | _ -> m
}

def elaborateToFile(exportfun: (Model -> ()), m: Model) -> () = {
  def m = elaborate m;
  def vo = getVisibleVisualObjects m;
  def vo = cleanupModel vo;

  def _ = exportfun m;
  match vo with
  | NoElement -> ()
  | _ -> writeFile SCENE_FILENAME (visualObject2JSON vo ++ "\n")
}

def elaborateToFile(m: Model) -> () =
  elaborateToFile export2ModelicaFile m

def elaborateToFileDebug(m: Model) -> () =
  elaborateToFile export2ModelicaFileDebug m

def clock1(t0: Real, t: <Real>) -> Model = clock t0 t

def translationActuator1(f: SRMatrix) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    translationActuator f f1 f2
}

def torqueActuator1(f: SRMatrix) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame -> torqueActuator f f1 f2
}

def translationSensor1(x: SRMatrix) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    translationSensor x f1 f2
}

def rotationSensor1(q: SRMatrix) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    rotationSensor q f1 f2
}

def _mkBodyVarT(t: ()) = {
  def xm1, xm2, xm3: Real;
  mkVector3 xm1 xm2 xm3
}

def _mkBodyVarR(t: ()) = {
  def qm1, qm2, qm3, qm4: Real;
  mkQuaternion qm1 qm2 qm3 qm4
}

def _mkBodyVars(t: ()) = {
  def x = _mkBodyVarT ();
  def q = _mkBodyVarR ();
  (x, q)
}

def mkTestVars(t: ()) = {
  def xm1_test, xm2_test, xm3_test,
    qm1_test, qm2_test, qm3_test, qm4_test: Real;

  def x = mkVector3 xm1_test xm2_test xm3_test;
  def q = mkQuaternion qm1_test qm2_test qm3_test qm4_test;
  (x, q)
}

def body1(world: Frame, m: Real, Jd: RealVector3, vd: VisualData,
  x: SRMatrix, q: SRMatrix) -> FrameFun1 = {

  fun fm: Frame ->
    world -- body m Jd x q -- fm ; visualObject x q vd
}

def body1(world: Frame, m: Real, Jd: RealVector3, vd: VisualData,
  q0: RealQuaternion) -> FrameFun1 = {

  fun fm: Frame ->
    def (x, q) = _mkBodyVars ();
    body1 world m Jd vd x q fm ;
    norm2 q ~= 1.; q <~~ mkQuaternion q0
}

def body1(world: Frame, m: Real, Jd: RealVector3, vd: VisualData)
  -> FrameFun1 = {

  fun fm: Frame ->
    def (x, q) = _mkBodyVars ();
    body1 world m Jd vd x q fm ; norm2 q ~= 1.
}

def gravity1(world: Frame, m: Real) -> FrameFun1 = {
  fun fm: Frame -> gravity m world fm
}

def _mkTransSensVar(t: ()) = {
  def xs1, xs2, xs3: Real;
  def x = mkVector3 xs1 xs2 xs3;
  x
}

def sphericalJoint1(world: Frame, vd: VisualData) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    def x = _mkTransSensVar ();
    def q = mkQuaternion ();
    sphericalJoint f1 f2;
    translationSensor x world f1;
    q == mkQuaternion idq;
    q <~~ mkQuaternion idq;
    visualObject x q vd
}

def sphericalJoint1(world: Frame, r: Real, c: Color, o: Opacity) -> FrameFun2 = {
  sphericalJoint1 world (visualSolid (sphere r) (stdMaterial c o))
}

def revoluteJoint1(world: Frame, u: RealVector3, vd: VisualData,
  q0: RealQuaternion) -> FrameFun2 = {

  fun f1: Frame -> fun f2: Frame ->
    def qrj1, qrj2, qrj3, qrj4: Real;
    def q = mkQuaternion qrj1 qrj2 qrj3 qrj4;
    def x = _mkTransSensVar ();
    sphericalJoint f1 f2;
    translationSensor x world f1;
    revoluteJoint u q world f1 f2;
    q <~~ mkQuaternion q0;
    visualObject x q vd
}

def revoluteJoint1(world: Frame, r: Real, h: Real, c: Color, o: Opacity,
  u: RealVector3, q0: RealQuaternion) -> FrameFun2 = {

  revoluteJoint1 world u (visualSolid (cylinder r h u) (stdMaterial c o)) q0
}

def rotationDamper1(D: Real) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame -> damperR D f1 f2
}

def _mkRigidArmVar(t: ()) = {
  def qra1, qra2, qra3, qra4: Real;
  def q = mkQuaternion qra1 qra2 qra3 qra4;
  q
}

def rigidArm1(world: Frame, r: RealVector3, q: SRMatrix) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    rigidArm r q world f1 f2
}

def rigidArm1(world: Frame, r: RealVector3, q0: RealQuaternion) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    def q = _mkRigidArmVar ();
    rigidArm1 world r q f1 f2 ;
    q <~~ mkQuaternion q0; norm2 q ~= 1.
}

def rigidArm1(world: Frame, r: RealVector3) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    def q = _mkRigidArmVar ();
    rigidArm1 world r q f1 f2 ; norm2 q ~= 1.
}

def bar1(world: Frame, m: Real, w: Real, h: Real, d: Real, c: Color, o: Opacity,
  xm: SRMatrix, qm: SRMatrix, ql: SRMatrix, qr: SRMatrix) -> FrameFun2 = {

  fun fw: Frame -> fun fe: Frame ->
    def fm: Frame;
    def Jd = mkCuboidInertia m w h d;
    // def Jd = (1., 2., 3.);
    def larm = rigidArm1 world (-w / 2., 0., 0.) qr;
    def rarm = rigidArm1 world (-w / 2., 0., 0.) ql;
    fw -- larm  -.- fm -.- rarm -- fe
    ; body1 world m Jd (visualSolid (cuboid w h d) (stdMaterial c o)) xm qm fm
    ; gravity1 world m fm

}

def bar1(world: Frame, m: Real, w: Real, h: Real, d: Real, c: Color, o: Opacity,
  x: SRMatrix, q: SRMatrix) -> FrameFun2 = {

  fun fw: Frame -> fun fe: Frame ->
    def qr = _mkRigidArmVar ();
    def ql = _mkRigidArmVar ();
    bar1 world m w h d c o x q ql qr fw fe
    ; qr~== q; ql ~== q
}

def bar1(world: Frame, m: Real, w: Real, h: Real, d: Real, c: Color, o: Opacity,
  q0: RealQuaternion) -> FrameFun2 = {

  fun fw: Frame -> fun fe: Frame ->
    def qr = _mkRigidArmVar ();
    def ql = _mkRigidArmVar ();
    def (x, q) = _mkBodyVars ();
    bar1 world m w h d c o x q fw fe;
    norm2 q ~= 1. ;
    q <~~ mkQuaternion q0
}

def bar1(world: Frame, m: Real, w: Real, h: Real, d: Real, c: Color, o: Opacity)
  -> FrameFun2 = {

  fun fw: Frame -> fun fe: Frame ->
    def (x, q) = _mkBodyVars ();
    bar1 world m w h d c o x q fw fe ; norm2 q ~= 1.
}

def sphere1(world: Frame, m: Real, r: Real, c: Color, o: Opacity,
  x: SRMatrix, q: SRMatrix) -> FrameFun1 = {

  fun fm: Frame ->
    def Jd = mkSphericalInertia m r;
    body1 world m Jd (visualSolid (sphere r) (stdMaterial c o)) x q fm
    ; gravity1 world m fm
}

def translationalSpring1(k: Real, s: Real) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    translationalSpring k s f1 f2
}

def translationalDamper1(d: Real) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    translationalDamper d f1 f2
}

def rotationalSpring1(world: Frame, k: Real, u: RealVector3,
  q0: RealQuaternion) -> FrameFun2 = {

  fun f1: Frame -> fun f2: Frame ->
    def q = mkQuaternion ();
    rotationalSpring k u q world f1 f2;
    norm2 q ~= 1.;
    q <~~ mkQuaternion q0
}

def angularVelocityActuator1(f: SRMatrix) -> FrameFun2 = {
  fun f1: Frame -> fun f2: Frame ->
    angularVelocityActuator f f1 f2
}
