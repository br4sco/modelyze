/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include EXPORTMATRIX

def SCENE_FILENAME = "/tmp/scene.json"

type Color = String

type Material
def stdMaterial: Color -> Real -> Material

type Geometry3D
def cuboid: Real -> Real -> Real -> Geometry3D
def sphere: Real -> Geometry3D
def cylinder: Real -> Real -> RealVector3 -> Geometry3D

type VisualData
def invisible: VisualData
def visualSolid: Geometry3D -> Material -> VisualData
def visualAxes: Real -> VisualData

type ModelElement
def (++) : ModelElement -> ModelElement -> ModelElement
def visualElement: SRMatrix -> SRMatrix -> VisualData -> ModelElement
def equationsElement: Equations -> ModelElement
def NoElement: ModelElement

type FrameFun1 = Frame -> ModelElement
type FrameFun2 = Frame -> Frame -> ModelElement

def inParallel(l: FrameFun2, r: FrameFun2, f_1: Frame, f_2: Frame) -> ModelElement = {
  l f_1 f_2 ++ r f_1 f_2
}
def (||) = inParallel

def inSeries(l: Frame, r: FrameFun1) -> ModelElement = {
  r l
}
def (--) = inSeries

def inSeries(l: FrameFun1, r: Frame) -> ModelElement = {
  l r
}
def (--) = inSeries

def inSeries(f: Frame, r: FrameFun2) -> FrameFun1 = {
  r f
}
def (--) = inSeries

def inSeries(l: FrameFun1, r: FrameFun2) = {
  def f_1: Frame;
  fun f_2: Frame -> l f_1 ++ r f_1 f_2
}
def (--) = inSeries

def inSeriesExposeFrame(l: FrameFun2, f_2: Frame) = {
  (l, f_2)
}
def (-.-) = inSeriesExposeFrame

def inSeriesExposeFrame(lf_2: (FrameFun2, Frame), r: FrameFun2) = {
  def (l, f_2) = lf_2;
  fun f_1: Frame -> fun f_3: Frame -> l f_1 f_2 ++ r f_2 f_3
}
def (-.-) = inSeriesExposeFrame

def inSeries(l: FrameFun2, r: FrameFun2) = {
  def f_2: Frame;
  fun f_1: Frame -> fun f_3: Frame -> l f_1 f_2 ++ r f_2 f_3
}
def (--) = inSeries

def WHITE = "#ffffff"
def RED = "#ff0000"
def BLUE = "#0000ff"
def GREEN = "#00ff00"
def BLACK = "#000000"

def real2JSONstring(r: Real) -> String = {
  if int2real (real2int r) == r then real2string r ++ "0"
  else real2string r
}

def geometry2JSON(g: Geometry3D) -> String = {
  match g with
  | cuboid (sval x: Real) (sval y: Real) (sval z: Real) ->
      "{ " ++
      "\"type\": \"Cuboid\", " ++
      "\"x\": " ++ real2JSONstring x ++ ", " ++
      "\"y\": " ++ real2JSONstring y ++ ", " ++
      "\"z\": " ++ real2JSONstring z ++
      " }"

  | sphere (sval r: Real) ->
    "{ " ++
    "\"type\": \"Sphere\", " ++
    "\"radius\": " ++ real2JSONstring r ++
    " }"

  | cylinder (sval r: Real) (sval h: Real) (sval u: RealVector3) -> {
      def (u1, u2, u3) = u;
      "{ " ++
      "\"type\": \"Cylinder\", " ++
      "\"radius\": " ++ real2JSONstring r ++ ", " ++
      "\"height\": " ++ real2JSONstring h ++ ", " ++
      "\"u1\": " ++ real2JSONstring u1 ++ ", " ++
      "\"u2\": " ++ real2JSONstring u2 ++ ", " ++
      "\"u3\": " ++ real2JSONstring u3 ++
      " }"
    }

  | _ -> error "Unmatched Geometry3D"
}

def material2JSON(m: Material) -> String = {
  match m with
  | stdMaterial (sval s: String) (sval o: Real) -> {
      if o >= 0. && o <= 1. then {
        "{ " ++
        "\"type\": \"Standard\", " ++
        "\"color\": \"" ++ s ++ "\", " ++
        "\"opacity\": " ++ real2JSONstring o ++
        " }"
      } else error INVALID_ARGUMENT
    }
  | _ -> error "Unmatched Material"
}

def visualData2Json(d: VisualData) -> String = {
  match d with
  | visualSolid g m -> "{ \"type\": \"Solid\"," ++
                       "\"geometry\": " ++ geometry2JSON g ++ ", " ++
                       "\"material\": " ++ material2JSON m ++
                       " }"
  | visualAxes (sval s: Real) -> "{ \"type\": \"Axes\", " ++
                                 "\"size\": " ++ real2JSONstring s ++
                                 " }"
  | _ -> error "Unmatched visual data"
}

def visualElement2Json(o: ModelElement) -> String = {
  def work(o: ModelElement) -> String = {
    match o with
    | o_1 ++ o_2 -> work o_1 ++ ", " ++ work o_2
    | visualElement (sval v: SRMatrix)  (sval q: SRMatrix) vd -> {
        def (x, y, z) = vec3ToTuple v;
        def (w, i, j, k) = quatToTuple q;
        "{ " ++
        "\"xLabel\": \"" ++ symstr(x) ++ "\", " ++
        "\"yLabel\": \"" ++ symstr(y) ++ "\", " ++
        "\"zLabel\": \"" ++ symstr(z) ++ "\", " ++
        "\"wLabel\": \"" ++ symstr(w) ++ "\", " ++
        "\"iLabel\": \"" ++ symstr(i) ++ "\", " ++
        "\"jLabel\": \"" ++ symstr(j) ++ "\", " ++
        "\"kLabel\": \"" ++ symstr(k) ++ "\", " ++
        "\"data\": " ++ visualData2Json vd ++
        " }"
      }
    | _ -> { def _ = dprintln o; error "Expected only visualElement" }
  };
  "{ \"scene\": [ " ++ work o ++ " ] }"
}

def getVisibleVisualElements(o: ModelElement) -> ModelElement = {
  def work(o: ModelElement, a: ModelElement) -> ModelElement = {
    match o with
    | o_1 ++ o_2 -> work o_2 (work o_1 a)
    | visualElement _ _ invisible -> a
    | visualElement _ _ _ -> a ++ o
    | _ -> a
  };
  work o NoElement
}

def cleanupModelElements(o: ModelElement) -> ModelElement = {
    match o with
    | o_1 ++ o_2 -> {
          match (cleanupModelElements o_1, cleanupModelElements o_2) with
          | (NoElement, NoElement) -> NoElement
          | (NoElement, o) -> o
          | (o, NoElement) -> o
          | (o_1b,o_2b) -> o_1b ++ o_2b
       }
    | _ -> o
}

def getModel(o: ModelElement) -> Equations = {
  def work(o: ModelElement, a: Equations) -> Equations = {
    match o with
    | o_1 ++ o_2 -> (work o_2 (work o_1 a))
    | equationsElement e -> a; e
    | _ -> a
  };
  work o NoEqn
}

def elaborateToFile(o: ModelElement) -> () = {
  def m = elaborate (getModel o);
  def vo = getVisibleVisualElements o;
  def vo = cleanupModelElements vo;

  def _ = export2ModelicaFile m;
  match vo with
  | NoElement -> ()
  | _ -> writeFile SCENE_FILENAME (visualElement2Json vo ++ "\n")
}

def _mkBodyVars(t: ()) = {
  def xm1, xm2, xm3, qm1, qm2, qm3, qm4: Real;
  def x = mkVector3 xm1 xm2 xm3;
  def q = mkQuaternion qm1 qm2 qm3 qm4;
  (x, q)
}

def _mkBody(e: Equations, x: SRMatrix, q: SRMatrix, world: Frame, m: Real, Jd: RealVector3, vd: VisualData, fm: Frame) = {
  equationsElement (e; body m Jd x q world fm) ++ visualElement x q vd
}

// def body1(world: Frame, m: Real, Jd: RealVector3, vd: VisualData, x0: RealVector3, q0: RealQuaternion) -> FrameFun1 = {
//   def (x, q) = _mkBodyVars ();
//   _mkBody (x <~~ mkVector3 x0; q <~~ mkQuaternion q0; norm2 q ~= 1.) x q world m Jd vd
// }

// def body1(world: Frame, m: Real, Jd: RealVector3, vd: VisualData, x0: RealVector3) -> FrameFun1 = {
//   def (x, q) = _mkBodyVars ();
//   _mkBody (x <~~ mkVector3 x0; norm2 q ~= 1.) x q world m Jd vd
// }

def body1(world: Frame, m: Real, Jd: RealVector3, vd: VisualData, q0: RealQuaternion) -> FrameFun1 = {
  def (x, q) = _mkBodyVars ();
  _mkBody (q <~~ mkQuaternion q0; norm2 q ~= 1.) x q world m Jd vd
}

type BodyFun = Frame -> Real -> RealVector3 -> VisualData -> FrameFun1

// def _mkBodyFun(x0: RealVector3, q0: RealQuaternion) -> BodyFun = {
//   fun world: Frame -> fun m: Real -> fun Jd: RealVector3 -> fun vd: VisualData ->
//     body1(world, m, Jd, vd, x0, q0)
// }

// def _mkBodyFun(x0: RealVector3) -> BodyFun = {
//   fun world: Frame -> fun m: Real -> fun Jd: RealVector3 -> fun vd: VisualData ->
//     body1(world, m, Jd, vd, x0)
// }

def _mkBodyFun(q0: RealQuaternion) -> BodyFun = {
  fun world: Frame -> fun m: Real -> fun Jd: RealVector3 -> fun vd: VisualData ->
    body1(world, m, Jd, vd, q0)
}

def gravity1(world: Frame, m: Real) -> FrameFun1 = {
  fun fm: Frame -> equationsElement (gravity m world fm)
}

def _mkTransSensVar(t: ()) = {
  def xs1, xs2, xs3: Real;
  def x = mkVector3 xs1 xs2 xs3;
  x
}

def sphericalJoint1(world: Frame, vd: VisualData) -> FrameFun2 = {
  def x = _mkTransSensVar ();
  def q = mkQuaternion ();
  fun f1: Frame -> fun f2: Frame ->
    equationsElement (
                      sphericalJoint f1 f2
                      ;translationSensor x world f1
                      ;q == mkQuaternion idq
                      ;q <~~ mkQuaternion idq
                     )
    ++ visualElement x q vd
}

def sphericalJoint1(world: Frame, r: Real, c: Color, o: Real) -> FrameFun2 = {
  sphericalJoint1 world (visualSolid (sphere r) (stdMaterial c o))
}

def revoluteJoint1(world: Frame, u: RealVector3, vd: VisualData, q0: RealQuaternion) -> FrameFun2 = {
  def qrj1, qrj2, qrj3, qrj4: Real;
  def q = mkQuaternion qrj1 qrj2 qrj3 qrj4;
  def x = _mkTransSensVar ();
  fun f1: Frame -> fun f2: Frame ->
    equationsElement (
                      sphericalJoint f1 f2
                      ;translationSensor x world f1
                      ;revoluteJoint u q world f1 f2
                      ;q <~~ mkQuaternion q0
                     )
    ++ visualElement x q vd
}

def revoluteJoint1(world: Frame, r: Real, h: Real, c: Color, o: Real, u: RealVector3, q0: RealQuaternion) -> FrameFun2 = {
  revoluteJoint1 world u (visualSolid (cylinder r h u) (stdMaterial c o)) q0
}

def _mkRigidArmVar(t: ()) = {
  def qra1, qra2, qra3, qra4: Real;
  def q = mkQuaternion qra1 qra2 qra3 qra4;
  q
}

def _mkRigidArm(e: Equations, q: SRMatrix, world: Frame, r: RealVector3, f1: Frame, f2: Frame) = {
  equationsElement (e; rigidArm r q world f1 f2)
}

def rigidArm1(world: Frame, r: RealVector3, q0: RealQuaternion) -> FrameFun2 = {
  def q = _mkRigidArmVar ();
  _mkRigidArm (q <~~ mkQuaternion q0) q world r
}

// def rigidArm1(world: Frame, r: RealVector3) -> FrameFun2 = {
//   def q = _mkRigidArmVar ();
//   _mkRigidArm NoEqn q world r
// }

type RigidArmFun = Frame -> RealVector3 -> FrameFun2

def _mkRigidArmFun(q0: RealQuaternion) -> RigidArmFun = {
  fun world: Frame -> fun r: RealVector3 -> rigidArm1(world, r, q0)
}

// def _mkRigidArmFun(t: ()) -> RigidArmFun = {
//   fun world: Frame -> fun r: RealVector3 -> rigidArm1(world, r)
// }

def _mkBar(world: Frame, m: Real, x: Real, y: Real, z: Real, c: Color, o: Real, bf: BodyFun, raf: RigidArmFun) -> FrameFun2 = {
  def fm: Frame;
  def Jd = mkCuboidInertia m x y z;
  fun fw: Frame -> fun fe: Frame ->
  // fw -- raf world (-x / 2., 0., 0.) -.- fm -.- raf world (x / 2., 0., 0.) -- fe
  raf world (-x / 2., 0., 0.) fw fm
  ++ raf world (x / 2., 0., 0.) fe fm
  ++ bf world m Jd (visualSolid (cuboid x y z) (stdMaterial c o)) fm
  ++ gravity1 world m fm
}

def bar1(world: Frame, m: Real, x: Real, y: Real, z: Real, c: Color, o: Real, q0: RealQuaternion) -> FrameFun2 = {
  _mkBar world m x y z c o (_mkBodyFun(q0)) (_mkRigidArmFun(q0))
}

// def bar1(world: Frame, m: Real, x: Real, y: Real, z: Real, c: Color, o: Real, x0: RealVector3) -> FrameFun2 = {
//   _mkBar world m x y z c o (_mkBodyFun(x0)) (_mkRigidArmFun ())
// }
