/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include DAELANGInterfaces
include DAELANG

def reinit: <Real> -> <Real> -> Equations
def switch: Equations -> Equations -> <Real> -> Equations

def M_ar(a: <Real>, f: VMap) -> Real = {
  def work(a: <?>) -> ? = {
    match a with
    | der x -> error "Only algebraic expressions allowed in M_ar"
    | sym: Real -> if (Map.mem a f) then (Map.find a f) else error "Undefined in M_ar"
    | a_1 a_2 ->  (work a_1 f) (work a_2 f)
    | lift op: ? -> op
    | _ ->  error "Unsupported model construct"
  };
  work a
}

def getzcb(s: Equations) -> Set(<Real>) = {
  def work(s: Equations, acc: Set(<Real>)) -> Set(<Real>) = {
    match s with
    | switch s_1 _ z -> work s_1 (Set.add z acc)
    | s_1; s_2 -> work s_1 (work s_2 acc)
    | _ -> acc
  };
  work s (Set.empty)
}

def zcdf(fb: VMap, fa: VMap, zcb: <Real>) -> Bool = {
  def bef = (M_ar zcb fb);
  def aft = (M_ar zcb fa);
  bef*aft < 0.
}

def haszc(zcb: Set(<Real>), z: (<Real> -> Bool)) -> Bool = {
  for_all (Set.toList zcb) z
}

def T_s(s: Equations, z: (<Real> -> Bool)) -> Equations = {
  match s with
  | s_1; s_2 -> (T_s s_1 z); (T_s s_2 z)
  | a_1 = a_2 -> s
  | init _ _ -> nil
  | reinit _ _ -> s
  | Branch _ _ _ _ -> s
  | RefBranch _ _ _ -> s
  | switch s_1 s_2 zcb -> if (z zcb) then s_2 else switch (T_s s_1 z) s_2 zcb
  | nil -> nil
  | _ -> error "Unmatched pattern in T_s"
}

def R_s(s: Equations, f: VMap) -> Equations = {
  match s with
  | s_1; s_2 -> (R_s s_1 f); (R_s s_2 f)
  | init x a -> {
        def r = M_ar a f;
        init x r
      }
  | reinit x a -> {
        def r = M_ar a f;
        init x r
      }
  | switch s_1 _ _ -> R_s s_1 f
  | a_1 = a_2 -> s
  | Branch _ _ _ _ -> s
  | RefBranch _ _ _ -> s
  | nil -> nil
  | _ -> error "Unmatched pattern in R_s"
}

def M_h(s: Equations, f: VMap, z: (<Real> -> Bool), t: Real) -> Omega = {
  if (Map.size f) == 0 then {
    def m = R_s s f;
    def (t_new, E, f_new) =  M_d m t;
    def Z = getzcb s;
    (s, t_new, E, f_new, Z)
  }
  else {
    def s_new = T_s s z;
    def Z = getzcb s_new;
    def (t_new, E, f_new) =  M_d (R_s s_new f) t;
    def z_new = zcdf f f_new;
    if haszc Z z_new then M_h s_new f_new z_new t_new
    else (s_new, t_new, E, f_new, Z)
  }
}
