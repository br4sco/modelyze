/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include DAELANGInterfaces
include DAELANG

def reinit: <Real> -> <Real> -> Equations
def switch: Equations -> Equations -> <Real> -> Equations

def M_ar(a: <?>, f: VMap) -> ? = {
  match a with
  | der x -> error "Only algebraic expressions allowed in M_ar"
  | sym: Real -> if (Map.mem a f) then (Map.find a f) else error "Undefined in M_ar"
  | a_1 a_2 ->  (M_ar a_1 f) (M_ar a_2 f)
  | lift op: ? -> op
  | _ ->  error "Unsupported model construct"
}

def getzcb(S: Equations) -> Set(<Real>) = {
  def work(S: Equations, acc: Set(<Real>)) -> Set(<Real>) = {
    match S with
    | switch s_1 _ z -> work s_1 (Set.add z acc)
    | s_1; s_2 -> work s_1 (work s_2 acc)
    | _ -> acc
  };
  work S (Set.empty)
}

def zcdf(fb: VMap, fa: VMap, zcb: <Real>) -> Bool = {
  def bef = (M_ar zcb fb);
  def aft = (M_ar zcb fa);
  bef*aft < 0.
}

def haszc(zcb: Set(Equations), z: (<Real> -> Bool)) -> Bool = {
  for_all (Set.toList zcb) z
}

def T_s(S: Equations, z: (<Real> -> Bool)) -> Equations = {
  match S with
  | s_1; s_2 -> (T_s s_1 z); (T_s s_2 z)
  | a_1 = a_2 -> S
  | init _ _ -> nil
  | reinit _ _ -> S
  | Branch _ _ _ _ -> S
  | RefBranch _ _ _ -> S
  | switch s_1 s_2 zcb -> if (z zcb) then s_2 else switch (T_s s_1 z) s_2 zcb
  | nil -> nil
  | _ -> error "Unmatched pattern in T_s"
}

def R_s(S: Equations, f: VMap) -> Equations = {
  match S with
  | s_1; s_2 -> (R_s s_1 f); (R_s s_2 f)
  | init x a -> {
        def r = M_ar a f;
        init x r
      }
  | reinit x a -> {
        def r = M_ar a f;
        init x r
      }
  | switch s_1 _ _ -> R_s s_1 f
  | a_1 = a_2 -> S
  | Branch _ _ _ _ -> S
  | RefBranch _ _ _ -> S
  | nil -> nil
  | _ -> error "Unmatched pattern in R_s"
}
