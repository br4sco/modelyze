/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include DAELANGInterfaces
include DAELANG

def reinit: <Real> -> <Real> -> Equations
def switch: Equations -> (() -> ?) -> <Real> -> Equations

def M_ar(a: <Real>, f: VMap) -> Real = {
  eval_from_vmap a f
}

def getzcb(s: Equations) -> Set(<Real>) = {
  def work(s: Equations, acc: Set(<Real>)) -> Set(<Real>) = {
    match s with
    | switch s_1 _ z -> work s_1 (Set.add z acc)
    | s_1; s_2 -> work s_1 (work s_2 acc)
    | _ -> acc
  };
  work s (Set.empty)
}

def zcdf(Z: Set(<Real>), fb: VMap, fa: VMap, zcb: <Real>) -> Bool = {
  if (Set.mem zcb Z) then {
    def bef = (eval_from_vmap zcb fb);
    def aft = (eval_from_vmap zcb fa);
    bef*aft < 0.
  } else false
}

def haszc(Z: Set(<Real>), z: (<Real> -> Bool)) -> Bool = {
  def b = exists z (Set.toList Z);
  b
}

def T_s(s: Equations, z: (<Real> -> Bool)) -> Equations = {
  def so = {match s with
  | s_1; s_2 -> (T_s s_1 z); (T_s s_2 z)
  | a_1 = a_2 -> s
  | init _ _ -> nil
  | reinit _ _ -> s
  | Branch _ _ _ _ -> s
  | RefBranch _ _ _ -> s
  | switch s_1 (lift s_2: (() -> ?)) zcb -> {
        if z zcb then o else switch (T_s s_1 z) s_2 zcb
      }
  | nil -> nil
  | _ -> error "Unmatched pattern in T_s"};
  so
}

def R_s(s: Equations, f: VMap) -> Equations = {
  match s with
  | s_1; s_2 -> (R_s s_1 f); (R_s s_2 f)
  | init x a -> {
        def r = M_ar a f;
        init x r
      }
  | reinit x a -> {
        def r = M_ar a f;
        init x r
      }
  | switch s_1 _ _ -> R_s s_1 f
  | a_1 = a_2 -> s
  | Branch _ _ _ _ -> s
  | RefBranch _ _ _ -> s
  | nil -> nil
  | _ -> error "Unmatched pattern in R_s"
}

def R_s_i(s: Equations) -> Equations = {
  match s with
  | reinit x a -> nil
  | s_1; s_2 -> (R_s_i s_1); (R_s_i s_2)
  | switch s_1 _ _ -> R_s_i s_1
  | _ -> s
}

def M_h(s: Equations, f: VMap, z: (<Real> -> Bool), t: Real) -> Omega = {
  if (Map.size f) == 0 then {
    def m = R_s (R_s_i s) f;
    def (t_new, E, f_new) =  M_d m t;
    def Z = getzcb s;
    (s, t_new, E, f_new, Z)
  }
  else {
    def s_new = T_s s z;
    def Z = getzcb s_new;
    def m = R_s s_new f;
    def (t_new, E, f_new) = M_d m t;
    def z_new = zcdf Z f f_new;
    if haszc Z z_new then {
      M_h s_new f_new z_new t_new
    } else (s_new, t_new, E, f_new, Z)
  }
}
