/*
Modeling Kernel Language (Modelyze) library 
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include DAELANGInterfaces
include DAELANG

def hinit: <Real> -> <Real> -> Equations
def hinit_guess: <Real> -> <Real> -> Equations
def reinit: <Real> -> <Real> -> Equations
def reinit_guess: <Real> -> <Real> -> Equations
def switch: Equations -> Equations -> <Real> -> Equations

def M_ar(a: <?>, f: (<Real> -> ?)) -> ? = {
  match a with
  | der x -> error "Only algebraic expressions allowed in M_ar"
  | sym: Real -> f a
  | a_1 a_2 -> {
        def lhs = (M_ar a_1 f);
        def rhs = (M_ar a_2 f);
        if (is_undefined lhs) || (is_undefined rhs) then undefined
        else lhs rhs
      }
  | lift op: ? -> op
  | _ ->  error "Unsupported model construct" 
}

def getzcb(S: Equations) -> Set(<Real>) = {
  def work(S: Equations, acc: Set(<Real>)) -> Set(<Real>) = {
    match S with
    | switch s_1 _ z -> work s_1 (Set.add z acc)
    | s_1; s_2 -> work s_1 (work s_2 acc)
    | _ -> acc
  };
  work S (Set.empty)
}

def zcdf(fb: (<Real> -> ?), fa: (<Real> -> ?), zcb: <Real>) -> Bool = {
  def bef = (M_ar zcb fb);
  def aft = (M_ar zcb fa);
  if (is_undefined bef) || (is_undefined aft) then false
  else bef*aft < 0.
}

def T_s(S: Equations, z: (<Real> -> Bool)) -> Equations = {
  match S with
  | s_1; s_2 -> (T_s s_1 z); (T_s s_2 z)
  | a_1 = a_2 -> S
  | hinit _ _ -> nil
  | hinit_guess _ _ -> nil
  | reinit _ _ -> S
  | reinit_guess _ _ -> S
  | Branch _ _ _ _ -> S
  | RefBranch _ _ _ -> S
  | switch s_1 s_2 zcb -> if (z zcb) then s_2 else switch (T_s s_1 z) s_2 zcb
  | nil -> nil
  | _ -> error "Unmatched pattern in T_s"
}

def R_s(S: Equations, f: (<Real> -> ?)) -> Equations = {
  match S with
  | s_1; s_2 -> (R_s s_1 f); (R_s s_2 f)
  | hinit x a -> {
        def r = M_ar a f;
        if is_undefined r then error "Undefined init value"
        else init x r
      }
  | hinit_guess x a -> {
        def r = M_ar a f;
        if is_undefined r then error "Undefined init guess value"
        else init_guess x r
      }
  | reinit x a -> {
        def r = M_ar a f;
        if is_undefined r then error "Undefined reinit value"
        else init x r
      }
  | reinit_guess x a -> {
        def r = M_ar a f;
        if is_undefined r then error "Undefined reinit guess value"
        else init_guess x r
      }
  | switch s_1 _ _ -> R_s s_1 f
  | a_1 = a_2 -> S
  | Branch _ _ _ _ -> S
  | RefBranch _ _ _ -> S
  | nil -> nil
  | _ -> error "Unmatched pattern in R_s"      
}

