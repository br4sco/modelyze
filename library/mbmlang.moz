/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Export

def SCENE_FILENAME = "/tmp/scene.json"

type Color = String

type Material
def stdMaterial: Color -> Real -> Material

type Geometry3D
def cuboid: Real -> Real -> Real -> Geometry3D
def sphere: Real -> Geometry3D

type VisualData
def visualSolid: Geometry3D -> Material -> VisualData
def visualAxes: Real -> VisualData

type ModelElement
def (++) : ModelElement -> ModelElement -> ModelElement
def visualElement: Vector3 -> Quaternion -> VisualData -> ModelElement
def equationsElement: Equations -> ModelElement
def NoElement: ModelElement

def visualElementPlanar(r: Vector3, th: <Real>, vd: VisualData) -> ModelElement = {
  def w, i, j, k: Real;
  def q = quat w i j k;
  equationsElement (w = cos(th / 2.); i = 0.; j = 0.; k = sin(th / 2.))
  ++ visualElement r q vd
}

def visualElementNoRotation(r: Vector3, vd: VisualData) -> ModelElement = {
  def w, i, j, k: Real;
  def q = quat w i j k;
  equationsElement (q ==. idq) ++ visualElement r q vd
}

type FrameFun1 = Frame -> ModelElement
type FrameFun2 = Frame -> Frame -> ModelElement

def inParallel(l: FrameFun2, r: FrameFun2, f_1: Frame, f_2: Frame) -> ModelElement = {
  l f_1 f_2 ++ r f_1 f_2
}
def (||) = inParallel

def inSeries(l: Frame, r: FrameFun1) -> ModelElement = {
  r l
}
def (--) = inSeries

def inSeries(l: FrameFun1, r: Frame) -> ModelElement = {
  l r
}
def (--) = inSeries

def inSeries(f: Frame, r: FrameFun2) -> FrameFun1 = {
  r f
}
def (--) = inSeries

def inSeries(l: FrameFun1, r: FrameFun2) = {
  def f_1: Frame;
  fun f_2: Frame -> l f_1 ++ r f_1 f_2
}
def (--) = inSeries

def inSeriesExposeFrame(l: FrameFun2, f_2: Frame) = {
  (l, f_2)
}
def (-.-) = inSeriesExposeFrame

def inSeriesExposeFrame(lf_2: (FrameFun2, Frame), r: FrameFun2) = {
  def (l, f_2) = lf_2;
  fun f_1: Frame -> fun f_3: Frame -> l f_1 f_2 ++ r f_2 f_3
}
def (-.-) = inSeriesExposeFrame

def inSeries(l: FrameFun2, r: FrameFun2) = {
  def f_2: Frame;
  fun f_1: Frame -> fun f_3: Frame -> l f_1 f_2 ++ r f_2 f_3
}
def (--) = inSeries

def WHITE = "#ffffff"
def RED = "#ff0000"
def BLUE = "#0000ff"
def GREEN = "#00ff00"
def BLACK = "#000000"

def real2JSONstring(r: Real) -> String = {
  if int2real (real2int r) == r then real2string r ++ "0"
  else real2string r
}

def geometry2JSON(g: Geometry3D) -> String = {
  match g with
  | cuboid (sval x: Real) (sval y: Real) (sval z: Real) -> "{ " ++
                                    "\"type\": \"Cuboid\", " ++
                                    "\"x\": " ++ real2JSONstring x ++ ", " ++
                                    "\"y\": " ++ real2JSONstring y ++ ", " ++
                                    "\"z\": " ++ real2JSONstring z ++
                                    " }"

  | sphere (sval r: Real) -> "{ " ++
                             "\"type\": \"Sphere\", " ++
                             "\"radius\": " ++ real2JSONstring r ++
                             " }"
  | _ -> error "Unmatched Geometry3D"
}

// def frameToJSON(rr: Vector3, th: <Real>, u: Real) -> String = {
//   "{ \"type\": Frame, \"units\": "   "}"
// }

def material2JSON(m: Material) -> String = {
  match m with
  | stdMaterial (sval s: String) (sval o: Real) -> {
      if o >= 0. && o <= 1. then {
        "{ " ++
        "\"type\": \"Standard\", " ++
        "\"color\": \"" ++ s ++ "\", " ++
        "\"opacity\": " ++ real2JSONstring o ++
        " }"
      } else error INVALID_ARGUMENT
    }
  | _ -> error "Unmatched Material"
}

def visualData2Json(d: VisualData) -> String = {
  match d with
  | visualSolid g m -> "{ \"type\": \"Solid\"," ++
                       "\"geometry\": " ++ geometry2JSON g ++ ", " ++
                       "\"material\": " ++ material2JSON m ++
                       " }"
  | visualAxes (sval s: Real) -> "{ \"type\": \"Axes\", " ++
                                 "\"size\": " ++ real2JSONstring s ++
                                 " }"
  | _ -> error "Unmatched visual data"
}

def visualElement2Json(o: ModelElement) -> String = {
  def work(o: ModelElement) -> String = {
    match o with
    | o_1 ++ o_2 -> work o_1 ++ ", " ++ work o_2
    | visualElement v q vd -> {
        match (v, q) with
        | (vec3 x y z, quat w i j k) -> {
                                      "{ " ++
                                      "\"xLabel\": \"" ++ symstr(x) ++ "\", " ++
                                      "\"yLabel\": \"" ++ symstr(y) ++ "\", " ++
                                      "\"zLabel\": \"" ++ symstr(z) ++ "\", " ++
                                      "\"wLabel\": \"" ++ symstr(w) ++ "\", " ++
                                      "\"iLabel\": \"" ++ symstr(i) ++ "\", " ++
                                      "\"jLabel\": \"" ++ symstr(j) ++ "\", " ++
                                      "\"kLabel\": \"" ++ symstr(k) ++ "\", " ++
                                      "\"data\": " ++ visualData2Json vd ++
                                      " }" }
        | _ -> { error ("Expected scalar unknowns, not: " ++ symstr(v) ++ ", " ++ symstr(q)) }
      }
    | _ -> { def _ = dprintln o; error "Expected only visualElement" }
  };
  "{ \"scene\": [ " ++ work o ++ " ] }"
}

def getVisualElements(o: ModelElement) -> ModelElement = {
  def work(o: ModelElement, a: ModelElement) -> ModelElement = {
    match o with
    | o_1 ++ o_2 -> work o_2 (work o_1 a)
    | visualElement _ _ _ -> a ++ o
    | _ -> a
  };
  work o NoElement
}

def cleanupModelElements(o: ModelElement) -> ModelElement = {
    match o with
    | o_1 ++ o_2 -> {
          match (cleanupModelElements o_1, cleanupModelElements o_2) with
          | (NoElement, NoElement) -> NoElement
          | (NoElement, o) -> o
          | (o, NoElement) -> o
          | (o_1b,o_2b) -> o_1b ++ o_2b
       }
    | _ -> o
}

def getModel(o: ModelElement) -> Equations = {
  def work(o: ModelElement, a: Equations) -> Equations = {
    match o with
    | o_1 ++ o_2 -> (work o_2 (work o_1 a))
    | equationsElement e -> a; e
    | _ -> a
  };
  work o NoEqn
}

def elaborateToFile(o: ModelElement) -> () = {
  def ukm = mkQuaternionUkMap o;
  def o = subs o ukm;
  def ukm = mkVector3UkMap o;
  def o = subs o ukm;

  // def ((sm, vm, qm), m) = elaborateWithSubstitutions (getModel o);
  // def vo = getVisualElements o;
  // def vo = cleanupModelElements (subs (subs vo qm) vm);

  def m = elaborate (getModel o);
  def vo = getVisualElements o;
  def vo = cleanupModelElements vo;

  def _ = export2ModelicaFile "Model" m;
  match vo with
  | NoElement -> ()
  | _ -> writeFile SCENE_FILENAME (visualElement2Json vo ++ "\n")
}

def rotationSensor1(q: Quaternion, f_1: Frame, f_2: Frame) -> ModelElement = {
  equationsElement (rotationSensor q f_1 f_2)
}

def translationSensor1(r: Vector3, f_1: Frame, f_2: Frame) -> ModelElement = {
  equationsElement (translationSensor r f_1 f_2)
}

type Body = Real -> RealVector3 -> FrameFun2

def _body1(m: Real, I: RealVector3, r: Vector3, q: Quaternion, world: Frame, f: Frame) -> ModelElement = {
  equationsElement (body m I r q world f)
}

def body1(r_0: RealVector3, q_0: RealQuaternion) -> Body = {
  fun m: Real -> fun I: RealVector3 -> fun world: Frame -> fun f_m: Frame -> {
    def r: Vector3;
    def q: Quaternion;
    _body1 m I r q world f_m ++ equationsElement (q ~==. mkQuat q_0; r ~== mkVec3 r_0)
  }
}

def body1(r_0: RealVector3) -> Body = {
  fun m: Real -> fun I: RealVector3 -> fun world: Frame -> fun f_m: Frame -> {
    def r: Vector3;
    def q: Quaternion;
    _body1 m I r q world f_m ++ equationsElement (norm2 q ~= 1.; r ~== mkVec3 r_0)
  }
}

def body1(q_0: RealQuaternion) -> Body = {
  fun m: Real -> fun I: RealVector3 -> fun world: Frame -> fun f_m: Frame -> {
     def r: Vector3;
     def q: Quaternion;
     _body1 m I r q world f_m ++ equationsElement (q ~==. mkQuat q_0)
   }
}

def body1(m: Real, I: RealVector3, world: Frame, f_m: Frame) -> ModelElement = {
  def r: Vector3;
  def q: Quaternion;
  _body1 m I r q world f_m ++ equationsElement (norm2 q ~= 1.)
}

def gravity1(m: Real, world: Frame, f: Frame) -> ModelElement = {
  equationsElement (gravity m world f)
}

def rigidArm1(r: RealVector3, world: Frame, f_1: Frame, f_2: Frame) -> ModelElement = {
  def r_1: Vector3;
  def q_2: Quaternion;
  equationsElement (rigidArm r r_1 q_2 world f_1 f_2)
}

def sphericalJoint1(f_1: Frame, f_2: Frame) -> ModelElement = {
  equationsElement (sphericalJoint f_1 f_2)
}

def rotationalDamper1(D: Real, f_1: Frame, f_2: Frame) -> ModelElement = {
  equationsElement (rotationalDamper D f_1 f_2)
}

def translation1(f: Vector3, f_1: Frame, f_2: Frame) -> ModelElement = {
  equationsElement (translation f f_1 f_2)
}

def visSolid1(g: Geometry3D, c: Color, opacity: Real, world: Frame, f: Frame) -> ModelElement = {
  def r: Vector3;
  def q: Quaternion;
  world -- (translationSensor1 r || rotationSensor1 q ) -- f ++
  visualElement r q (visualSolid g (stdMaterial c opacity))
}

def visSolidNonRot1(g: Geometry3D, c: Color, opacity: Real, world: Frame, f: Frame) -> ModelElement = {
  def r: Vector3;
  def q: Quaternion;
  world -- translationSensor1 r -- f ++ equationsElement (q ==. idq) ++
  visualElement r q (visualSolid g (stdMaterial c opacity))
}

def visAxes1(l: Real, world: Frame, f: Frame) -> ModelElement = {
  def r: Vector3;
  def q: Quaternion;
  world -- (translationSensor1 r || rotationSensor1 q ) -- f ++
  visualElement r q (visualAxes l)
}

type Arm = Frame -> Frame -> Frame -> ModelElement

def arm1(r_l: RealVector3, r_r: RealVector3, body: FrameFun2, world: Frame) -> Arm = {
  fun f_m: Frame -> fun f_l: Frame -> fun f_r: Frame -> {
    f_l -- rigidArm1 (r_l) world -.- f_m -.- rigidArm1 (-r_r) world -- f_r ++
    world -- body -- f_m
  }
}

type Bar = Real -> RealVector3 -> Frame -> Arm

def _bar1(body: Body, m: Real, xyz: RealVector3, world: Frame) -> Arm = {
  def (x, y, z) = xyz;
  arm1 (-x / 2., 0., 0.) (x / 2., 0., 0.) (body m (mkCuboidInertia m xyz)
        || gravity1 m
       ) world
}

def bar1(r_0: RealVector3, q_0: RealQuaternion, m: Real, xyz: RealVector3, world: Frame) -> Arm = {
  _bar1 (body1 r_0 q_0) m xyz world
}

def bar1(q_0: RealQuaternion, m: Real, xyz: RealVector3, world: Frame) -> Arm = {
  _bar1 (body1 q_0) m xyz world
}

def bar1(r_0: RealVector3, m: Real, xyz: RealVector3, world: Frame) -> Arm = {
  _bar1 (body1 r_0) m xyz world
}

def bar1(m: Real, xyz: RealVector3, world: Frame) -> Arm = { _bar1 body1 m xyz world }
