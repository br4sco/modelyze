/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include BasicEqsFormulation

type PlanarInitVars = (InitVal, InitVal, InitVal)
type PlanarVars = (<Real>, <Real>, <Real>)
type PlanarVals = (Real, Real, Real)

def getPlanarVars(v: PlanarInitVars) -> PlanarVars = {
  def ((v_1, _), (v_2, _), (v_3, _)) = v;
  (v_1, v_2, v_3)
}

def getPlanarVals(v: PlanarInitVars) -> PlanarVals = {
  def ((_, v_1), (_, v_2), (_, v_3)) = v;
  (v_1, v_2, v_3)
}

def mkZeroInitPlanarInitVars(v: PlanarVars) -> PlanarInitVars = {
  def (v_1, v_2, v_3) = v;
  ((v_1, 0.), (v_2, 0.), (v_3, 0.))
}

def  planarInitVarsToMatrix(v: PlanarInitVars)
  -> (MatrixMapSReal, MatrixMapReal) = {

  def ((v_1, v_1_0), (v_2, v_2_0), (v_3, v_3_0)) = v;
  (listToMatrix [[v_1], [v_2], [v_3]] (mmSRealZero (3, 1)),
   listToMatrix [[v_1_0], [v_2_0], [v_3_0]] (mmRealZero (3, 1)))
}

def mkTransMatrices(rxryt: PlanarVars) -> (TransFun, TransFun) = {
  def (rx, ry, t) = rxryt;
  def u: <Real> = 1.;
  def z: <Real> = 0.;

  def tf(mv: ModelVar) -> ModelVar = {
    def mv = hconcat mv (mmSRealId 1);
    def T = listToMatrix [
                          [cos t, -sin t, z, z],
                          [sin t,  cos t, z, z],
                          [z,      z,     u, z],
                          [z,      z,     z, u]
                         ] (mmSRealZero (4, 4));

    fst (hsplit 3 (T * mv))
  };

  def itf(mv: ModelVar) -> ModelVar = {
    def mv = hconcat mv (mmSRealId 1);
    def T = listToMatrix [
                          [cos t,  sin t, z, z],
                          [-sin t, cos t, z, z],
                          [z,      z,     u, z],
                          [z,      z,     z, u]
                         ] (mmSRealZero (4, 4));

    fst (hsplit 3 (T * mv))
  };

  (tf, itf)
}

def mkPlanarMechModelEdge(e: Edge,
  vxvyo: PlanarInitVars, rxryt_p: PlanarInitVars,rxryt: PlanarInitVars, FxFyT: PlanarInitVars,
  terminals: Res, derivatives: Res) -> VectorModelEdge = {

  def (tf, itf) = mkTransMatrices (getPlanarVars rxryt);
  def M_vxvyo = planarInitVarsToMatrix vxvyo;
  def M_rxryt_p = planarInitVarsToMatrix rxryt_p;
  def M_rxryt = planarInitVarsToMatrix rxryt;
  def M_FxFyT = planarInitVarsToMatrix FxFyT;
  (e, ([M_vxvyo, M_rxryt_p, M_rxryt], M_FxFyT), hconcat derivatives terminals, tf, itf)
}

def mkPlanarMechModelEdge(e: Edge,
  vxvyo: PlanarInitVars, rxryt: PlanarInitVars, FxFyT: PlanarInitVars,
  terminals: Res) -> VectorModelEdge = {
  def (rx, ry, t) = getPlanarVars rxryt;
  def (vx, vy, o) = getPlanarVars vxvyo;
  def (vx_0, vy_0, o_0) = getPlanarVals vxvyo;
  def rxryt_p = ((rx', vx_0), (ry', vy_0), (t', o_0));
  def derivatives = listToMatrix [[vx - rx'],
                                  [vy - ry'],
                                  [o - t']] (mmSRealZero (3, 1));
  mkPlanarMechModelEdge e vxvyo rxryt_p rxryt FxFyT terminals derivatives
}

// def mkPlanarMechModelEdge(e: Edge, rxryt: PlanarInitVars, FxFyT: PlanarInitVars,
//   terminals: Res) -> VectorModelEdge = {

//   def (tf, itf) = mkTransMatrices (getPlanarVars rxryt);
//   (e, ([planarInitVarsToMatrix rxryt],
//   planarInitVarsToMatrix FxFyT), terminals, tf, itf)
// }

def PlanarBody(m: Real, I: Real,
  vxvyo: PlanarInitVars, rxryt: PlanarInitVars, FxFyT: PlanarInitVars,
  e: Edge) -> [VectorModelEdge] = {

  def (vx, vy, o) = getPlanarVars vxvyo;
  def (Fx, Fy, T) = getPlanarVars FxFyT;
  def terminals = listToMatrix [[Fx - m * vx'],
                                [Fy - m * vy'],
                                [T - I * o']] (mmSRealZero (3, 1));
  [mkPlanarMechModelEdge e vxvyo rxryt FxFyT terminals]
}

def PlanarGravity(g: Real, e: Edge) -> [VectorModelEdge] = {
  def vx_g, vy_g, o_g, rx_g, ry_g, t_g, Fx_g, Fy_g, T_g: Real;
  def vxvyo = mkZeroInitPlanarInitVars (vx_g, vy_g, o_g);
  def rxryt = mkZeroInitPlanarInitVars (rx_g, ry_g, t_g);
  def FxFyT = ((Fx_g, 0.), (Fy_g, g), (T_g, 0.));
  def terminals = listToMatrix [[Fx_g],
                                [Fy_g - g],
                                [T_g]] (mmSRealZero (3, 1));
  [mkPlanarMechModelEdge e vxvyo rxryt FxFyT terminals]
}

def RotationalDrive(f: <Real>, f_0: Real, fp_0: Real, e: Edge)
  -> [VectorModelEdge] = {

  def vx_h, vy_h, o_h, rx_h, ry_h, t_h, Fx_h, Fy_h, T_h: Real;
  def vxvyo = ((vx_h, 0.), (vy_h, 0.), (o_h, fp_0));
  def rxryt = ((rx_h, 0.), (ry_h, 0.), (t_h, f_0));
  def FxFyT = mkZeroInitPlanarInitVars (Fx_h, Fy_h, T_h);
  def terminals = listToMatrix [[rx_h],
                                [ry_h],
                                [t_h - f]] (mmSRealZero (3, 1));
  [mkPlanarMechModelEdge e vxvyo rxryt FxFyT terminals]
}

def PlanarArm(l: Real,
  vxvyo_1: PlanarInitVars, rxryt_1: PlanarInitVars, FxFyT_1: PlanarInitVars,
  vxvyo_2: PlanarInitVars, rxryt_2: PlanarInitVars, FxFyT_2: PlanarInitVars,
  n_1: Node, n_2: Node, n_3: Node) -> [VectorModelEdge] = {

  def (rx_1, ry_1, o_1) = getPlanarVars rxryt_1;
  def (Fx_1, Fy_1, _) = getPlanarVars FxFyT_1;
  def (_, _, t_2) = getPlanarVars rxryt_2;
  def (Fx_2, Fy_2, T_2) = getPlanarVars FxFyT_2;

  def terminals_1 = listToMatrix [[rx_1 - l * cos t_2],
                                  [ry_1 - l * sin t_2],
                                  [o_1]] (mmSRealZero (3, 1));
  def terminals_2 =
    listToMatrix [[Fx_2],
                  [Fy_2],
                  [T_2 + l * cos t_2 * Fx_1 - l * sin t_2 * Fy_1]]
                  (mmSRealZero (3, 1));
  [mkPlanarMechModelEdge (n_2, n_3) vxvyo_1 rxryt_1 FxFyT_1 terminals_1,
   mkPlanarMechModelEdge (n_1, n_2) vxvyo_2 rxryt_2 FxFyT_2 terminals_2]
}

def PlanarArm(l: Real, t_0: Real, o_0: Real, n_1: Node, n_2: Node, n_3: Node)
  -> [VectorModelEdge] = {

  def vx_r1, vy_r1, o_r1, rx_r1, ry_r1, t_r1, Fx_r1, Fy_r1, T_r1: Real;
  def vx_r2, vy_r2, o_r2, rx_r2, ry_r2, t_r2, Fx_r2, Fy_r2, T_r2: Real;

  def vxvyo_1 = ((vx_r1, -o_0 * l * sin t_0), (vy_r1, o_0 * l * cos t_0), (o_r1, o_0));
  def rxryt_1 = ((rx_r1, l * cos t_0), (ry_r1, l * sin t_0), (t_r1, t_0));
  def FxFyT_1 = ((Fx_r1, 0.), (Fy_r1, 0.), (T_r1, 0.));

  def vxvyo_2 = ((vx_r2, 0.), (vy_r2, 0.), (o_r2, o_0));
  def rxryt_2 = ((rx_r2, 0.), (ry_r2, 0.), (t_r2, t_0));
  def FxFyT_2 = ((Fx_r2, 0.), (Fy_r2, 0.), (T_r2, 0.));

  PlanarArm l vxvyo_1 rxryt_1 FxFyT_1 vxvyo_2 rxryt_2 FxFyT_2 n_1 n_2 n_3
}
