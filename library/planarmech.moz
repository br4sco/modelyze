/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include BasicEqsFormulation

type PlanarInitVars = (InitVal, InitVal, InitVal)
type PlanarVars = (<Real>, <Real>, <Real>)
type PlanarVals = (Real, Real, Real)

def mkPlanarMechModelEdge(e: Edge, aatt: (ModelVarInit, ModelVarInit), terminal: Res)
  -> VectorModelEdge = {

  def ((aa, _), _) = aatt;
  def x = find (1, 1) aa;
  def y = find (2, 1) aa;
  def t = find (3, 1) aa;
  def u: <Real> = 1.;
  def z: <Real> = 0.;

  def tf(mv: ModelVar) -> ModelVar = {
    def mv = hconcat mv (mmSRealId 1);
    def T = listToMatrix [
                          [cos t, -sin t, z, z],
                          [sin t,  cos t, z, z],
                          [z,      z,     u, z],
                          [z,      z,     z, u]
                         ] (mmSRealZero (4, 4));

    fst (hsplit 3 (T * mv))
  };

  def itf(mv: ModelVar) -> ModelVar = {
    def mv = hconcat mv (mmSRealId 1);
    def T = listToMatrix [
                          [cos t,  sin t, z, z],
                          [-sin t, cos t, z, z],
                          [z,      z,     u, z],
                          [z,      z,     z, u]
                         ] (mmSRealZero (4, 4));

    fst (hsplit 3 (T * mv))
  };

  (e, aatt, terminal, tf, itf)
}

def mkZeroInitPlanarInitVars(v: PlanarVars) -> PlanarInitVars = {
  def (v_1, v_2, v_3) = v;
  ((v_1, 0.), (v_2, 0.), (v_3, 0.))
}


def  planarInitVarsToMatrix(v: PlanarInitVars) -> (MatrixMapSReal, MatrixMapReal) = {
  def ((v_1, v_1_0), (v_2, v_2_0), (v_3, v_3_0)) = v;
  (listToMatrix [[v_1], [v_2], [v_3]] (mmSRealZero (3, 1)),
   listToMatrix [[v_1_0], [v_2_0], [v_3_0]] (mmRealZero (3, 1)))
}

def getPlanarVars(v: PlanarInitVars) -> PlanarVars = {
  def ((v_1, _), (v_2, _), (v_3, _)) = v;
  (v_1, v_2, v_3)
}

def PlanarBody(m: Real, I: Real, rxryt: PlanarInitVars, FxFyT: PlanarInitVars, e: Edge)
  -> [VectorModelEdge] = {

  def (rx, ry, t) = getPlanarVars rxryt;
  def (Fx, Fy, T) = getPlanarVars FxFyT;
  def terminals = listToMatrix [[Fx - m * rx''], [Fy - m * ry''], [T - I * t'']] (mmSRealZero (3, 1));
  [mkPlanarMechModelEdge e (planarInitVarsToMatrix rxryt, planarInitVarsToMatrix FxFyT) terminals]
}

def PlanarGravity(g: Real, e: Edge) -> [VectorModelEdge] = {
  def rx_g, ry_g, t_g, Fx_g, Fy_g, T_g: Real;
  def rxryt = mkZeroInitPlanarInitVars (rx_g, ry_g, t_g);
  def FxFyT = ((Fx_g, 0.), (Fy_g, g), (T_g, 0.));
  def terminals = listToMatrix [[Fx_g], [Fy_g - g], [T_g]] (mmSRealZero (3, 1));
  [mkPlanarMechModelEdge e (planarInitVarsToMatrix rxryt, planarInitVarsToMatrix FxFyT) terminals]
}
