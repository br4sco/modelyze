/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Matrix
include Graph
include ModelyzeDAE

type Frame = Node

def sw(a: {Dyn}, i: Int, j: Int) -> () = {
  def n = (Array.length a);
  if i < n && 0 <= i && j < n && 0 <= j then {
    def t = (Array.get a i);
    def _ = (Array.set a i (Array.get a j));
    Array.set a j t
  } else error DIMENSION_MISSMATCH
}

def mapToIdx(l: [Dyn]) -> [Int] = {
  def f(i: Int, e: Dyn) -> Int = { i };
  mapi f l
}

def initGuess: <Real> -> Real -> Equations
def (<~) = initGuess

def initEq: <Real> -> <Real> -> Equations
def (~=) = initEq

type Vector3
def vec3: Real -> Real -> Real -> Vector3

type Quaternion
def quat: Real -> Real -> Real -> Real -> Quaternion

def scalarEdge: Node -> Node -> <Real> -> <Real> -> Equations
def translationEdge: Node -> Node -> Vector3 -> Vector3 -> Equations
def rotationEdge: Node -> Node -> Quaternion -> Vector3 -> Equations

type ModelEdge = (Edge, (Dyn, Dyn))
type ScalarEdge = (Edge, (<Real>, <Real>))
type Vector3Edge = (Edge, (Vector3, Vector3))
type QuaternionVector3Edge = (Edge, (Quaternion, Vector3))

def mkGraph(mes: [ModelEdge]) -> [Edge] = {
  map (fun me: ModelEdge -> fst me) mes
}

def mkVarsList(mes: [ModelEdge]) -> [(Dyn, Dyn)] = {
  map (fun me: ModelEdge -> snd me) mes
}

type InitVal = (<Real>, (Real, Bool))

def mkVec3 = fun t: () -> { def x, y, z: Real; vec3 x y z }
def mkQuat = fun t: () -> { def w, i, j, k: Real; quat w i j k }

def x_(v: Vector3) -> <Real> = {
  match v with
  | vec3 x _ _ -> x
  | _ -> error "Invalid Operand"
}

def y_(v: Vector3) -> <Real> = {
  match v with
  | vec3 _ y _ -> y
  | _ -> error "Invalid Operand"
}

def z_(v: Vector3) -> <Real> = {
  match v with
  | vec3 _ _ z -> z
  | _ -> error "Invalid Operand"
}

def w_(q: Quaternion) -> <Real> = {
  match q with
  | quat w _ _ _ -> w
  | _ -> error "Invalid Operand"
}

def i_(q: Quaternion) -> <Real> = {
  match q with
  | quat _ i _ _ -> i
  | _ -> error "Invalid Operand"
}

def j_(q: Quaternion) -> <Real> = {
  match q with
  | quat _ _ j _ -> j
  | _ -> error "Invalid Operand"
}

def k_(q: Quaternion) -> <Real> = {
  match q with
  | quat _ _ _ k -> k
  | _ -> error "Invalid Operand"
}

def eaa2q(x: <Real>, y: <Real>, z: <Real>, th: <Real>) -> Quaternion = {
  def c = (sin (th / 2.)) / (sqrt (x^2. + y^2. + z^2.));
  quat (cos (th / 2.)) (c * x) (c * y) (c * z)
}

def eaa2t(x: Real, y: Real, z: Real, th: Real) -> (Real, Real, Real, Real) = {
  def c = (sin (th / 2.)) / (sqrt (x^2. + y^2. + z^2.));
  (cos (th / 2.), c * x, c * y, c * z)
}

def sv32q(s: <Real>, v: Vector3) -> Quaternion = {
  match v with
  | vec3 x y z -> quat s x y z
  | _ -> error "Invalid Operand"
}

def v32q(v: Vector3) -> Quaternion = { sv32q 0. v }

def q2sv3(q: Quaternion) -> (<Real>, Vector3) = {
  match q with
  | quat w i j k -> (w, vec3 i j k)
  | _ -> error "Invalid Operand"
}

def conj(q: Quaternion) -> Quaternion = {
  match q with
  | quat w i j k -> quat w (-i) (-j) (-k)
  | _ -> error "Invalid Operand"
}

def quatProd(l: Quaternion, r: Quaternion) -> Quaternion = {
  match l with
  | quat p0 p1 p2 p3 -> {
      match r with
      | quat q0 q1 q2 q3 -> {
          quat (p0 * q0 - p1 * q1 - p2 * q2 - p3 * q3)
               (p0 * q1 + q0 * p1 + p2 * q3 - p3 * q2)
               (p0 * q2 + q0 * p2 + p3 * q1 - p1 * q3)
               (p0 * q3 + q0 * p3 + p1 * q2 - p2 * q1)
        }
      | _ -> error "Right operand invalid"
    }
  | _ -> error "Left operand invalid"
}

def crossProd(l: Vector3, r: Vector3) -> Vector3 = {
  match l with
  | vec3 lx ly lz -> {
      match r with
      | vec3 rx ry rz -> vec3 (ly * rz - lz * ry) (lx * rz - lz * rx) (lx * ry - ly * rx)
      | _ -> error "Right operand invalid"
    }
  | _ -> error "Left operand invalid"
}

def dotProd(l: Vector3, r: Vector3) -> <Real> = {
  match l with
  | vec3 lx ly lz -> {
      match r with
      | vec3 rx ry rz -> lx * rx + ly * ry + lz * rz
      | _ -> error "Right operand invalid"
    }
  | _ -> error "Left operand invalid"
}

def mkAngularVelocityEqs(om: Vector3, th: Quaternion) -> Equations = {
  match th with
  | quat w i j k -> {
      def r = quatProd (quat (2. * w') (2. * i') (2. * j') (2. * k')) (conj th);
      1. = w^2. + i^2. + j^2. + k^2.;
      // 0. = w_ r;
      x_ om = i_ r;
      y_ om = j_ r;
      z_ om = k_ r
    }
  | _ -> error "Right operand invalid"
}

def scalarProd(l: <Real>, r: Vector3) -> Vector3 = { vec3 (l * x_ r) (l * y_ r) (l * z_ r) }

def v3eq(l: Vector3, r: Vector3) -> Equations = { x_ l = x_ r; y_ l = y_ r; z_ l = z_ r }

def v3der(v: Vector3) -> Vector3 = { vec3 ((x_ v)') ((y_ v)') ((z_ v)') }

def qeq(l: Quaternion, r: Quaternion) -> Equations = {
// w_ l = w_ r;
i_ l = i_ r; j_ l = j_ r; k_ l = k_ r }

def v3init(v: Vector3, iv: (Real, Real, Real)) -> Equations = {
  def (x_0, y_0, z_0) = iv;
  x_ v <~ x_0; y_ v <~ y_0; z_ v <~ z_0
}

def qinit(q: Quaternion, iv: (Real, Real, Real, Real)) -> Equations = {
  def (w_0, i_0, j_0, k_0) = iv;
  w_ q <~ w_0; i_ q <- i_0; j_ q <- j_0; k_ q <- k_0
}

def getUknowns(m: Equations) -> [<Real>] = {
  def f(e: (<Real>, (Int, Bool))) -> <Real> = { fst e };
  map f (Map.toList (makeUkMap m))
}

def getScalarEdges(e: Equations) -> ([ScalarEdge], Equations) = {
  def work(e: Equations, a: ([ScalarEdge], Equations)) -> ([ScalarEdge], Equations)  = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | scalarEdge n_1 n_2 x y -> (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoEqn)
}

def getTranslationEdges(e: Equations) -> ([Vector3Edge], Equations) = {
  def work(e: Equations, a: ([Vector3Edge], Equations)) -> ([Vector3Edge], Equations) = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | translationEdge n_1 n_2 x y -> (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoEqn)
}

def getRotationEdges(e: Equations) -> ([QuaternionVector3Edge], Equations) = {
  def work(e: Equations, a: ([QuaternionVector3Edge], Equations)) -> ([QuaternionVector3Edge], Equations) = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | rotationEdge n_1 n_2 x y -> (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoEqn)
}

def getInits(e: Equations) -> ([InitVal], Equations) = {
  def work(e: Equations, a: ([InitVal], Equations)) -> ([InitVal], Equations)  = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | v <- v_0 -> {
        match (v, v_0) with
        | (v, lift v_0: Real) -> ((v, (v_0, true))::(fst a), snd a)
        | _ -> error "Invalid init"
      }
    | v <~ v_0 -> {
        match (v, v_0) with
        | (v, lift v_0: Real) -> ((v, (v_0, false))::(fst a), snd a)
        | _ -> error "Invalid init"
      }
    | l ~= r -> (fst a, snd a; l = r)
    | _ -> a
  };

  work e ([], NoEqn)
}

// def getEquations(e: Equations) -> (Equations, Equations) = {
//   def work(e: Equations, a: (Equations, Equations)) -> (Equations, Equations) = {
//     match e with
//     | e_1; e_2 -> ((fst a); e, snd a)
//     | _ -> (fst a, (snd a); e)
//   };
//   work e (NoEqn, NoEqn)
// }

def mkCutsetMatrix(mes: [ModelEdge]) -> (MatrixMapInt, (Dyn, Dyn)) = {
  def G = mkGraph mes;
  if hasSelfLoop G then error "Model graph contains self loop"
  else {
    def IM = mkIncidenceMatrix G;
    def _ = logg 2 "IM" (fun t: () -> def _ = dp IM; ());
    def _ = logg 2 "(x, y)" (loggprint (mkVarsList mes));

    def vs = listToArray (mkVarsList mes);

    def work(i: Int, a: MatrixMapInt) -> MatrixMapInt = {
      if i > rdim a then a
      else {
        def j_max = snd (argfind (fun v: Int -> v != 0)
                      (sub (i, 1) (i, cdim a) a));
        if i == j_max then work (i + 1) a
        else {
          def _ = sw vs (i - 1) (j_max - 1);
          work (i + 1) (swcols i j_max a)
        }
      }
    };

    def IMrr = rowreduce IM;
    def _ = logg 2 "IMrr" (fun t: () -> def _ = dp IMrr; ());

    def IMrrt = trimrows IMrr;
    def _ = logg 2 "IMrrt" (fun t: () -> def _ = dp IMrrt; ());

    if rdim IMrrt > cdim IMrrt then error BAD_MATRIX
    else {
      def IA = work 1 (real2int IMrrt);
      def _ = logg 2 "IA" (fun t: () -> def _ = dp IA; ());

      def (I, A) = vsplit (rdim IA) IA;
      def T = (if dim A < (1, 1) then arrayToList vs
               else arrayToList (sub vs 0 (rdim A)));
      def C = (if dim A < (1, 1) then []
               else arrayToList (sub vs (rdim A) (Array.length vs)));
      (A, (T, C))
    }
  }
}

def mkTopolRes(bop: (Int -> Dyn -> Dyn -> Dyn), C: MatrixMapInt,
  pvs: [Dyn], svs: [Dyn]) -> [Dyn] = {

  def ipvs = zip (mapToIdx pvs) pvs;
  def jsvs = zip (mapToIdx svs) svs;

  map (fun ipv: (Int, Dyn) -> {
        def (i, pv) = ipv;

        def f(a: Dyn, jsv: (Int, Dyn)) -> Dyn = {
          def (j, sv) = jsv;
          def c = find (i + 1, j + 1) C;
          if c == 0 then a else bop c a sv
        };

        foldLeft f pv jsvs

      }) ipvs
}

def mkScalarTopolEquations(C: MatrixMapInt, pvs: [<Real>], svs: [<Real>], a: Equations) -> Equations = {
  def bop(c: Int, l: <Real>, r: <Real>) -> <Real> = { l + (int2real c) * r };
  def rs = mkTopolRes bop C pvs svs;

  def work(rs: [<Real>], a: Equations) -> Equations = {
    match rs with
    | [] -> a
    | r::rs -> work rs (a; r = 0.)
    | _ -> error "Unmatched"
  };

  work rs a
}

def mkVector3TopolEquations(C: MatrixMapInt, pvs: [Vector3], svs: [Vector3], a: Equations)
  -> Equations = {
  def bop(c: Int, l: Vector3, r: Vector3) -> Vector3 = {
    def c = int2real c;
    vec3 (x_ l + c * x_ r) (y_ l + c * y_ r) (z_ l + c * z_ r)
  };
  def rs = mkTopolRes bop C pvs svs;

  def work(rs: [Vector3], a: Equations) -> Equations = {
    match rs with
    | [] -> a
    | r::rs -> work rs (a; x_ r = 0.; y_ r = 0.; z_ r = 0.)
    | _ -> error "Unmatched"
  };

  work rs a
}

def mkQuaternionTopolEquations(C: MatrixMapInt, pvs: [Quaternion], svs: [Quaternion], a: Equations)
  -> Equations = {
  def bop(c: Int, l: Quaternion, r: Quaternion) -> Quaternion = {
    if c == 1 then {
      quatProd l r
    } else if c == -1 then {
      quatProd l (conj r)
    } else error "Expected non-zero matrix elements to be -1 or 1"
  };
  def rs = mkTopolRes bop C pvs svs;

  def work(rs: [Quaternion], a: Equations) -> Equations = {
    match rs with
    | [] -> a
    | r::rs -> work rs (a; w_ r = 1.; i_ r = 0.; j_ r = 0.; k_ r = 0.)
    | _ -> error "Unmatched"
  };

  work rs a
}

type ResidualFunction = MatrixMapInt -> [Dyn] -> [Dyn] -> Equations -> Equations
def mkTopolEquations(f_a: ResidualFunction, f_t: ResidualFunction, mes: [ModelEdge], a: Equations) -> Equations = {
  def (A, (T, C)) = mkCutsetMatrix mes;
  def _ = logg 2 "A" (fun t: () -> def _ = dp A; ());

  def (x_t, y_t) = unzip T;
  def (x_c, y_c) = unzip C;

  def _ = logg 2 "x_t" (loggprint x_t);
  def _ = logg 2 "x_c" (loggprint x_c);

  f_t A y_t y_c (f_a (- (tr A)) x_c x_t a)
}

def elaborate(e: Equations) -> Equations = {
  def (ses, e) = getScalarEdges e;
  def (tes, e) = getTranslationEdges e;
  def (res, e) = getRotationEdges e;
  def e = (if isEmpty ses then e else mkTopolEquations mkScalarTopolEquations mkScalarTopolEquations ses e);
  def e = (if isEmpty tes then e else mkTopolEquations mkVector3TopolEquations mkVector3TopolEquations tes e);
  def e = (if isEmpty res then e else mkTopolEquations mkQuaternionTopolEquations mkVector3TopolEquations res e);
  cleanupEquations e
}

def GRAVITATIONAL_CONSTANT = 9.81

def Clock(t_0: Real, t: <Real>) = {
  t <- t_0;
  t' <- 1.;
  t' = 1.
}

def ForceActuator(f: Vector3, r: Vector3, f_1: Frame, f_2: Frame) -> Equations = {
  def Fx_a, Fy_a, Fz_a: Real;
  def F = vec3 Fx_a Fy_a Fz_a;
  translationEdge f_1 f_2 r F;
  v3eq F f
}

def ForceActuator(f: Vector3, f_1: Frame, f_2: Frame) -> Equations = {
  def x_a, y_a, z_a: Real;
  ForceActuator f (vec3 x_a y_a z_a) f_1 f_2
}

def TranslationActuator(f: Vector3, F: Vector3, f_1: Frame, f_2: Frame) -> Equations = {
  def x_a, y_a, z_a: Real;
  def r = vec3 x_a y_a z_a;
  translationEdge f_1 f_2 r F;
  v3eq r f
}

def TranslationActuator(f: Vector3, f_1: Frame, f_2: Frame) -> Equations = {
  def Fx_a, Fy_a, Fz_a: Real;
  TranslationActuator f (vec3 Fx_a Fy_a Fz_a) f_1 f_2
}

def RotationActuator(f: Quaternion, T: Vector3, f_1: Frame, f_2: Frame) -> Equations = {
  def w_a, i_a, j_a, k_a: Real;
  def th = quat w_a i_a j_a k_a;
  rotationEdge f_1 f_2 th T;
  qeq th f
}

def RotationActuator(f: Quaternion, f_1: Frame, f_2: Frame) -> Equations = {
  def Tx_a, Ty_a, Tz_a: Real;
  RotationActuator f (vec3 Tx_a Ty_a Tz_a) f_1 f_2
}

// def RotationVelocityActuator(f: Vector3, T: Vector3, f_1: Frame, f_2: Frame) -> Equations = {
//   def omx_a, omy_a, omz_a: Real;
//   def om = vec3 omx_a omy_a omz_a;
//   rotationEdge f_1 f_2 om T;
//   v3eq om f
// }

// def RotationVelocityActuator(f: Vector3, f_1: Frame, f_2: Frame) -> Equations = {
//   def Tx_a, Ty_a, Tz_a: Real;
//   RotationVelocityActuator f (vec3 Tx_a Ty_a Tz_a) f_1 f_2
// }

def TorqueActuator(f: Vector3, th: Quaternion, f_1: Frame, f_2: Frame) -> Equations = {
  def Tx_a, Ty_a, Tz_a: Real;
  def T = vec3 Tx_a Ty_a Tz_a;
  rotationEdge f_1 f_2 th T;
  v3eq T f
}

def TorqueActuator(f: Vector3, f_1: Frame, f_2: Frame) -> Equations = {
  def w_a, i_a, j_a, k_a: Real;
  TorqueActuator f (quat w_a i_a j_a k_a) f_1 f_2
}

def TranslationSensor(r: Vector3, f_1: Frame, f_2: Frame) -> Equations = {
  ForceActuator (vec3 0. 0. 0.) r f_1 f_2
}

def RotationSensor(th: Quaternion, f_1: Frame, f_2: Frame) -> Equations = {
  TorqueActuator (vec3 0. 0. 0.) th f_1 f_2
}

// def RotationVelocityController(om: Vector3, f_1: Frame, f_2: Frame) -> Equations = {
//   RotationVelocityActuator om (vec3 0. 0. 0.) f_1 f_2
// }

def Body(m: Real, I: (Real, Real, Real), DATUM: Frame, f: Frame) -> Equations = {
  def (I_xx, I_yy, I_zz) = I;
  def x_m, y_m, z_m, vx_m, vy_m, vz_m, Fx_m, Fy_m, Fz_m: Real;
  def w_m, i_m, j_m, k_m, omx_m, omy_m, omz_m, Tx_m, Ty_m, Tz_m: Real;
  def r = vec3 x_m y_m z_m;
  def v = vec3 vx_m vy_m vz_m;
  def F = vec3 Fx_m Fy_m Fz_m;
  def th = quat w_m i_m j_m k_m;
  def om = vec3 omx_m omy_m omz_m;
  def T = vec3 Tx_m Ty_m Tz_m;

  rotationEdge DATUM f th T;
  translationEdge DATUM f r F;
  mkAngularVelocityEqs om th;
  v3eq (v3der r) v;

  x_ F = m * (x_ v)';
  y_ F = m * (y_ v)';
  z_ F = m * (z_ v)';

  x_ T = (I_xx * (x_ om)' + (I_zz - I_yy) * y_ om * z_ om);
  y_ T = (I_yy * (y_ om)' + (I_xx - I_zz) * z_ om * x_ om);
  z_ T = (I_zz * (z_ om)' + (I_yy - I_xx) * x_ om * y_ om)
}

def Gravity(m: Real, DATUM: Frame, f: Frame) -> Equations = {
  ForceActuator (vec3 0. (m * GRAVITATIONAL_CONSTANT) 0.) DATUM f
}

def SphericalJoint(f_1: Frame, f_2: Frame) -> Equations = {
  TranslationActuator (vec3 0. 0. 0.) f_1 f_2
}

// def RigidArm(x: Real, y: Real, z: Real, DATUM: Frame, f_1: Frame, f_2: Frame) -> Equations = {
//   def x_r1, y_r1, z_r1, vx_r1, vy_r1, vz_r1, Fx_r1, Fy_r1, Fz_r1: Real;
//   def r_1 = vec3 x_r1 y_r1 z_r1;
//   def v_1 = vec3 vx_r1 vy_r1 vz_r1;
//   def F_1 = vec3 Fx_r1 Fy_r1 Fz_r1;

//   def w_r1, i_r1, j_r1, k_r1, omx_r1, omy_r1, omz_r1, Tx_r1, Ty_r1, Tz_r1: Real;
//   def th_1 = quat w_r1 i_r1 j_r1 k_r1;
//   def om_1 = vec3 omx_r1 omy_r1 omz_r1;
//   def T_1 = vec3 Tx_r1 Ty_r1 Tz_r1;

//   def w_r2, i_r2, j_r2, k_r2, omx_r2, omy_r2, omz_r2, Tx_r2, Ty_r2, Tz_r2: Real;
//   def th_2 = quat w_r2 i_r2 j_r2 k_r2;
//   def om_2 = vec3 omx_r2 omy_r2 omz_r2;
//   def T_2 = vec3 Tx_r2 Ty_r2 Tz_r2;

//   def om_X_r = crossProd om_2 r_1;
//   def r_X_F = crossProd r_1 F_1;

//   translationEdge f_1 f_2 r_1 F_1;
//   rotationEdge f_1 f_2 om_1 T_1;
//   rotationEdge DATUM f_1 om_2 T_2;

//   mkAngularVelocityEqs om_1 th_1;
//   mkAngularVelocityEqs om_2 th_2;

//   v3eq r_1 (vec3 x y z);
//   v3eq v_1 om_X_r;
//   v3eq om_1 (vec3 0. 0. 0.);
//   x_ T_1 = -(x_ r_X_F);
//   y_ T_1 = -(y_ r_X_F);
//   z_ T_1 = -(z_ r_X_F)
// }
