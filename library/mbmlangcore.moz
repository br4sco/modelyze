/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Graph
include Quaternion

type Frame = Node

def sw(a: {Dyn}, i: Int, j: Int) -> () = {
  def n = (Array.length a);
  if i < n && 0 <= i && j < n && 0 <= j then {
    def t = (Array.get a i);
    def _ = (Array.set a i (Array.get a j));
    Array.set a j t
  } else error DIMENSION_MISSMATCH
}

def mapToIdx(l: [Dyn]) -> [Int] = {
  def f(i: Int, e: Dyn) -> Int = { i };
  mapi f l
}

def scalarEdge: Node -> Node -> <Real> -> <Real> -> Equations
def translationEdge: Node -> Node -> Vector3 -> Vector3 -> Equations
def rotationEdge: Node -> Node -> Vector3 -> Vector3 -> Equations

type ModelEdge = (Edge, (Dyn, Dyn))
type ScalarEdge = (Edge, (<Real>, <Real>))
type Vector3Edge = (Edge, (Vector3, Vector3))

def mkGraph(mes: [ModelEdge]) -> [Edge] = {
  map (fun me: ModelEdge -> fst me) mes
}

def mkVarsList(mes: [ModelEdge]) -> [(Dyn, Dyn)] = {
  map (fun me: ModelEdge -> snd me) mes
}

def getScalarEdges(e: Equations) -> ([ScalarEdge], Equations) = {
  def work(e: Equations, a: ([ScalarEdge], Equations)) -> ([ScalarEdge], Equations)  = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | scalarEdge n_1 n_2 x y -> (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoEqn)
}

def getTranslationEdges(e: Equations) -> ([Vector3Edge], Equations) = {
  def work(e: Equations, a: ([Vector3Edge], Equations)) -> ([Vector3Edge], Equations) = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | translationEdge n_1 n_2 x y -> (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoEqn)
}

def getRotationEdges(e: Equations) -> ([Vector3Edge], Equations) = {
  def work(e: Equations, a: ([Vector3Edge], Equations)) -> ([Vector3Edge], Equations) = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | rotationEdge n_1 n_2 x y -> (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoEqn)
}

def mkCutsetMatrix(mes: [ModelEdge]) -> (MatrixMapInt, (Dyn, Dyn)) = {
  def G = mkGraph mes;
  if hasSelfLoop G then error "Model graph contains self loop"
  else {
    def IM = mkIncidenceMatrix G;
    def _ = logg 2 "IM" (fun t: () -> def _ = dp IM; ());
    def _ = logg 2 "(x, y)" (loggprint (mkVarsList mes));

    def vs = listToArray (mkVarsList mes);

    def work(i: Int, a: MatrixMapInt) -> MatrixMapInt = {
      if i > rdim a then a
      else {
        def j_max = snd (argfind (fun v: Int -> v != 0)
                      (sub (i, 1) (i, cdim a) a));
        if i == j_max then work (i + 1) a
        else {
          def _ = sw vs (i - 1) (j_max - 1);
          work (i + 1) (swcols i j_max a)
        }
      }
    };

    def IMrr = rowreduce IM;
    def _ = logg 2 "IMrr" (fun t: () -> def _ = dp IMrr; ());

    def IMrrt = trimrows IMrr;
    def _ = logg 2 "IMrrt" (fun t: () -> def _ = dp IMrrt; ());

    if rdim IMrrt > cdim IMrrt then error BAD_MATRIX
    else {
      def IA = work 1 (real2int IMrrt);
      def _ = logg 2 "IA" (fun t: () -> def _ = dp IA; ());

      def (I, A) = vsplit (rdim IA) IA;
      def T = (if dim A < (1, 1) then arrayToList vs
               else arrayToList (sub vs 0 (rdim A)));
      def C = (if dim A < (1, 1) then []
               else arrayToList (sub vs (rdim A) (Array.length vs)));
      (A, (T, C))
    }
  }
}

def mkTopolRes(bop: (Int -> Dyn -> Dyn -> Dyn), C: MatrixMapInt,
  pvs: [Dyn], svs: [Dyn]) -> [Dyn] = {

  def ipvs = zip (mapToIdx pvs) pvs;
  def jsvs = zip (mapToIdx svs) svs;

  map (fun ipv: (Int, Dyn) -> {
        def (i, pv) = ipv;

        def f(a: Dyn, jsv: (Int, Dyn)) -> Dyn = {
          def (j, sv) = jsv;
          def c = find (i + 1, j + 1) C;
          if c == 0 then a else bop c a sv
        };

        foldLeft f pv jsvs

      }) ipvs
}

def mkScalarTopolEquations(C: MatrixMapInt, pvs: [<Real>], svs: [<Real>], a: Equations) -> Equations = {
  def bop(c: Int, l: <Real>, r: <Real>) -> <Real> = { l + (int2real c) * r };
  def rs = mkTopolRes bop C pvs svs;

  def work(rs: [<Real>], a: Equations) -> Equations = {
    match rs with
    | [] -> a
    | r::rs -> work rs (a; r = 0.)
    | _ -> error "Unmatched"
  };

  work rs a
}

def mkVector3TopolEquations(C: MatrixMapInt, pvs: [Vector3], svs: [Vector3], a: Equations)
  -> Equations = {
  def bop(c: Int, l: Vector3, r: Vector3) -> Vector3 = {
    def c = int2real c;
    // vec3 (x_ l + c * x_ r) (y_ l + c * y_ r) (z_ l + c * z_ r)
    l + c * r
  };
  def rs = mkTopolRes bop C pvs svs;

  def work(rs: [Vector3], a: Equations) -> Equations = {
    match rs with
    | [] -> a
    // | r::rs -> work rs (a; x_ r = 0.; y_ r = 0.; z_ r = 0.)
    | r::rs -> work rs (a; r == zero)
    | _ -> error "Unmatched"
  };

  work rs a
}

type ResidualFunction = MatrixMapInt -> [Dyn] -> [Dyn] -> Equations -> Equations
def mkTopolEquations(f_a: ResidualFunction, f_t: ResidualFunction, mes: [ModelEdge], a: Equations) -> Equations = {
  def (A, (T, C)) = mkCutsetMatrix mes;
  def _ = logg 2 "A" (fun t: () -> def _ = dp A; ());

  def (x_t, y_t) = unzip T;
  def (x_c, y_c) = unzip C;

  def _ = logg 2 "x_t" (loggprint x_t);
  def _ = logg 2 "x_c" (loggprint x_c);

  f_t A y_t y_c (f_a (- (tr A)) x_c x_t a)
}

def elaborate(e: Equations) -> Equations = {
  def (ses, e) = getScalarEdges e;
  def (tes, e) = getTranslationEdges e;
  def (res, e) = getRotationEdges e;
  def e = (if isEmpty ses then e else mkTopolEquations mkScalarTopolEquations mkScalarTopolEquations ses e);
  def e = (if isEmpty tes then e else mkTopolEquations mkVector3TopolEquations mkVector3TopolEquations tes e);
  def e = (if isEmpty res then e else mkTopolEquations mkVector3TopolEquations mkVector3TopolEquations res e);
  e
}

def GRAVITATIONAL_CONSTANT = 9.81

def Clock(t_0: Real, t: <Real>) = {
  t <- t_0;
  t' <- 1.;
  t' = 1.
}

def TorqueActuator(f: Vector3, q: Quaternion, f_1: Frame, f_2: Frame) -> Equations = {
  def T_a, om_a: Vector3;
  norm2 q ~= 1.;
  rotationEdge f_1 f_2 om_a T_a;
  q' ==. 0.5 * (q_ om_a) * q;
  T_a == f
}

def TorqueActuator(f: Vector3, f_1: Frame, f_2: Frame) -> Equations = {
  def q_a: Quaternion;
  TorqueActuator f q_a f_1 f_2
}

def ForceActuator(f: Vector3, r: Vector3, f_1: Frame, f_2: Frame) -> Equations = {
  def F_a: Vector3;
  translationEdge f_1 f_2 r F_a;
  F_a == f
}

def ForceActuator(f: Vector3, f_1: Frame, f_2: Frame) -> Equations = {
  def r_a: Vector3;
  ForceActuator f r_a f_1 f_2
}

def TranslationActuator(f: Vector3, F: Vector3, f_1: Frame, f_2: Frame) -> Equations = {
  def r_a: Vector3;
  translationEdge f_1 f_2 r_a F;
  r_a == f
}

def TranslationActuator(f: Vector3, f_1: Frame, f_2: Frame) -> Equations = {
  def F_a: Vector3;
  TranslationActuator f F_a f_1 f_2
}

def RotationSensor(q: Quaternion, f_1: Frame, f_2: Frame) -> Equations = {
  TorqueActuator zero q f_1 f_2
}

def TranslationSensor(r: Vector3, f_1: Frame, f_2: Frame) -> Equations = {
  ForceActuator zero r f_1 f_2
}

def Body(m: Real, I: (Real, Real, Real), DATUM: Frame, f: Frame) -> Equations = {
  def (I_xx, I_yy, I_zz) = I;
  def I = vec3 I_xx I_yy I_zz;
  def r_m, v_m, F_m, om_m, T_m: Vector3;
  def q_m: Quaternion;
  // def vx, vy, vz: Real;
  // def v_m = vec3 vx vy vz;
  // vx <- 5.;
  norm2 q_m ~= 1.;
  translationEdge DATUM f r_m F_m;
  rotationEdge DATUM f om_m T_m;
  r_m' == v_m;
  F_m == m * v_m';
  q_m' ==. 0.5 * (q_ om_m) * q_m;
  T_m == I *. om_m' + cross om_m (I *. om_m)
}

def Gravity(m: Real, DATUM: Frame, f: Frame) -> Equations = {
  ForceActuator (m * GRAVITATIONAL_CONSTANT * jj) DATUM f
}

def SphericalJoint(f_1: Frame, f_2: Frame) -> Equations = {
  TranslationActuator zero f_1 f_2
}

def RigidArm(r: (Real, Real, Real), DATUM: Frame, f_1: Frame, f_2: Frame) -> Equations = {
  def (rx, ry, rz) = r;
  def r_r1, F_r1, om_r1, T_r1, om_r2, T_r2: Vector3;
  def q_r1, q_r2: Quaternion;
  norm2 q_r1 ~= 1.;
  norm2 q_r2 ~= 1.;
  translationEdge f_2 f_1 r_r1 F_r1;
  rotationEdge f_2 f_1 om_r1 T_r1;
  rotationEdge DATUM f_2 om_r2 T_r2;
  r_r1 == L q_r2 (vec3 rx ry rz);
  q_r1' ==. 0.5 * (q_ om_r1) * q_r1;
  om_r1 == zero;
  q_r2' ==. 0.5 * (q_ om_r2) * q_r2;
  T_r2 == cross (-r_r1) F_r1
}
