/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Graph
include Quaternion

def ERROR_UNIT_QUATERNION = "Expected unit quaternion"

type Frame = Node

def sw(a: {Dyn}, i: Int, j: Int) -> () = {
  def n = (Array.length a);
  if i < n && 0 <= i && j < n && 0 <= j then {
    def t = (Array.get a i);
    def _ = (Array.set a i (Array.get a j));
    Array.set a j t
  } else error DIMENSION_MISSMATCH
}

def mapToIdx(l: [Dyn]) -> [Int] = {
  def f(i: Int, e: Dyn) -> Int = { i };
  mapi f l
}

def electricalEdge: Node -> Node -> <Real> -> <Real> -> Equations
def planarRotationEdge: Node -> Node -> <Real> -> <Real> -> Equations
def translationEdge: Node -> Node -> Vector3 -> Vector3 -> Equations
def angularVelocityEdge: Node -> Node -> Vector3 -> Vector3 -> Equations
def rotationEdge: Node -> Node -> Quaternion -> Vector3 -> Equations

type ModelEdge = (Edge, (Dyn, Dyn))
type ScalarEdge = (Edge, (<Real>, <Real>))
type Vector3Edge = (Edge, (Vector3, Vector3))
type QuaternionVector3Edge = (Edge, (Quaternion, Vector3))

def mkGraph(mes: [ModelEdge]) -> [Edge] = {
  map (fun me: ModelEdge -> fst me) mes
}

def mkVarsList(mes: [ModelEdge]) -> [(Dyn, Dyn)] = {
  map (fun me: ModelEdge -> snd me) mes
}

def getElectricalEdges(e: Equations) -> ([ScalarEdge], Equations) = {
  def work(e: Equations, a: ([ScalarEdge], Equations)) -> ([ScalarEdge], Equations)  = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | electricalEdge n_1 n_2 x y -> (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoEqn)
}

def getPlanarRotationEdges(e: Equations) -> ([ScalarEdge], Equations) = {
  def work(e: Equations, a: ([ScalarEdge], Equations)) -> ([ScalarEdge], Equations)  = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | planarRotationEdge n_1 n_2 x y -> (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoEqn)
}

def getTranslationEdges(e: Equations) -> ([Vector3Edge], Equations) = {
  def work(e: Equations, a: ([Vector3Edge], Equations)) -> ([Vector3Edge], Equations) = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | translationEdge n_1 n_2 x y -> (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoEqn)
}

def getAngularVelocityEdges(e: Equations) -> ([Vector3Edge], Equations) = {
  def work(e: Equations, a: ([Vector3Edge], Equations)) -> ([Vector3Edge], Equations) = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | angularVelocityEdge n_1 n_2 x y -> (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoEqn)
}

def getRotationEdges(e: Equations) -> ([QuaternionVector3Edge], Equations) = {
  def work(e: Equations, a: ([QuaternionVector3Edge], Equations)) -> ([QuaternionVector3Edge], Equations) = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | rotationEdge n_1 n_2 x y -> (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoEqn)
}

def mkCutsetMatrix(mes: [ModelEdge]) -> (MatrixMapInt, (Dyn, Dyn)) = {
  if isEmpty mes then error "Edge list empty" else {
    def G = mkGraph mes;
    if hasSelfLoop G then error "Model graph contains self loop"
    else {
      def IM = mkIncidenceMatrix G;
      def _ = logg 2 "IM" (fun t: () -> def _ = dp IM; ());
      def _ = logg 2 "(x, y)" (loggprint (mkVarsList mes));

      def vs = listToArray (mkVarsList mes);

      def work(i: Int, a: MatrixMapInt) -> MatrixMapInt = {
        if i > rdim a then a
        else {
          def j_max = snd (argfind (fun v: Int -> v != 0)
                        (sub (i, 1) (i, cdim a) a));
          if i == j_max then work (i + 1) a
          else {
            def _ = sw vs (i - 1) (j_max - 1);
            work (i + 1) (swcols i j_max a)
          }
        }
      };

      def IMrr = rowreduce IM;
      def _ = logg 2 "IMrr" (fun t: () -> def _ = dp IMrr; ());

      def IMrrt = trimrows IMrr;
      def _ = logg 2 "IMrrt" (fun t: () -> def _ = dp IMrrt; ());

      if rdim IMrrt > cdim IMrrt then error BAD_MATRIX
      else {
        def IA = work 1 (real2int IMrrt);
        def _ = logg 2 "IA" (fun t: () -> def _ = dp IA; ());

        def (I, A) = vsplit (rdim IA) IA;
        def T = (if dim A < (1, 1) then arrayToList vs
                 else arrayToList (sub vs 0 (rdim A)));
        def C = (if dim A < (1, 1) then []
                 else arrayToList (sub vs (rdim A) (Array.length vs)));
        (A, (T, C))
      }
    }
  }
}

def mkPriScndVarsRel(uop: (Int -> Dyn -> Dyn), bop: (Int -> Dyn -> Dyn -> Dyn), zero: Dyn, C: MatrixMapInt, svs: [Dyn], pvs: [Dyn]) -> [(Dyn, Dyn)] = {
  def isvs = zip (mapToIdx svs) svs;
  def jpvs = zip (mapToIdx pvs) pvs;

  map (fun isv: (Int, Dyn) -> {
        def (i, sv) = isv;

        def cpvs = map (fun jpv: (Int, Dyn) -> { def (j, pv) = jpv; (find (i + 1, j + 1) C, pv) }) jpvs;
        def cpvs = filter (fun jpv: (Int, Dyn) -> fst jpv != 0) cpvs;

        def f(a: Dyn, cpv: (Int, Dyn)) -> Dyn = {
          def (c, pv) = cpv;
          if c == 0 then a else bop c a pv
        };

        match cpvs with
        | (c, pv)::cpvs -> (sv, foldLeft f (uop c pv) cpvs)
        | [] -> (sv, zero)

      }) isvs
}

def mkPriScndVarsRel(C: MatrixMapInt, svs: [<Real>], pvs: [<Real>]) -> [(<Real>, <Real>)] = {
  def uop(c: Int, r: <Real>) -> <Real> = { - (int2real c) * r };
  def bop(c: Int, l: <Real>, r: <Real>) -> <Real> = { l - (int2real c) * r };
  mkPriScndVarsRel uop bop 0. C svs pvs
}

def mkPriScndVarsRel(C: MatrixMapInt, svs: [Vector3], pvs: [Vector3]) -> [(Vector3, Vector3)] = {
  def uop(c: Int, v: Vector3) -> Vector3 = { - (int2real c) * v };
  def bop(c: Int, l: Vector3, r: Vector3) -> Vector3 = { l - (int2real c) * r };
  mkPriScndVarsRel uop bop zero3 C svs pvs
}

def mkPriScndVarsRel(C: MatrixMapInt, svs: [Quaternion], pvs: [Quaternion]) -> [(Quaternion, Quaternion)] = {
  def uop(c: Int, q: Quaternion) -> Quaternion = {
    if c == 1 then (qconj q)
    else if c == -1 then q
    else error "Expected matrix elements to be -1, or 1"
  };
  def bop(c: Int, l: Quaternion, r: Quaternion) -> Quaternion = {
    if c == 1 then l * (qconj r)
    else if c == -1 then l * r
    else error "Expected matrix elements to be -1, or 1"
  };
  mkPriScndVarsRel uop bop idq C svs pvs
}

def mkRealCutsetRelation(Ays: (MatrixMapInt, ([<Real>], [<Real>]))) -> [(<Real>, <Real>)] = {
  def (A, (y_t, y_c)) = Ays;
  mkPriScndVarsRel A y_t y_c
}

def mkRealCircuitRelation(Bxs: (MatrixMapInt, ([<Real>], [<Real>]))) -> [(<Real>, <Real>)] = {
  def (B, (x_t, x_c)) = Bxs;
  mkPriScndVarsRel B x_c x_t
}

def mkVector3CutsetRelation(Ays: (MatrixMapInt, ([Vector3], [Vector3]))) -> [(Vector3, Vector3)] = {
  def (A, (y_t, y_c)) = Ays;
  mkPriScndVarsRel A y_t y_c
}

def mkVector3CircuitRelation(Bxs: (MatrixMapInt, ([Vector3], [Vector3]))) -> [(Vector3, Vector3)] = {
  def (B, (x_t, x_c)) = Bxs;
  mkPriScndVarsRel B x_c x_t
}

def mkQuaternionCircuitRelation(Bxs: (MatrixMapInt, ([Quaternion], [Quaternion]))) -> [(Quaternion, Quaternion)] = {
  def (B, (x_t, x_c)) = Bxs;
  mkPriScndVarsRel B x_c x_t
}

def mkScalarTopolEquations(Cvs: (MatrixMapInt, ([<Real>], [<Real>])), a: Equations) -> Equations = {
  def (C, (svs, pvs)) = Cvs;
  def rs = mkPriScndVarsRel C svs pvs;

  def work(rs: [(<Real>, <Real>)], a: Equations) -> Equations = {
    match rs with
    | [] -> a
    | r::rs -> work rs (a; fst r = snd r)
    | _ -> error "Unmatched"
  };

  work rs a
}

def mkVector3TopolEquations(Cvs: (MatrixMapInt, ([Vector3], [Vector3])), a: Equations) -> Equations = {
  def (C, (svs, pvs)) = Cvs;
  def rs = mkPriScndVarsRel C svs pvs;

  def work(rs: [(Vector3, Vector3)], a: Equations) -> Equations = {
    match rs with
    | [] -> a
    | r::rs -> work rs (a; fst r == snd r)
    | _ -> error "Unmatched"
  };

  work rs a
}

def mkQuaternionTopolEquations(Cvs: (MatrixMapInt, ([Quaternion], [Quaternion])), a: Equations) -> Equations = {
  def (C, (svs, pvs)) = Cvs;
  def rs = mkPriScndVarsRel C svs pvs;

  def work(rs: [(Quaternion, Quaternion)], a: Equations) -> Equations = {
    match rs with
    | [] -> a
    | r::rs -> work rs (a; fst r ==. snd r)
    | _ -> error "Unmatched"
  };

  work rs a
}

def mkCutsetCircuitData(mes: [ModelEdge]) -> ((MatrixMapInt, ([Dyn], [Dyn])), (MatrixMapInt, ([Dyn], [Dyn]))) = {
  def (A, (T, C)) = mkCutsetMatrix mes;
  def B = -tr A;
  def _ = logg 2 "A" (fun t: () -> def _ = dp A; ());

  def (x_t, y_t) = unzip T;
  def (x_c, y_c) = unzip C;

  def _ = logg 2 "x_t" (loggprint x_t);
  def _ = logg 2 "x_c" (loggprint x_c);
  ((A, (y_t, y_c)), (B, (x_t, x_c)))
}

type MkEqsFun = (MatrixMapInt, ([Dyn], [Dyn])) -> Equations -> Equations
def mkTopolEquations(f_a: MkEqsFun, f_t: MkEqsFun, mes: [ModelEdge], a: Equations) -> Equations = {
  if isEmpty mes then a else {
    def ((A, (y_t, y_c)), (B, (x_t, x_c))) = mkCutsetCircuitData mes;
    f_t (A, (y_t, y_c)) (f_a (B, (x_c, x_t)) a)
  }
}

def elaborate(e: Equations) -> Equations = {
  def (ees, e) = getElectricalEdges e;
  def (pres, e) = getPlanarRotationEdges e;
  def (tes, e) = getTranslationEdges e;
  def (aves, e) = getAngularVelocityEdges e;
  def (res, e) = getRotationEdges e;
  def e = mkTopolEquations mkScalarTopolEquations mkScalarTopolEquations ees e;
  def e = mkTopolEquations mkScalarTopolEquations mkScalarTopolEquations pres e;
  def e = mkTopolEquations mkVector3TopolEquations mkVector3TopolEquations tes e;
  def e = mkTopolEquations mkVector3TopolEquations mkVector3TopolEquations aves e;
  def e = mkTopolEquations mkQuaternionTopolEquations mkVector3TopolEquations res e;
  e
}

type RealMap = (<Real> => <Real>)
def mkSubsMap(mes: [ScalarEdge], a: RealMap) -> RealMap = {
  if isEmpty mes then a else {
    def (Ays, Bxs) = mkCutsetCircuitData mes;
    Union [listToMap (mkRealCutsetRelation Ays), listToMap (mkRealCircuitRelation Bxs), a];
  }
}

type Vector3Map = (Vector3 => Vector3)
def mkSubsMap(mes: [Vector3Edge], a: Vector3Map) -> Vector3Map = {
  if isEmpty mes then a else {
    def (Ays, Bxs) = mkCutsetCircuitData mes;
    Union [listToMap (mkVector3CutsetRelation Ays), listToMap (mkVector3CircuitRelation Bxs), a];
  }
}

type QuaternionMap = (Quaternion => Quaternion)
def mkSubsMap(mes: [QuaternionVector3Edge], a: (QuaternionMap, Vector3Map)) -> (QuaternionMap, Vector3Map) = {
  if isEmpty mes then a else {
    def (qm, vm) = a;
    def (Ays, Bxs) = mkCutsetCircuitData mes;
    (union (listToMap (mkQuaternionCircuitRelation Bxs)) qm, union (listToMap (mkVector3CutsetRelation Ays)) vm)
  }
}

type SubsMaps = (RealMap, Vector3Map, QuaternionMap)
def elaborateWithSubstitutions(e: Equations) -> (SubsMaps, Equations) = {
  def (ees, e) = getElectricalEdges e;
  def (pres, e) = getPlanarRotationEdges e;
  def (tes, e) = getTranslationEdges e;
  def (aves, e) = getAngularVelocityEdges e;
  def (res, e) = getRotationEdges e;

  def sm = (mkSubsMap pres (mkSubsMap ees (Map.empty)));
  def vm = (mkSubsMap aves (mkSubsMap tes (Map.empty)));
  def (qm, vm) = (mkSubsMap res (Map.empty, vm));
  ((sm, vm, qm), subs (subs (subs e sm) vm) qm)
}

def GRAVITATIONAL_CONSTANT = 9.81
def CORRECTION_SPEED = 1.0
def EPSILON = 1.e-10

def clock(t_0: Real, t: <Real>) = {
  t <- t_0;
  t' <- 1.;
  t' = 1.
}

def mkCuboidInertia(m: Real, xyz: RealVector3) -> RealVector3 = {
  def (x, y, z) = xyz;
  ((m / 12.) * (y^2. + z^2.), (m / 12.) * (x^2. + z^2.), (m / 12.) * (y^2. + x^2.))
}

def rotationSensor(q: Quaternion, f_1: Frame, f_2: Frame) -> Equations = {
  def T: Vector3;
  rotationEdge f_1 f_2 q T;
  T == zero3
}

def translationSensor(r: Vector3, f_1: Frame, f_2: Frame) -> Equations = {
  def F: Vector3;
  translationEdge f_1 f_2 r F;
  F == zero3
}

def body(m: Real, I: RealVector3, r: Vector3, q: Quaternion, world: Frame, f: Frame) -> Equations = {
  def (I_xx, I_yy, I_zz) = I;
  def I = vec3 I_xx I_yy I_zz;
  def v, F, om, T: Vector3;
  translationEdge world f r F;
  rotationEdge world f q T;

  q' ==. 0.5 * (q_ om) * q + CORRECTION_SPEED * (1. - sqrt(norm2 q)) * q;
  // q_ om ==. 2. * (q' * qconj q);
  r' == v;
  F == m * v';
  T == I *. om' + cross om (I *. om)
}

def gravity(m: Real, world: Frame, f: Frame) -> Equations = {
  def r, F: Vector3;
  translationEdge world f r F;
  F == m * GRAVITATIONAL_CONSTANT * jj
}

def sphericalJoint(f_1: Frame, f_2: Frame) -> Equations = {
  def r, F: Vector3;
  translationEdge f_1 f_2 r F;
  r == zero3
}

def rotationalDamper(D: Real, f_1: Frame, f_2: Frame) -> Equations = {
  def om, T: Vector3;
  def q: Quaternion;
  rotationEdge f_1 f_2 q T;
  q' ==. 0.5 * (q_ om) * q + CORRECTION_SPEED * (1. - sqrt(norm2 q)) * q;
  // qim (q') == 0.5 * qim ((q_ om) * q + CORRECTION_SPEED * (1. - sqrt(norm2 q)) * q);
  T == -D * om
}

def rigidArm(r: RealVector3, r_1: Vector3, q_2: Quaternion, world: Frame, f_1: Frame, f_2: Frame) -> Equations = {
  def F_1, om_1, om_2, T_1, T_2: Vector3;
  def q_1: Quaternion;

  translationEdge f_2 f_1 r_1 F_1;
  rotationEdge f_2 f_1 q_1 T_1;
  rotationEdge world f_2 q_2 T_2;

  q_1 ==. idq;
  r_1 == L q_2 (mkVec3 r);
  T_2 == cross (-r_1) F_1
}

def translation(f: Vector3, f_1: Frame, f_2: Frame) -> Equations = {
  def r, F: Vector3;
  translationEdge f_1 f_2 r F;
  r == f
}
