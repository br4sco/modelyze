/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include EBMLANG2
include MEBMLANG2
include Numsolvers
include simoutput

def simulatemebml(m: Equations, t0: Real, dt: Real, tend: Real,
  monitored: [(<Real>, String)]) -> SimulationResult = {

  def Mp_m = M_m t0;
  def probes = map (fun e: (<Real>, String) -> fst e) monitored;
  def labels = map (fun e: (<Real>, String) -> snd e) monitored;

  def ctsim(f: F, L: Set(<Real>))
    -> ([StepVal], Real, VMap, SolverResult) = {

    def (_, _, t0) = f;
    def (resf, nroots, rootf, yy, yp, vids, ukm) =
      get_dae_solver_input f L 0.;

    def mm = (DAESolver.init_with_rootf resf nroots rootf t0 yy yp);
    def _ = (DAESolver.set_stop_time mm tend);
    def dtt = 0.;

    // def dtt = 0.00001;
    // def _ = (DAESolver.calc_ic_ya_ydp mm vids yy yp (t0 + dtt));

    def go(t: Real, sr: SolverResult, acc: [StepVal])
      -> (Real, SolverResult, [StepVal]) = {

      def eval(t: Real) -> StepVal = {
        (t, map (fun e: <Real> ->
          eval_from_arrays_with_default_val e ukm yy yp INFINITE) probes)
      };

      def accp = (eval(t))::acc;
      if sr == SolverResultsSuccess then {
          def (tp, srp) = (DAESolver.solve_normal mm (t + dt) yy yp);
          go(tp, srp, accp)
      } else (t, sr, accp)
    };

    def (tp, sr, svs) = go(t0 + dtt, SolverResultsSuccess, []);
    def mu = ukmap_yy_yp_to_vmap ukm yy yp;
    (svs, tp, mu, sr)
  };

  def sim(m: Equations, mu: VMap, t: Real, acc: [StepVal])
    -> [StepVal] = {

    def (mp, f, L, tau) = Mp_m m mu (t, 0);
    def (svs, tp, mup, sr) = ctsim f L;
    if sr == SolverResultStopTimeReached then concat svs acc
    else {
      if sr == SolverResultRootsFound then
        sim mp mup tp (concat svs acc)
      else error "Unrecognized return value from numerical solver"
    }
  };

  (labels, reverse (sim m (Map.empty) t0 []))
}
