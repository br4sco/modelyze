/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include MEBMLANGPhysical

// Positive current is defined to be moving from the positive to the negative node
def CurrentSensor(i: Current, p: Electrical, n: Electrical) = {
  FlowSensor i p n
}

// The potential difference between n and p is pot at p minus pot at n
def VoltageSensor(u: Voltage, p: Electrical, n: Electrical) = {
  EffortSensor u p n
}

def Conductor(p: Electrical, n: Electrical) = {
  def i_Co: Current;
  def u_Co: Voltage;
  Branch i_Co u_Co p n;
  u_Co = 0.
}

def ResistorDebug(R: Real, p: Electrical, n: Electrical,
  i_R: Current, u_R: Voltage) = {

  Branch i_R u_R p n;
  u_R = R * i_R
}

def ConstantVoltageSourceDebug(V: Real, p: Electrical, n: Electrical,
  i_V: Current, u_V: Voltage) = {

  // A source drives current from high to low potential
  Branch i_V u_V n p;
  u_V = V
}

def CapacitorDebug(C: Real, u0: Real, p: Electrical, n: Electrical,
  i_C: Current, u_C: Voltage) = {

  Branch i_C u_C p n;
  init u_C u0;
  C * (der u_C) = i_C
}

def InductorDebug(L: Real, i0: Real, p: Electrical, n: Electrical,
  i_L: Current, u_L: Voltage) = {
  Branch i_L u_L p n;
  init i_L i0;
  L * (der i_L) = u_L
}

def DiodeDebug(forward: Bool, fbias: Real,
  p: Electrical, n: Electrical, i_D: Current, u_D: Voltage) = {

  def d(forward: Bool) -> Equations = {
    if forward then
      sw
        (u_D = fbias)
        (fun t:() -> d(false))
        (i_D > 0.)
    else
      sw
        (i_D = 0.)
        (fun t: () -> d(true))
        (u_D < fbias)
  };

  Branch i_D u_D p n;
  d(forward)
}

// def TimedSwitch(is_closed: Bool, tflip: Real, p: Electrical, n: Electrical) = {

//   def t: Real;

//   def Clock(t: <Real>) = {
//     init t 0.;
//     reinit t t;
//     der t = 1.
//   };

//   def s(is_closed: Bool) -> Equations = {
//     if is_closed then
//       switch
//         (Conductor p n)
//         (fun t: () -> nilp ())
//         ([tflip - t])
//     else
//       switch
//         (nilp ())
//         (fun t: () -> Conductor p n)
//         ([tflip - t])
//   };

//   Clock(t);
//   s(is_closed)
// }

def Resistor(R: Real, p: Electrical, n: Electrical) = {
  def i_R: Current;
  def u_R: Voltage;
  ResistorDebug R p n i_R u_R
}

def ConstantVoltageSource(V: Real, p: Electrical, n: Electrical) = {
  def i_V: Current;
  def u_V: Voltage;
  ConstantVoltageSourceDebug V p n i_V u_V
}

def Capacitor(C: Real, u0: Real, p: Electrical, n: Electrical) = {
  def i_C: Current;
  def u_C: Voltage;
  CapacitorDebug C u0 p n i_C u_C
}

def Inductor(L: Real, i0: Real, p: Electrical, n: Electrical) = {
  def i_L: Current;
  def u_L: Voltage;
  InductorDebug L i0 p n i_L u_L
}

def Diode(forward: Bool, fbias: Real,
  p: Electrical, n: Electrical) = {

  def i_D: Current;
  def u_D: Voltage;
  DiodeDebug forward fbias p n i_D u_D
}
