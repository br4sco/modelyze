/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include MEBMLANGPhysical

// Positive current is defined to be moving from the positive to the negative node
def CurrentSensor(i: Current, p: Electrical, n: Electrical) = {
  FlowSensor i p n
}

// The potential difference between n and p is pot at p minus pot at n
def VoltageSensor(u: Voltage, p: Electrical, n: Electrical) = {
  EffortSensor u p n
}

def ResistorDebug(R: Real, p: Electrical, n: Electrical,
  i_R: Current, u_R: Voltage) = {

  Branch i_R u_R p n;
  u_R = R * i_R
}

def ConstantVoltageSourceDebug(V: Real, p: Electrical, n: Electrical,
  i_V: Current, u_V: Voltage) = {

  // A source drives current from high to low potential
  Branch i_V u_V n p;
  init u_V V;
  reinit u_V u_V;
  u_V = V
}

def CapacitorDebug(C: Real, u0: Real, p: Electrical, n: Electrical,
  i_C: Current, u_C: Voltage) = {

  Branch i_C u_C p n;
  init u_C u0;
  reinit u_C u_C;
  C * (der u_C) = i_C
}

def InductorDebug(L: Real, i0: Real, p: Electrical, n: Electrical,
  i_L: Current, u_L: Voltage) = {
  Branch i_L u_L p n;
  init i_L i0;
  reinit i_L i_L;
  L * (der i_L) = u_L
}

def DiodeDebug(forward: Bool, fbias: Real,
  p: Electrical, n: Electrical, i_D: Current, u_D: Voltage) = {

  def d(forward: Bool) -> Equations = {
    if forward then
      switch
        (reinit u_D fbias; reinit i_D 0.; u_D = fbias)
        (fun t:() -> d(false))
        ([i_D])
    else
      switch
        (reinit i_D 0.; reinit u_D 0.; i_D = 0.)
        (fun t: () -> d(true))
        ([-u_D + fbias])
  };

  Branch i_D u_D p n;
  d(forward)
}

def SafeDiodeDebug(forward: Bool, fbias: Real,
  p: Electrical, n: Electrical, i_D: Current, u_D: Voltage) = {

  def d(forward: Bool) -> Equations = {
    if forward then
      SafeSwitch
        (reinit u_D fbias; reinit i_D 0.; u_D = fbias)
        (fun t:() -> d(false))
        ([i_D])
        (fun t: () -> u_D = 0.)
        ([u_D])
    else
      // SafeSwitch
      //   (reinit i_D 0.; reinit u_D 0.; i_D = 0.)
      //   (fun t: () -> d(true))
      //   ([-u_D])
      //   (fun t: () -> i_D = 0.)
      //   ([])
      switch
        (reinit i_D 0.; reinit u_D 0.; i_D = 0.)
        (fun t: () -> d(true))
        ([-u_D])
  };

  Branch i_D u_D p n;
  d(forward)
}

def TimedSwitchDebug(closed: Bool, tb: Real, p: Electrical, n: Electrical,
  i_TS: Current, u_TS: Voltage) = {

  def Clock(t: <Real>) = {
    init t 0.;
    reinit t t;
    der t = 1.
  };

  def t: Real;
  def s(closed: Bool) -> Equations = {
    if closed then
      switch
        (u_TS = 0.; Branch i_TS u_TS p n)
        (fun t: () -> nilp ())
        ([tb - t])
    else
      switch
        (nilp ())
        (fun t: () -> u_TS = 0.; Branch i_TS u_TS p n)
        ([tb - t])
  };
  Clock(t);
  s(closed)
}

def Conductor(p: Electrical, n: Electrical) = {
  def i: Current;
  def u: Voltage;
  Branch i u p n;
  u = 0.
}

def Resistor(R: Real, p: Electrical, n: Electrical) = {
  def i_R: Current;
  def u_R: Voltage;
  ResistorDebug R p n i_R u_R
}

def ConstantVoltageSource(V: Real, p: Electrical, n: Electrical) = {
  def i_V: Current;
  def u_V: Voltage;
  ConstantVoltageSourceDebug V p n i_V u_V
}

def Capacitor(C: Real, u0: Real, p: Electrical, n: Electrical) = {
  def i_C: Current;
  def u_C: Voltage;
  CapacitorDebug C u0 p n i_C u_C
}

def Inductor(L: Real, i0: Real, p: Electrical, n: Electrical) = {
  def i_L: Current;
  def u_L: Voltage;
  InductorDebug L i0 p n i_L u_L
}

def Diode(forward: Bool, fbias: Real,
  p: Electrical, n: Electrical) = {

  def i_D: Current;
  def u_D: Voltage;
  DiodeDebug forward fbias p n i_D u_D
}

def SafeDiode(forward: Bool, fbias: Real,
  p: Electrical, n: Electrical) = {

  def i_D: Current;
  def u_D: Voltage;
  SafeDiodeDebug forward fbias p n i_D u_D
}

def TimedSwitch(closed: Bool, tb: Real, p: Electrical, n: Electrical) = {
  def i_TS: Current;
  def u_TS: Voltage;
  TimedSwitchDebug closed tb p n i_TS u_TS
}
