/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include OSCMMLANG
include Numsolvers
include simoutput

type SimState = (Equations, VMap, VMap, (Real, Int))

def simulateDebug(m: Equations, t0: Real, h: Real, tend: Real,
  monitored: [(<Real>, String)]) -> () = {

  def probes = map (fun e: (<Real>, String) -> fst e) monitored;
  def labels = map (fun e: (<Real>, String) -> snd e) monitored;

  def printSimHeader = (fun thunk: () -> {
    def _ = print "time";
    def _ = map (fun l: String -> print ("\t" ++ l)) labels;
    print "\n"
  });

  def printSimResult(isD: (<Real> -> Bool), ev: (<Real> -> Real),
    t: Real) -> () = {

    def f(e: <Real>) -> () = {
      def _ =  print "\t";
      if isD e then print (real2string (ev e))
      else print "?"
    };

    def _ = print (real2string t);
    def _ = map f probes;
    print "\n"
  };

  def ctsim(ss: SimState)
    -> SimState = {

    def llog = logger "ctsim";

    def (m, ll, rl, (t1, _)) = ss;
    def E = evalpres (elaborate m) rl;
    def _ = llog DEBUG "model before ir" (setToCont E);
    def P = gatherregs m;


    // Perform index reduction
    def nE = indexred E;

    // Setup the DAE Solver
    def (resf, nroots, rootf, yy1, yp1, vids, ukm, zcm) =
      getDAESolverInput (nE, rl, t0) P 0.;
    def yy0 = (Array.make (Array.length yy1) INFINITE);
    def yp0 = (Array.make (Array.length yp1) INFINITE);
    def t0 = INFINITE;
    def s = (DAESolver.initWithRootf resf nroots rootf t1 yy1 yp1);
    def _ = (DAESolver.setStopTime s tend);
    def nt1 = t1 + 0.00001;
    def _ = llog DEBUG "yy1 before ivc" yy1;
    def _ = llog DEBUG "yp1 before ivc" yp1;
    def _ = (DAESolver.calcIcYaYdp s vids yy1 yp1 nt1);
    def _ = llog DEBUG "yy1 after ivc" yy1;
    def _ = llog DEBUG "yp1 after ivc" yp1;

    def psr(yy: {Real}, yp: {Real}) = printSimResult (isDefined ukm)
      (fun e: <Real> -> evalFromArrays e ukm yy yp);

    // And then solve!
    def go(sr: SolverResult, t0: Real, yy0: {Real}, yp0: {Real},
      t1: Real, yy1: {Real}, yp1: {Real}, use1: Bool)
        -> (SolverResult, Real, Bool) = {

      if sr == DAE_SOLVER_RESULT_SUCCESS then {
        def _ = psr yy1 yp1 t1;
        def (nt0, nsr) = (DAESolver.solveNormal s (t1 + h) yy0 yp0);
        go nsr t1 yy1 yp1 nt0 yy0 yp0 (!use1)
      } else {
        if sr == DAE_SOLVER_RESULT_ROOTS_FOUND then {
          def zca = (DAESolver.getRootInfo s);
          def nt0 = ipolZCTime zcm zca ukm t0 yy0 yp0 t1 yy1 yp1;
          def _ = ipolArray yy0 yy1 t0 t1 nt0 yy0;
          def _ = ipolArray yp0 yp1 t0 t1 nt0 yp0;
          def _ = psr yy0 yp0 nt0;
          (sr, t1, use1)
        } else {
          // def _ = trunc yy1 EPSILON2;
          // def _ = trunc yp1 EPSILON2;
          def _ = psr yy1 yp1 t1;
          (sr, t1, use1)
        }
      }
    };

    def (sr, t, use1) = go DAE_SOLVER_RESULT_SUCCESS t0 yy0 yp0 nt1 yy1 yp1 true;
    def nrl = { if use1 then ukMapYyYpToVMap ukm yy1 yp1
                else ukMapYyYpToVMap ukm yy0 yp0 };
    def nll = { if use1 then ukMapYyYpToVMap ukm yy0 yp0
                else ukMapYyYpToVMap ukm yy1 yp1 };
    // def nll = nrl;
    ((m, nll, nrl, (t, 0)))
  };

  def dtsim(ss: SimState)
    -> SimState = {
    def llog = dlogger "dtsim" DEBUG;

    def (m, ll, rl, (t, n)) = ss;
    def psr = (fun vm: VMap -> fun thnk: () ->
      printSimResult (isDefined vm) (fun e: <Real> -> evalRealFromVMap e vm) t);

    def go(ss: SimState)
      -> SimState = {

      def dh = 0.001;
      def (m, ll, rl, (t, n)) = ss;
      def _ = (if n > 10 then error "Number of ticks exceeded 10" else ());

      def _ = llog "left limit:" (psr ll);
      def _ = llog "right limit:" (psr rl);

      if (stable m rl) then ss
      else {
        def nm = elabsws m rl;
        def nrl = evalinits nm rl;
        def E = evalpres (elaborate nm) ll;
        def _ = llog "model" (fun thnk: () -> (setToCont E));
        def dia = impulseApprox E ll nrl dh;
        def _ = llog "impulse" (psr dia);

        // if containsImps dia (1. / h) then {
          // we have impulses
          // def _ = llog "we have an impulse" (fun thnk: () -> ());
          if stable nm dia then {
            def rla = ivApprox E dia dh;
            go (nm, rla, rla, (t, n + 1))
          } else {
            go (nm, ll, dia, (t, n + 1))
          }
        // } else go (nm, ll, nrl, (t, n + 1))
      }
    };

    go ss;
  };

  def sim(m: Equations) -> () = {

    def chain(first: (SimState -> SimState),
      second: (SimState -> SimState), ss: SimState) -> SimState = {

      def (m, ll, rl, (t, n)) = ss;
      if t >= tend then ss
      else {
        def nss = first ss;
        chain second first nss
      }
    };

    // TODO: eval inits at each mode-switch
    def ss = (m, Map.empty, evalinits m (Map.empty), (t0, 0));
    def _  = chain ctsim dtsim ss;
    ()
  };

  def _ = printSimHeader ();
  sim m
}
