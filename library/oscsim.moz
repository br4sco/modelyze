/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include OSCMMLANG
include Numsolvers
include simoutput

type SS = (Equations, VMap, (Real, Int))

def simulateDebug(m: Equations, t0: Real, h: Real, tend: Real,
  monitored: [(<Real>, String)]) -> () = {

  def probes = map (fun e: (<Real>, String) -> fst e) monitored;
  def labels = map (fun e: (<Real>, String) -> snd e) monitored;

  def printSimHeader = (fun thunk: () -> {
    def _ = print "time";
    def _ = map (fun l: String -> print ("\t" ++ l)) labels;
    print "\n"
  });

  def printSimResult(isD: (<Real> -> Bool), ev: (<Real> -> Real),
    t: Real) -> () = {

    def f(e: <Real>) -> () = {
      def _ =  print "\t";
      if isD e then print (real2string (ev e))
      else print "?"
    };

    def _ = print (real2string t);
    def _ = map f probes;
    print "\n"
  };

  def ctsim(ss: SS)
    -> SS = {

    def (m, vm, (t, _)) = ss;
    def E = elaborate m;
    def P = gatherregs m;


    // Perform index reduction
    def nE = indexred E;

    // Setup the DAE Solver
    def (resf, nroots, rootf, yy, yp, vids, ukm) =
      getDAESolverInput (nE, vm, t) P 0.;
    def s = (DAESolver.initWithRootf resf nroots rootf t0 yy yp);
    def _ = (DAESolver.setStopTime s tend);
    def nt = t + 0.00001;
    def _ = (DAESolver.calcIcYaYdp s vids yy yp nt);


    def psr = printSimResult (isDefined ukm)
      (fun e: <Real> -> evalFromArrays e ukm yy yp);

    // And then solve!
    def go(sr: SolverResult, t: Real)
      -> (SolverResult, Real) = {

      def _ = psr t;
      if sr == DAE_SOLVER_RESULT_SUCCESS then {
          def (nt, nsr) = (DAESolver.solveNormal s (t + h) yy yp);
          go(nsr, nt)
      } else (sr, t)
    };

    def (sr, nnt) = go(DAE_SOLVER_RESULT_SUCCESS, nt);
    def nvm = ukMapYyYpToVMap ukm yy yp;
    ((m, nvm, (nnt, 0)))
  };

  def dtsim(ss: SS)
    -> SS = {
    def llog = logger "dtsim";

    def (m, vm, (t, n)) = ss;

    def go(ss: SS)
      -> SS = {

      def (m, vm, (t, n)) = ss;

      if stable m vm then ss
      else {
        def _ = llog DEBUG "before switch" m;
        def nm = elabsws m vm;
        def _ = llog DEBUG "after switch" nm;
        def E = evalpres (elaborate nm) vm;
        def imp = impulseApprox E vm h;
        if stable nm imp then go (nm, ivApprox E imp h, (t, n + 1))
        else go (elabsws nm imp, vm, (t, n + 1))
      }
    };

    go ss;
  };

  def sim(m: Equations) -> () = {

    def chain(first: (SS -> SS),
                  second: (SS -> SS),
                  ss: SS) -> SS = {

      def (m, vm, (t, n)) = ss;
      if t >= tend then ss
      else {
        def nss = first ss;
        chain second first nss
      }
    };

    // TODO: eval inits at each mode-switch
    def ss = (m, evalinits m (Map.empty), (t0, 0));
    def _  = chain ctsim dtsim ss;
    ()
  };

  def _ = printSimHeader ();
  sim m
}
