/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include OSCMMLANG
include Numsolvers
include simoutput

type SimState = (Equations, VMap, (Real, Int))

def simulateDebug(m: Equations, t0: Real, h: Real, tend: Real,
  monitored: [(<Real>, String)]) -> () = {

  def probes = map (fun e: (<Real>, String) -> fst e) monitored;
  def labels = map (fun e: (<Real>, String) -> snd e) monitored;

  def printSimHeader = (fun thunk: () -> {
    def _ = print "time";
    def _ = map (fun l: String -> print ("\t" ++ l)) labels;
    print "\n"
  });

  def printSimResult(isD: (<Real> -> Bool), ev: (<Real> -> Real),
    t: Real) -> () = {

    def f(e: <Real>) -> () = {
      def _ =  print "\t";
      if isD e then print (real2string (ev e))
      else print "?"
    };

    def _ = print (real2string t);
    def _ = map f probes;
    print "\n"
  };

  def ctsim(ss: SimState)
    -> SimState = {

    def llog = logger "ctsim";

    def (m, vm, (t, _)) = ss;
    def E = evalpres (elaborate m) vm;
    def _ = llog DEBUG "model before ir" E;
    def P = gatherregs m;


    // Perform index reduction
    def nE = indexred E;

    // Setup the DAE Solver
    def (resf, nroots, rootf, yy0, yp0, vids, ukm, zcm) =
      getDAESolverInput (nE, vm, t) P 0.;
    def yy1 = (Array.make (Array.length yy0) INFINITE);
    def yp1 = (Array.make (Array.length yp0) INFINITE);
    def s = (DAESolver.initWithRootf resf nroots rootf t yy0 yp0);
    def _ = (DAESolver.setStopTime s tend);
    def nt = t + 0.00001;
    def _ = llog DEBUG "yy0 before ivc" yy0;
    def _ = llog DEBUG "yp0 before ivc" yp0;
    def _ = (DAESolver.calcIcYaYdp s vids yy0 yp0 nt);
    def _ = llog DEBUG "yy0 after ivc" yy0;
    def _ = llog DEBUG "yp0 after ivc" yp0;

    def psr(yy: {Real}, yp: {Real}) = printSimResult (isDefined ukm)
      (fun e: <Real> -> evalFromArrays e ukm yy yp);

    // And then solve!
    def go(sr: SolverResult, yy0: {Real}, yp0: {Real},
      yy1: {Real}, yp1: {Real}, t: Real, use1: Bool) -> (SolverResult, Real, Bool) = {

      def _ = psr yy0 yp0 t;
      if sr == DAE_SOLVER_RESULT_SUCCESS then {
          def (nt, nsr) = (DAESolver.solveNormal s (t + h) yy1 yp1);
          go nsr yy1 yp1 yy0 yp0 nt (!use1)
      } else {
        (sr, t, use1)
      }
    };

    def (sr, nnt, use1) = go DAE_SOLVER_RESULT_SUCCESS yy0 yp0 yy1 yp1 nt false;
    def nvm = { if use1 then ukMapYyYpToVMap ukm yy1 yp1
                else ukMapYyYpToVMap ukm yy0 yp0};
    ((m, nvm, (nnt, 0)))
  };

  def dtsim(ss: SimState)
    -> SimState = {
    def llog = logger "dtsim";

    def (m, vm, (t, n)) = ss;
    def psr = (fun vm: VMap ->
      printSimResult (isDefined vm) (fun e: <Real> -> evalRealFromVMap e vm) t);

    def go(ss: SimState)
      -> SimState = {

      def (m, pvm, (t, n)) = ss;
      def _ = (if n > 10 then error "Number of ticks exceeded 10" else ());

      if stable m pvm then ss
      else {
        def nm = elabsws m pvm;
        def vm = evalinits nm pvm;
        def E = evalpres (elaborate nm) pvm;
        def imp = impulseApprox E pvm vm (h / 10.);
        def _ = llog DEBUG "Impulse" (psr imp);
        if stable nm imp then {
            def iva = ivApprox E imp (h / 10.);
            def _ = llog DEBUG "IVApprox" (psr iva);
            go (nm, iva, (t, n + 1))
          }
        else go (elabsws nm imp, vm, (t, n + 1))
      }
    };

    go ss;
  };

  def sim(m: Equations) -> () = {

    def chain(first: (SimState -> SimState),
      second: (SimState -> SimState), ss: SimState) -> SimState = {

      def (m, vm, (t, n)) = ss;
      if t >= tend then ss
      else {
        def nss = first ss;
        chain second first nss
      }
    };

    // TODO: eval inits at each mode-switch
    def ss = (m, evalinits m (Map.empty), (t0, 0));
    def _  = chain ctsim dtsim ss;
    ()
  };

  def _ = printSimHeader ();
  sim m
}
