/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include OSCMMLANG
include Numsolvers
include simoutput

type SimState = (Equations, Set(Equations), VMap, VMap, (Real, Int))

def simulateDebug(m: Equations, t0: Real, h: Real, tend: Real,
  monitored: [(<Real>, String)]) -> () = {

  def probes = map (fun e: (<Real>, String) -> fst e) monitored;
  def labels = map (fun e: (<Real>, String) -> snd e) monitored;

  def printSimHeader = (fun thunk: () -> {
    def _ = print "time";
    def _ = map (fun l: String -> print ("\t" ++ l)) labels;
    print "\n"
  });

  def printSimResult(isD: (<Real> -> Bool), ev: (<Real> -> Real),
    t: Real) -> () = {

    def f(e: <Real>) -> () = {
      def _ =  print "\t";
      if isD e then print (real2string (ev e))
      else print "?"
    };

    def _ = print (real2string t);
    def _ = map f probes;
    print "\n"
  };

  def consCheck(ivp: IVP) -> (Bool, VMap, Real) = {
    def (E, vm, t) = ivp;
    def (nvm, nt) = findiv ivp;

    def p(e: (<Real>, Real)) -> Bool = {
      def (x, v) = e;
      if isDefined nvm x then abs ((find x nvm) - v) < CONSISTLIM else true
    };

    def l = (Map.toList vm);
    (forAll p l, nvm, nt)
  };

  def ctsim(ss: SimState)
    -> SimState = {

    def llog = logger "ctsim";

    def (m, E, ll, rl, (nt1, _)) = ss;
    def _ = llog DEBUG "here we are!" rl;
    def _ = llog DEBUG "and the time is" nt1;
    // def (m, ll, rl, (t1, _)) = ss;
    // def E = evalpres (elaborate m) rl;
    // def _ = llog DEBUG "model before ir" (setToCont E);
    def P = gatherregs m;

    // Perform index reduction
    // def nE = indexred E;

    // Setup the DAE Solver
    def (resf, nroots, rootf, yy1, yp1, vids, ukm, zcm) =
      getDAESolverInput (E, rl, nt1) P INFINITE;
    def yy0 = (Array.make (Array.length yy1) INFINITE);
    def yp0 = (Array.make (Array.length yp1) INFINITE);
    def t0 = INFINITE;
    def s = (DAESolver.initWithRootf resf nroots rootf nt1 yy1 yp1);
    def _ = (DAESolver.setStopTime s tend);
    // def nt1 = t1 + 0.00001;
    // def _ = llog DEBUG "yy1 before ivc" yy1;
    // def _ = llog DEBUG "yp1 before ivc" yp1;
    // def _ = (DAESolver.calcIcYaYdp s vids yy1 yp1 nt1);
    def _ = llog DEBUG "yy1 after ivc" yy1;
    def _ = llog DEBUG "yp1 after ivc" yp1;

    def psr(yy: {Real}, yp: {Real}) = printSimResult (isDefinedUkMap ukm)
      (fun e: <Real> -> evalFromArrays e ukm yy yp);

    // And then solve!
    def go(sr: SolverResult, t0: Real, yy0: {Real}, yp0: {Real},
      t1: Real, yy1: {Real}, yp1: {Real}, use1: Bool)
        -> (SolverResult, Real, Bool) = {

      if sr == DAE_SOLVER_RESULT_SUCCESS then {
        def _ = psr yy1 yp1 t1;
        def (nt0, nsr) = (DAESolver.solveNormal s (t1 + h) yy0 yp0);
        go nsr t1 yy1 yp1 nt0 yy0 yp0 (!use1)
      } else {
        if sr == DAE_SOLVER_RESULT_ROOTS_FOUND then {
          def zca = (DAESolver.getRootInfo s);
          def nt0 = ipolZCTime zcm zca ukm t0 yy0 yp0 t1 yy1 yp1;
          def _ = ipolArray yy0 yy1 t0 t1 nt0 yy0;
          def _ = ipolArray yp0 yp1 t0 t1 nt0 yp0;
          def _ = psr yy0 yp0 nt0;
          (sr, t1, use1)
        } else {
          // def _ = trunc yy1 EPSILON2;
          // def _ = trunc yp1 EPSILON2;
          def _ = psr yy1 yp1 t1;
          (sr, t1, use1)
        }
      }
    };

    def (sr, t, use1) = go DAE_SOLVER_RESULT_SUCCESS t0 yy0 yp0 nt1 yy1 yp1 true;
    def nrl = { if use1 then ukMapYyYpToVMap ukm yy1 yp1
                else ukMapYyYpToVMap ukm yy0 yp0 };
    def nll = { if use1 then ukMapYyYpToVMap ukm yy0 yp0
                else ukMapYyYpToVMap ukm yy1 yp1 };
    // def nll = nrl;
    // ((m, nll, nrl, (t, 0)))
    (m, E, nll, nrl, (t, 0))
  };

  def dtsim(ss: SimState)
    -> SimState = {

    def llog = dlogger "dtsim" DEBUG;

    def psr(vm: VMap, t: Real) -> () = {
      printSimResult (isDefined vm) (fun e: <Real> -> evalRealFromVMap e vm) t
    };

    def go(ss: SimState)
      -> SimState = {

      def dh = 0.001;

      def (m, E, ll, rl, (t, n)) = ss;

      def elab(m: Equations, rl: VMap) -> (Equations, Set(Equations), VMap) = {
        def nm = elabsws m rl;
        def E = evalpres (elaborate nm) ll;
        def nrl = evalinits nm rl;
        (nm, E, nrl)
      };

      def propgimp(m: Equations, rl: VMap, n: Int)
        -> (Equations, VMap, Int) = {

        def work(m: Equations, imp: VMap, dia: VMap, iva: VMap) -> (Equations, VMap) = {
          // def _ = llog "m" (fun tnk: () -> m);
          def _ = llog "imp" (fun tnk: () -> psr imp t);
          def _ = llog "dia" (fun tnk: () -> psr dia t);
          def _ = llog "iva" (fun tnk: () -> psr iva t);

          if (stable m imp) && (stable m iva) then (m, iva)
          else {
            def nm = elabsws m imp;
            def E = evalpres (elaborate nm) ll;
            def diawi = evalinits nm dia;
            def ndia = impulseApprox E ll diawi dh;
            def niva = ivApprox E ndia dh;
            def ii = isImpulse ll ndia niva dh 3.;
            def nimp = combineImpIVApp ndia niva ii;
            work nm nimp ndia niva
          }
        };

        def (nm, nrl) = work m rl rl rl;
        (nm, nrl, n)
      };

      def _ = llog "left limit" (fun thk: () -> psr ll t);
      def _ = llog "right limit" (fun thk: () -> psr rl t);

      def (nm, E, nrl) = elab m rl;
      def Eir = indexred E;
      def (c, nnrl, nt) =  consCheck (Eir, nrl, t);

      def _ = llog "right limit after cs" (fun thk: () -> psr nnrl t);
      def _ = llog "c after cs" (fun thk: () -> c);

      if c && (stable nm nnrl) then (nm, Eir, ll, nnrl, (nt, n))
      else {
        def (nnm, nnrl, nn) = propgimp m rl n;
        def _ = llog "right limit after propgimp" (fun thk: () -> psr nnrl t);
        go (nnm, Set.empty, ll, nnrl, (t, nn))
      }
    };

    go ss
  };

  def sim(m: Equations) -> () = {

    def chain(first: (SimState -> SimState),
      second: (SimState -> SimState), ss: SimState) -> SimState = {

      def (_, _, _, _, (t, _)) = ss;
      if t >= tend then ss
      else {
        def nss = first ss;
        chain second first nss
      }
    };

    def E = indexred (elaborate m);
    def g = evalinits m (Map.empty);
    def (_, iv, nt0) = consCheck (E, g, t0);
    def ss = (m, E, Map.empty, iv, (nt0, 0));
    def _  = chain ctsim dtsim ss;
    ()
  };

  def _ = printSimHeader ();
  sim m
}
