/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Graph

def EPSILON = 1.e-15

def der: Real -> Real
def (') = der

type Model
def (;): Model -> Model -> Model
def (=): Real -> Real -> Model
def (<-): Real -> Real -> Model
def (<~): Real -> Real -> Model
def (~=): Real -> Real -> Model
def probe: Real -> Model
def NoElement: Model

type Frame = Node

type FrameFun1 = Frame -> Model
type FrameFun2 = Frame -> Frame -> Model

def inParallel(l: FrameFun2, r: FrameFun2,
  f_1: Frame, f_2: Frame) -> Model = {

  l f_1 f_2 ; r f_1 f_2
}
def (||) = inParallel

def inSeries(l: Frame, r: FrameFun1) -> Model = {
  r l
}
def (--) = inSeries

def inSeries(l: FrameFun1, r: Frame) -> Model = {
  l r
}
def (--) = inSeries

def inSeries(f: Frame, r: FrameFun2) -> FrameFun1 = {
  r f
}
def (--) = inSeries

def inSeries(l: FrameFun1, r: FrameFun2) = {
  fun f_2: Frame ->
      def f_1: Frame;
      l f_1 ; r f_1 f_2
}
def (--) = inSeries

def inSeriesExposeFrame(l: FrameFun2, f_2: Frame) = {
  (l, f_2)
}
def (-.-) = inSeriesExposeFrame

def inSeriesExposeFrame(lf_2: (FrameFun2, Frame), r: FrameFun2) = {
  fun f_1: Frame -> fun f_3: Frame ->
      def (l, f_2) = lf_2;
      l f_1 f_2 ; r f_2 f_3
}
def (-.-) = inSeriesExposeFrame

def inSeries(l: FrameFun2, r: FrameFun2) = {
  fun f_1: Frame -> fun f_3: Frame ->
    def f_2: Frame;
    l f_1 f_2 ; r f_2 f_3
}
def (--) = inSeries

def serializei(f: (Int -> FrameFun2), n: Int) -> FrameFun2 = {
  def work(a: FrameFun2, i: Int) -> FrameFun2 = {
    if n - i < 0 then error "n is not a positive number"
    else if n - i == 0 then a
    else work (a -- f (i + 1)) (i + 1)
  };
  work (f 1) 1
}

def serialize(f: FrameFun2, n: Int) -> FrameFun2 = {
  serializei (fun i: Int -> f) n
}

def sw(a: {Dyn}, i: Int, j: Int) -> () = {
  def n = (Array.length a);
  if i < n && 0 <= i && j < n && 0 <= j then {
    def t = (Array.get a i);
    def _ = (Array.set a i (Array.get a j));
    Array.set a j t
  } else error DIMENSION_MISSMATCH
}

def mapToIdx(l: [Dyn]) -> [Int] = {
  def f(i: Int, e: Dyn) -> Int = { i };
  mapi f l
}

type ScalarPairEdge = (Edge, (<Real>,<Real>))
type ModelEdge = (Edge, (Dyn, Dyn))

def mkGraph(mes: [ModelEdge]) -> [Edge] = {
  map (fun me: ModelEdge -> fst me) mes
}

def mkVarsList(mes: [ModelEdge]) -> [(Dyn, Dyn)] = {
  map (fun me: ModelEdge -> snd me) mes
}

def mkCutsetMatrix(mes: [Dyn]) -> (MatrixMapInt, (Dyn, Dyn)) = {
  if isEmpty mes then error "Edge list empty" else {
    def G = mkGraph mes;
    if hasSelfLoop G then error "Model graph contains self loop"
    else {
      def IM = mkIncidenceMatrix G;
      def vs = listToArray (mkVarsList mes);

      def work(i: Int, a: MatrixMapInt) -> MatrixMapInt = {
        if i > rdim a then a
        else {
          def j_max = snd (argfind (fun v: Int -> v != 0)
                        (sub (i, 1) (i, cdim a) a));
          if i == j_max then work (i + 1) a
          else {
            def _ = sw vs (i - 1) (j_max - 1);
            work (i + 1) (swcols i j_max a)
          }
        }
      };

      def IMrr = rowreduce IM;
      def IMrrt = trimrows IMrr;

      if rdim IMrrt > cdim IMrrt then error BAD_MATRIX
      else {
        def IA = work 1 (real2int IMrrt);

        def (I, A) = vsplit (rdim IA) IA;
        def T = (if dim A < (1, 1) then arrayToList vs
                 else arrayToList (sub vs 0 (rdim A)));
        def C = (if dim A < (1, 1) then []
                 else arrayToList (sub vs (rdim A) (Array.length vs)));
        (A, (T, C))
      }
    }
  }
}

def mkPriScndVarsRel(uop: (Int -> Dyn -> Dyn), bop: (Int -> Dyn -> Dyn -> Dyn),
  zero: Dyn, C: MatrixMapInt, svs: [Dyn], pvs: [Dyn]) -> [(Dyn, Dyn)] = {

  def isvs = zip (mapToIdx svs) svs;
  def jpvs = zip (mapToIdx pvs) pvs;

  map (fun isv: (Int, Dyn) -> {
        def (i, sv) = isv;

        def cpvs = map (fun jpv: (Int, Dyn) -> {
          def (j, pv) = jpv; (find (i + 1, j + 1) C, pv)
        }) jpvs;

        def cpvs = filter (fun jpv: (Int, Dyn) -> fst jpv != 0) cpvs;

        def f(a: Dyn, cpv: (Int, Dyn)) -> Dyn = {
          def (c, pv) = cpv;
          if c == 0 then a else bop c a pv
        };

        match cpvs with
        | (c, pv)::cpvs -> (sv, foldLeft f (uop c pv) cpvs)
        | [] -> (sv, zero)

      }) isvs
}

def mkPriScndVarsRelScalar(C: MatrixMapInt, svs: [<Real>], pvs: [<Real>])
  -> [(<Real>, <Real>)] = {

  def uop(c: Int, v: <Real>) -> <Real> = { - (int2real c) * v };
  def bop(c: Int, l: <Real>, r: <Real>) -> <Real> = { l - (int2real c) * r };
  mkPriScndVarsRel uop bop 0. C svs pvs
}

def mkScalarCutsetRelation(Ays: (MatrixMapInt, ([<Real>], [<Real>])))
  -> [(<Real>, <Real>)] = {

  def (A, (y_t, y_c)) = Ays;
  mkPriScndVarsRelScalar A y_t y_c
}

def mkScalarCircuitRelation(Bxs: (MatrixMapInt, ([<Real>], [<Real>])))
  -> [(<Real>, <Real>)] = {

  def (B, (x_t, x_c)) = Bxs;
  mkPriScndVarsRelScalar B x_c x_t
}

def mkCutsetCircuitData(mes: [Dyn]) -> ((MatrixMapInt,
  ([Dyn], [Dyn])), (MatrixMapInt, ([Dyn], [Dyn]))) = {

  def (A, (T, C)) = mkCutsetMatrix mes;
  def B = -tr A;
  def _ = logg 2 "A" (fun t: () -> def _ = dp A; ());

  def (x_t, y_t) = unzip T;
  def (x_c, y_c) = unzip C;

  def _ = logg 2 "x_t" (loggprint x_t);
  def _ = logg 2 "x_c" (loggprint x_c);
  ((A, (y_t, y_c)), (B, (x_t, x_c)))
}

def mkCircuitData(mies: [ModelEdge]) -> (MatrixMapInt, ([Dyn], [Dyn])) = {
  def (A, (t, c)) = mkCutsetMatrix mies;
  def B = -tr A;
  (B, (t, c))
}

type MkEqsFun = (MatrixMapInt, ([Dyn], [Dyn])) -> Model -> Model

def mkTopolEquations(f_a: MkEqsFun, f_t: MkEqsFun, mes: [Dyn],
  a: Model) -> Model = {

  if isEmpty mes then a else {
    def ((A, (y_t, y_c)), (B, (x_t, x_c))) = mkCutsetCircuitData mes;
    f_t (A, (y_t, y_c)) (f_a (B, (x_c, x_t)) a)
  }
}

def mkScalarTopolEquations(Cvs: (MatrixMapInt, ([<Real>], [<Real>])),
  a: Model) -> Model = {

  def (C, (svs, pvs)) = Cvs;
  def rs = mkPriScndVarsRelScalar C svs pvs;

  def work(rs: [(<Real>, <Real>)], a: Model) -> Model = {
    match rs with
    | [] -> a
    | r::rs -> work rs (a; fst r = snd r)
    | _ -> error "Unmatched"
  };

  work rs a
}

def removeTrivialEquations(e: Model) -> Model = {
  match e with
  | e_1; e_2 -> removeTrivialEquations e_1; removeTrivialEquations e_2
  | (sval l: Real) = (sval r: Real) -> if l == r then NoElement
                                       else {
                                        def _ = dprintln e;
                                        error "Inconsistent Equation"
                                       }
  | _ -> e
}

def Clock(t0: Real, t: <Real>) -> Model = {
  t' = 1.;
  t <- t0
}
