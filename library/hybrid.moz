/*
Modeling Kernel Language (Modelyze) library 
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

Author: Oscar Eriksson
oerikss@kth.se
*/

include ModelyzeDAE
include Elaboration

type State = (Time, SolverState, VarArray, UkMap) 

def daeInit(model:Equations) -> (State,ProbeMap) = {
    def (model1,probes) = elaborateProbes(model);
    def (model2,_) = elaborateDerivatives(model1,Map.empty);
    def (model3,_) = indexReducationPantelides(model2, Map.empty);
    def ukmap = makeUkMap(model3);
    def residual = peval (makeResidual(ukmap,model3)); 
    def (yy,yp) = makeInitValues(model3, ukmap);
    def id = initConditionCorrection(ukmap);
    def solverState = (DAESolver.make yy yp id residual);
    ((0.,solverState, yy, ukmap), probes);
}

def daeDoStep(state:State, comStepSize:Real) -> (State, Time) = {
    def (currTime, solverState, yy, ukmap) = state;
    def newtime = (DAESolver.step comStepSize solverState);
    def newState = (newtime, solverState, yy, ukmap);
    (newState, newtime);
}

def daeGet(state:State, var:<Real>) -> Real = {
    def (currTime, solverState, yy, ukmap) = state;
    if Map.mem var ukmap then 
       Array.get yy (fst(Map.find var ukmap))
    else 
       INFINITE;
}

def daeSet(state:State, var:<Real>, value:Real) -> State = {
    state;    
}   

def daeGetAsStr(state:State, var:<Real>) -> String = {
    real2string(daeGet(state,var))
}

def ctSim(model:Equations, steptime:Real, endtime:Real) -> SimulationResult = {
  def (state,probes) = daeInit(model);
  def probelist = (Map.toList probes);
  def stepval = (0., getProbeVals(probelist, daeGet(state)));

  def simloop(currtime:Real, acc:[StepVal]) -> [StepVal] = {
    if currtime >= endtime then acc
    else {
        def (state,newtime) = daeDoStep(state, steptime);
        def stepval = (newtime, getProbeVals(probelist, daeGet(state)));     
        if newtime == 0. then acc
        else simloop(newtime,stepval::acc);
    }
  };  
  (makeProbeNames("",probelist),reverse(simloop(0.,[stepval]))) 
}

def printsim(model:Equations, steptime:Real, endtime:Real) =
    print(pprintSimulation(ctSim(model,steptime,endtime)))

