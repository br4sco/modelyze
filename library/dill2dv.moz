/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include DILLEXPORT
include Dill2D

def MODEL_FILENAME = "/tmp/model.mo"
def SCENE_FILENAME = "/tmp/scene.json"

type Color = String

type Material
def stdMaterial: Color -> Real -> Material

type Geometry2D
def rectangle: Real -> Real -> Geometry2D
def circle: Real -> Geometry2D

type VisualData
def visSolid: Geometry2D -> Material -> VisualData
def visAxes: Real -> VisualData

type ModelElement
def visElement: Vector2 -> <Real> -> VisualData -> ModelElement
def eqsElement: Equations -> ModelElement

def WHITE = "#ffffff"
def RED = "#ff0000"
def BLUE = "#0000ff"
def GREEN = "#00ff00"
def BLACK = "#000000"

def real2JSONstring(r: Real) -> String = {
  if int2real (real2int r) == r then real2string r ++ "0"
  else real2string r
}

def geometry2JSON(g: Geometry2D) -> String = {
  match g with
  | rectangle (sval h: Real) (sval w: Real) -> "{ " ++
                                    "\"type\": \"Rectangle\", " ++
                                    "\"height\": " ++ real2JSONstring h ++ ", " ++
                                    "\"width\": " ++ real2JSONstring w ++
                                    " }"

  | circle (sval r: Real) -> "{ " ++
                             "\"type\": \"Circle\", " ++
                             "\"radius\": " ++ real2JSONstring r ++
                             " }"
  | _ -> error "Unmatched Geometry2D"
}

def material2JSON(m: Material) -> String = {
  match m with
  | stdMaterial (sval s: String) (sval o: Real) -> {
      if o >= 0. && o <= 1. then {
        "{ " ++
        "\"type\": \"Standard\", " ++
        "\"color\": \"" ++ s ++ "\", " ++
        "\"opacity\": " ++ real2JSONstring o ++
        " }"
      } else error INVALID_ARGUMENT
    }
  | _ -> error "Unmatched Material"
}

def visualData2JSON(d: VisualData) -> String = {
  match d with
  | visSolid g m -> "{ \"type\": \"Solid\"," ++
                       "\"geometry\": " ++ geometry2JSON g ++ ", " ++
                       "\"material\": " ++ material2JSON m ++
                       " }"
  | visAxes (sval s: Real) -> "{ \"type\": \"Axes\", " ++
                                 "\"size\": " ++ real2JSONstring s ++
                                 " }"
  | _ -> error "Unmatched visual data"
}

def modelScene2Json(es: [ModelElement]) -> String = {

  def e2string(x: <Real>, y: <Real>, th: <Real>, vd: VisualData) -> String = {
                                      "{ " ++
                                      "\"type\": \"Object\", " ++
                                      "\"x\": \"" ++ symstr(x) ++ "\", " ++
                                      "\"y\": \"" ++ symstr(y) ++ "\", " ++
                                      "\"th\": \"" ++ symstr(th) ++ "\", " ++
                                      "\"data\": " ++ visualData2JSON vd ++
                                      " }"
  };

  def work(es: [ModelElement]) -> String = {
    match es with
    | (visElement (vec x y) th vd)::(o::es_1) -> e2string x y th vd ++ ", " ++ work (tl es)
    | (visElement (vec x y) th vd)::[] -> e2string x y th vd
    | _ -> ""
  };

  "{ \"scene\": [ " ++ work es ++ " ] }"
}

def filterVisElements(es: [ModelElement]) -> [ModelElement] = {
  filter (fun e: ModelElement -> match e with
                                 | visElement _ _ _ -> true
                                 | _ -> false) es
}


def getModel(es: [ModelElement]) -> Equations = {
  def work(a: Equations, o: ModelElement) -> Equations = {
    match o with
    | eqsElement e -> a; e
    | _ -> a
  };
  foldLeft work NoEqn es
}

def getModel(es: Set(ModelElement)) -> Equations = { getModel (Set.toList es) }

def elaborateToFile(es: [ModelElement]) -> () = {
  def m = getModel es;
  def ves = filterVisElements es;
  def _ = writeFile MODEL_FILENAME (exportDill2Modelica "Model" m ++ "\n");
  writeFile SCENE_FILENAME (modelScene2Json ves ++ "\n")
}

def elaborateToFile(es: Set(ModelElement)) ->  () = { elaborateToFile (Set.toList es) }

def mdl(e: Equations) -> Set(ModelElement) = { Set.add (eqsElement e) (Set.empty) }

def vis(vd: VisualData, fr: Frame, to: Frame) -> Set(ModelElement) = {
  def x_v, y_v, th_v: Real;
  def rr_v = vec x_v y_v;
  listToSet [eqsElement (AcrossController rr_v fr to; AcrossController th_v fr to),
             visElement rr_v th_v vd]
}

type FieldFun = Frame -> Frame -> Equations
type BodyFun = Frame -> Frame -> Equations
// type ArmFun = Frame -> Frame -> Frame -> Equations
// type ArmEndFun = Frame -> Equations

def inField(body: BodyFun, field: FieldFun, DATUM: Frame, inf: Frame, f: Frame) -> Equations = {
  field DATUM f; body inf f
}

def Bar1(DATUM: Frame, fr: Frame, l: Real, h: Real, m: Real, we: Frame, ea: Frame) -> Set(ModelElement) = {
  def c: Frame;
  def g = 9.81;
  def I = l * h ^ 3. / 12.;
  def vd = visSolid (rectangle h l) (stdMaterial GREEN 0.5);
  def b = inField (Body m I) (Gravity m) DATUM DATUM c;
  def model = mdl (RigidArm (l / 2.) DATUM we c
                  ; RigidArm (l / 2.) DATUM c ea
                  ; b);
  union model (vis vd fr c)
}

def RevoluteJoint1(fr: Frame, r: Real, f_1: Frame, f_2: Frame) -> Set(ModelElement) = {
  def vd = visSolid (circle r) (stdMaterial RED 0.5);
  // union
  (mdl (RevoluteJoint f_1 f_2))
  // (vis vd fr f_2)
}

// type InertialFrame
// def inertialFrame
