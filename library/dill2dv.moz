/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include DILLEXPORT
include Dill2D

def MODEL_FILENAME = "/tmp/model.mo"
def SCENE_FILENAME = "/tmp/scene.json"

type Geometry2D
def rectangle: Real -> Real -> Geometry2D
def elipse: Real -> Real -> Geometry2D

type Material
def stdMaterial: String -> Real -> Material

type Object2D
def (;) : Object2D -> Object2D -> Object2D
def visualObj2D: Vector2 -> <Real> -> Geometry2D -> Material -> Object2D
def modelObj2D: Equations -> Object2D
def NoObj: Object2D

def WHITE = "#ffffff"
def RED = "#ff0000"
def BLUE = "#0000ff"
def GREEN = "#00ff00"
def BLACK = "#000000"

def circle(r: Real) -> Geometry2D = { elipse r r }

def geometryToJSON(g: Geometry2D) -> String = {
  match g with
  | rectangle (sval h: Real) (sval w: Real) -> "{ " ++
                                    "type: \"Rectangle\", " ++
                                    "height: " ++ real2string h ++ ", " ++
                                    "width: " ++ real2string w ++
                                    " }"

  | elipse (sval h: Real) (sval w: Real) -> "{ " ++
                                    "type: \"Elipse\", " ++
                                    "height: " ++ real2string h ++ ", " ++
                                    "width: " ++ real2string w ++
                                    " }"
  | _ -> error "Unmatched Geometry2D"
}

def materialToJSON(m: Material) -> String = {
  match m with
  | stdMaterial (sval s: String) (sval o: Real) -> {
      if o >= 0. && o <= 1. then {
        "{ " ++
        "type: \"Standard\", " ++
        "color: \"" ++ s ++ "\", " ++
        "opacity: " ++ real2string o ++
        " }"
      } else error INVALID_ARGUMENT
    }
  | _ -> error "Unmatched Material"
}

def visualObj2DToJSON(o: Object2D) -> String = {
  def work(o: Object2D) -> String = {
    match o with
    | noObj; o -> work o
    // | o; NoObj -> work o
    | o_1; o_2 -> work o_1 ++ ", " ++ work o_2
    | visualObj2D (vec x y) th g m -> {
                                      "{" ++
                                      "x: " ++ symstr(x) ++ ", " ++
                                      "y: " ++ symstr(y) ++ ", " ++
                                      "th: " ++ symstr(th) ++ ", " ++
                                      "geometry: " ++ geometryToJSON g ++ ", " ++
                                      "material: " ++ materialToJSON m ++
                                      "}"}
    | _ -> error "Expected only visualObj2D"
  };
  "{ scene: [ " ++ work o ++ " ]}"
}

def getVisualObjects(o: Object2D) -> Object2D = {
  def work(o: Object2D, a: Object2D) -> Object2D = {
    match o with
    | o_1; o_2 -> work o_2 (work o_1 a)
    | visualObj2D _ _ _ _ -> a; o
    | _ -> a
  };
  work o NoObj
}

def getModel(o: Object2D) -> Equations = {
  def work(o: Object2D, a: Equations) -> Equations = {
    match o with
    | o_1; o_2 -> (work o_2 (work o_1 a))
    | modelObj2D e -> a; e
    | _ -> a
  };
  work o NoEqn
}

def elaborateToFile(o: Object2D) -> () = {
  def m = getModel o;
  def vo = getVisualObjects o;
  def _ = writeFile MODEL_FILENAME (exportDill2Modelica "Model" m ++ "\n");
  writeFile SCENE_FILENAME (visualObj2DToJSON vo ++ "\n")
}
