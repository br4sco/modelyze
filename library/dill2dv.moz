/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include DILLEXPORT
include Dill2D

def MODEL_FILENAME = "/tmp/model.mo"
def SCENE_FILENAME = "/tmp/scene.json"

type Color = String

type Material
def stdMaterial: Color -> Real -> Material

type Geometry2D
def rectangle: Real -> Real -> Geometry2D
def circle: Real -> Geometry2D

type VisualData
def visualSolid: Geometry2D -> Material -> VisualData
def visualAxes: Real -> VisualData

type Component2D
def (++) : Component2D -> Component2D -> Component2D
def visualCpnt: Vector2 -> <Real> -> VisualData -> Component2D
def modelCpnt: Equations -> Component2D
def NoCpnt: Component2D

def WHITE = "#ffffff"
def RED = "#ff0000"
def BLUE = "#0000ff"
def GREEN = "#00ff00"
def BLACK = "#000000"

def real2JSONstring(r: Real) -> String = {
  if int2real (real2int r) == r then real2string r ++ "0"
  else real2string r
}

def geometry2JSON(g: Geometry2D) -> String = {
  match g with
  | rectangle (sval h: Real) (sval w: Real) -> "{ " ++
                                    "\"type\": \"Rectangle\", " ++
                                    "\"height\": " ++ real2JSONstring h ++ ", " ++
                                    "\"width\": " ++ real2JSONstring w ++
                                    " }"

  | circle (sval r: Real) -> "{ " ++
                             "\"type\": \"Circle\", " ++
                             "\"radius\": " ++ real2JSONstring r ++
                             " }"
  | _ -> error "Unmatched Geometry2D"
}

// def frameToJSON(rr: Vector2, th: <Real>, u: Real) -> String = {
//   "{ \"type\": Frame, \"units\": "   "}"
// }

def material2JSON(m: Material) -> String = {
  match m with
  | stdMaterial (sval s: String) (sval o: Real) -> {
      if o >= 0. && o <= 1. then {
        "{ " ++
        "\"type\": \"Standard\", " ++
        "\"color\": \"" ++ s ++ "\", " ++
        "\"opacity\": " ++ real2JSONstring o ++
        " }"
      } else error INVALID_ARGUMENT
    }
  | _ -> error "Unmatched Material"
}

def visualData2JSON(d: VisualData) -> String = {
  match d with
  | visualSolid g m -> "{ \"type\": \"Solid\"," ++
                       "\"geometry\": " ++ geometry2JSON g ++ ", " ++
                       "\"material\": " ++ material2JSON m ++
                       " }"
  | visualAxes (sval s: Real) -> "{ \"type\": \"Axes\", " ++
                                 "\"size\": " ++ real2JSONstring s ++
                                 " }"
  | _ -> error "Unmatched visual data"
}

def visualCpntToJSON(o: Component2D) -> String = {
  def work(o: Component2D) -> String = {
    match o with
    | o_1 ++ o_2 -> work o_1 ++ ", " ++ work o_2
    | visualCpnt (vec x y) th vo -> {
                                      "{ " ++
                                      "\"x\": \"" ++ symstr(x) ++ "\", " ++
                                      "\"y\": \"" ++ symstr(y) ++ "\", " ++
                                      "\"th\": \"" ++ symstr(th) ++ "\", " ++
                                      "\"data\": " ++ visualData2JSON vo ++
                                      " }"}
    | _ -> error "Expected only VisualCpnt"
  };
  "{ \"scene\": [ " ++ work o ++ " ] }"
}

def getVisualObjects(o: Component2D) -> Component2D = {
  def work(o: Component2D, a: Component2D) -> Component2D = {
    match o with
    | o_1 ++ o_2 -> work o_2 (work o_1 a)
    | visualCpnt _ _ _ -> a ++ o
    | _ -> a
  };
  work o NoCpnt
}

def cleanup2DObjects(o: Component2D) -> Component2D = {
    match o with
    | o_1 ++ o_2 ->
       {
          match (cleanup2DObjects o_1, cleanup2DObjects o_2) with
          | (NoCpnt, NoCpnt) -> NoCpnt
          | (NoCpnt, o) -> o
          | (o, NoCpnt) -> o
          | (o_1b,o_2b) -> o_1b ++ o_2b
       }
    | _ -> o
}

def getModel(o: Component2D) -> Equations = {
  def work(o: Component2D, a: Equations) -> Equations = {
    match o with
    | o_1 ++ o_2 -> (work o_2 (work o_1 a))
    | modelCpnt e -> a; e
    | _ -> a
  };
  work o NoEqn
}

def elaborateToFile(o: Component2D) -> () = {
  def m = getModel o;
  def vo = getVisualObjects o;
  def vo = cleanup2DObjects vo;
  def _ = writeFile MODEL_FILENAME (exportDill2Modelica "Model" m ++ "\n");
  writeFile SCENE_FILENAME (visualCpntToJSON vo ++ "\n")
}

// type OOObject2D = (Node, Vector2, Vector2, <Real>, <Real>, Component2D)
// def getNode(o: OOObject2D) -> Node = { def (n, _, _, _, _, _) = o; n }
// def getRr(o: OOObject2D) -> Vector2 = { def (_, rr, _, _, _, _) = o; rr }
// def getTh(o: OOObject2D) -> <Real> = { def (_, _, _, th, _, _) = o; th }
// def getVv(o: OOObject2D) -> Vector2 = { def (_, _, vv, _, _, _) = o; vv }
// def getOm(o: OOObject2D) -> <Real> = { def (_, _, _, _, om, _) = o; om }
// def getData(o: OOObject2D) -> Component2D = { def (_, _, _, _, _, d) = o; d }

// def DATUM: Node
// def z: <Real> = 0.
// def world = (DATUM, vec 0. 0., vec 0. 0., z, z, NoCpnt)

// def OOBody(p: OOObject2D, m: Real, I: Real,
//            rr_r0: (Real, Real),
//            vv_r0: (Real, Real),
//            th_r0: Real,
//            om_r0: Real,
//            vd: VisualData)
//            -> OOObject2D
//            = {

//   def rr_r0 = mkVec rr_r0;
//   def vv_r0 = mkVec vv_r0;
//   def n: Node;
//   def x_m, y_m, vx_m, vy_m, ax_m, ay_m, Fx_m, Fy_m, th_m, om_m, al_m, T_m: Real;
//   def rr_m = vec x_m y_m;
//   def vv_m = vec vx_m vy_m;
//   def aa_m = vec ax_m ay_m;
//   def FF_m = vec Fx_m Fy_m;
//   def rr_o = getRr p;
//   def th_o = getTh p;
//   def vv_o = getVv p;
//   def om_o = getOm p;

//   def eqs = (initEq (v2eq rr_m (v2add rr_o rr_r0));
//              initEq (th_m = th_o + th_r0);
//              // th_m <- th_r0;
//              initEq (v2eq vv_m (v2add vv_r0 (v2add vv_o (v2prod om_o (vec (-j_ rr_r0) (i_ rr_r0))))));
//              // initEq (om_m = om_o + om_r0);
//              om_m <- om_r0;
//              Body m I rr_m vv_m FF_m th_m om_m T_m DATUM n);

//   def m = visualCpnt rr_m th_m vd ++ modelCpnt eqs;
//   (n, rr_m, vv_m, th_m, om_m, m)
// }
