/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se

*/

include DILL2D

type InitValMap = (<Real> => (Real, Bool))

def exportModelica(name: String, e: Equations, ivm: InitValMap) -> String = {

  def r2mr(r: Real) -> String = {
      if r < 0. then "(" ++ real2string r  ++ ")"
      else real2string r
  };

  def pprintUnknowns(e: Equations) -> String = {
    def f(a: String, u: <Real>) -> String = {
      def iv = (if Map.mem u ivm then {
                  def (u_0, fix) = (Map.find u ivm);
                  " (start=" ++ r2mr u_0 ++ (if fix then ", fixed=true)" else ")")
                } else "");
      a ++ "  Real " ++ symstr(u) ++ iv ++ ";\n"
    };
    def us = (map (fun uk: (<Real>, (Int, Bool)) -> fst uk) (Map.toList (makeUkMap e)));
    foldLeft f "" us
  };

  def pprintExpr(e: <Real>) -> String = {
    def work(e: <>) -> String = {
        match e with
        | e1 + e2 -> "(" ++ work e1 ++ " + " ++ work e2 ++ ")"
        | e1 - e2 -> "(" ++ work e1 ++ " - " ++ work e2 ++ ")"
        | e1 * e2 -> work e1 ++ " * " ++ work e2
        | e1 / e2 -> work e1 ++ " / " ++ work e2
        | -e -> "(-" ++ work e ++ ")"
        | e1^e2 -> work e1 ++ " ^ " ++ "(" ++ work e2 ++ ")"
        | der e -> "der(" ++ work e ++ ")"
        | ~sin e -> "sin(" ++ work e ++ ")"
        | ~cos e -> "cos(" ++ work e ++ ")"
        | ~tan e -> "tan(" ++ work e ++ ")"
        | ~asin e -> "asin(" ++ work e ++ ")"
        | ~acos e -> "acos(" ++ work e ++ ")"
        | ~atan e -> "atan(" ++ work e ++ ")"
        | ~sinh e -> "sinh(" ++ work e ++ ")"
        | ~cosh e -> "cosh(" ++ work e ++ ")"
        | ~tanh e -> "tanh(" ++ work e ++ ")"
        | ~sqrt e -> "sqrt(" ++ work e ++ ")"
        | ~exp e -> "exp(" ++ work e ++ ")"
        | ~log e -> "log(" ++ work e ++ ")"
        | ~log10 e -> "log10(" ++ work e ++ ")"
        | sym: Real -> symstr(e)
        | sval r: Real -> r2mr r
        | _ -> error "Unmatched"
    };

    work e
  };

  def pprintEqs(e: Equations) -> String  = {
    match e with
    | e_1; e_2 -> pprintEqs e_1 ++ pprintEqs e_2
    | e_1 = e_2 -> " " ++ pprintExpr e_1 ++ " = " ++ pprintExpr e_2 ++ ";\n"
    | _ -> ""
  };

  def pprintInitEqs(e: Equations) -> String = {
    match e with
    | e_1; e_2 -> pprintInitEqs e_1 ++ pprintInitEqs e_2
    | initEq e_1 e_2 -> " " ++ pprintExpr e_1 ++ " = " ++ pprintExpr e_2 ++ ";\n"
    | _ -> ""
  };

  "model " ++ name ++ "\n"
  ++ pprintUnknowns e
  ++ "initial equation\n"
  ++ pprintInitEqs e
  ++ "equation\n"
  ++ pprintEqs e
  ++ "end " ++ name ++ ";\n"
}
