/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include DAELANG
include HDAELANG
include Numsolvers
include simoutput

def simulatehdae(s: Equations, t0: Real, dt: Real, tend: Real,
  exprl: [<Real>], labels: [String]) -> SimulationResult = {

  def ctsim(sigma: Sigma, Z: Set(<Real>)) -> ([StepVal], Real, VMap, Bool, (<Real> -> Bool)) = {

    def (t0, _, _) = sigma;
    def (resf, nroots, rootf, yy, yp, vids, ukm, zcbm) =
      get_dae_solver_input sigma Z 0.;

    def s = (DAESolver.init_with_rootf resf nroots rootf t0 yy yp);
    def dtt = 0.00001;
    def _ = (DAESolver.calc_ic_ya_ydp s vids yy yp (t0 + dtt));
    def _ = (DAESolver.set_stop_time s tend);

    def go(t: Real, sr: SolverResult, acc: [StepVal]) -> (Real, [StepVal], Bool) = {

      def eval(t: Real) -> StepVal = {
        (t, map (fun e: <Real> -> eval_from_arrays_with_default_val e ukm yy yp INFINITE) exprl)
      };

      def newacc = (eval(t))::acc;
      match sr with
      | SolverResultsSuccess -> {
          def (newt, newsr) = (DAESolver.solve_normal s (t + dt) yy yp);
          go(newt, newsr, newacc)
        }
      | SolverResultRootsFound -> (newt, newacc, true)
      | SolverResultStopTimeReached -> (newt, newacc, false)
      | _ -> error "Unknown return code received from DAESolver"
    };

    def (newt, svs, zc) = go(t0 + dtt, SolverResultsSuccess, []);
    def f = ukmap_yy_yp_to_vmap ukm yy yp;
    if !zc then (svs, newt, f, zc, fun x: <Real> -> false)
    else {
      def zcarr = (DAESolver.get_root_info s);
      def zf = (fun e: <Real> ->
        if (Map.mem e zcbm) then (Array.get zcarr (Map.find e zcbm)) != RootsNoRoot
        else false);
      (svs, newt, f, zc, zf)
    }
  };

  def sim(s: Equations, f: VMap, z: (<Real> -> Bool), t: Real, acc: [StepVal]) -> [StepVal] = {
    def (s_new, t_new, E, f_new, Z) = M_h s f z t;
    def sigma = (t_new, E, f_new);
    def (svs, t_newer, f_newer, zc, z_newer) = ctsim sigma Z;
    if !zc then concat svs acc
    else {
      sim s_new f_newer z_newer t_newer (concat svs acc)
    }
  };

  (labels, sim s (Map.empty) (fun e: <Real> -> false) t0 [])
}
