/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include EBMLANG
include MEBMLANG
include Numsolvers
include simoutput

def simulatehdae(s: Equations, t0: Real, dt: Real, tend: Real,
  monitored: [(<Real>, String)]) -> SimulationResult = {

  def probes = map (fun e: (<Real>, String) -> fst e) monitored;
  def labels = map (fun e: (<Real>, String) -> snd e) monitored;

  def ctsim(sigma: Sigma, Z: Set(<Real>))
    -> ([StepVal], Real, VMap, SolverResult, (<Real> -> Bool)) = {

    def (t0, _, _) = sigma;
    def (resf, nroots, rootf, yy, yp, vids, ukm, zcbm) =
      get_dae_solver_input sigma Z 0.;

    def ss = (DAESolver.init_with_rootf resf nroots rootf t0 yy yp);
    def _ = (DAESolver.set_stop_time ss tend);
    def dtt = 0.;

    // def dtt = 0.00001;
    // def _ = (DAESolver.calc_ic_ya_ydp ss vids yy yp (t0 + dtt));

    def go(t: Real, sr: SolverResult, acc: [StepVal])
      -> (Real, SolverResult, [StepVal]) = {

      def eval(t: Real) -> StepVal = {
        (t, map (fun e: <Real> ->
          eval_from_arrays_with_default_val e ukm yy yp INFINITE) probes)
      };

      def newacc = (eval(t))::acc;
      if sr == SolverResultsSuccess then {
          def (newt, newsr) = (DAESolver.solve_normal ss (t + dt) yy yp);
          go(newt, newsr, newacc)
      } else (t, sr, newacc)
    };

    def (newt, sr, svs) = go(t0 + dtt, SolverResultsSuccess, []);
    def f = ukmap_yy_yp_to_vmap ukm yy yp;
    if sr == SolverResultStopTimeReached then
      (svs, newt, f, sr, fun x: <Real> -> false)
    else {
        def zcarr = (DAESolver.get_root_info ss);
        def zf = (fun e: <Real> ->
          if (Map.mem e zcbm) then
            (Array.get zcarr (Map.find e zcbm)) != RootsNoRoot
          else false);
        (svs, newt, f, sr, zf)
    }
  };

  def sim(s: Equations, f: VMap, z: (<Real> -> Bool), t: Real, acc: [StepVal])
    -> [StepVal] = {

    def (s_new, t_new, E, f_new, Z) = M_h s f z t;
    def sigma = (t_new, E, f_new);
    def (svs, t_newer, f_newer, sr, z_newer) = ctsim sigma Z;
    if sr == SolverResultStopTimeReached then concat svs acc
    else {
      sim s_new f_newer z_newer t_newer (concat svs acc)
    }
  };

  (labels, reverse (sim s (Map.empty) (fun e: <Real> -> false) t0 []))
}
