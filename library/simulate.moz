/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include EBMLANG
include MEBMLANG
include Numsolvers
include simoutput

def ctsim(dt: Real, tend: Real, probes: [<Real>], f: F, L: Set(<Real>))
  -> ([StepVal], Real, VMap, SolverResult) = {

  def (_, _, t0) = f;
  def (resf, nroots, rootf, yy, yp, vids, ukm) =
    get_dae_solver_input f L 0.;

  def mm = (DAESolver.init_with_rootf resf nroots rootf t0 yy yp);
  def _ = (DAESolver.set_stop_time mm tend);
  def dtt = 0.;

  // def dtt = 0.00001;
  // def _ = (DAESolver.calc_ic_ya_ydp mm vids yy yp (t0 + dtt));

  def go(t: Real, sr: SolverResult, acc: [StepVal])
    -> (Real, SolverResult, [StepVal]) = {

    def eval(t: Real) -> StepVal = {
      (t, map (fun e: <Real> ->
        eval_from_arrays_with_default_val e ukm yy yp INFINITE) probes)
    };

    def accp = (eval(t))::acc;
    if sr == SolverResultsSuccess then {
        def (tp, srp) = (DAESolver.solve_normal mm (t + dt) yy yp);
        go(tp, srp, accp)
    } else (t, sr, accp)
  };

  def (tp, sr, svs) = go(t0 + dtt, SolverResultsSuccess, []);
  def mu = ukmap_yy_yp_to_vmap ukm yy yp;
  (svs, tp, mu, sr)
}

def simulatemebml(m: Equations, t0: Real, dt: Real, tend: Real,
  monitored: [(<Real>, String)]) -> SimulationResult = {

  def Mp_m = M_m t0;
  def probes = map (fun e: (<Real>, String) -> fst e) monitored;
  def labels = map (fun e: (<Real>, String) -> snd e) monitored;
  def cs = ctsim dt tend probes;

  def sim(m: Equations, mu: VMap, t: Real, probes: [<Real>],
    acc: [StepVal]) -> [StepVal] = {

    def (mp, f, L, tau) = Mp_m m mu (t, 0);
    def (svs, tp, mup, sr) = cs f L;
    if sr == SolverResultStopTimeReached then concat svs acc
    else {
      if sr == SolverResultRootsFound then
        sim mp mup tp probes (concat svs acc)
      else error "Unrecognized return value from numerical solver"
    }
  };

  (labels, reverse (sim m (Map.empty) t0 probes []))
}

def simulatemebmlDebug(m: Equations, t0: Real, dt: Real, tend: Real,
  monitored: [(<Real>, String)], maxn: Int) -> SimulationResult = {

  def llog = logger "simulatemebmlDebug" DEBUG;
  def Mp_m = M_m_debug t0;
  def probes = map (fun e: (<Real>, String) -> fst e) monitored;
  def labels = map (fun e: (<Real>, String) -> snd e) monitored;
  def cs = ctsim dt tend probes;

  def dtsim(m: Equations, mu: VMap, tau: T, acc: [StepVal])
    -> (M, [StepVal]) = {

    def eval(mu: VMap, t: Real) -> StepVal = {
      (t, map (fun e: <Real> ->
        eval_from_vmap_with_default_val e mu INFINITE) probes)
    };

    def mp = Mp_m m mu tau;
    def (mpp, f, L, taup) = mp;
    def (t, n) = taup;
    def (_, mup, _) = f;
    def _ = llog "max n" maxn;
    def _ = llog "start of dtsim, n" n;
    if n > maxn || inside L mup then (mp, acc)
    else {
      def accp = (eval mup t)::acc;
      dtsim mpp mup taup accp
    }
  };

  def sim(m: Equations, mu: VMap, t: Real, probes: [<Real>],
    acc: [StepVal]) -> [StepVal] = {

    def (mp, accp) = dtsim m mu (t, 0) acc;
    def (mpp, f, L, tau) = mp;
    def (tp, n) = tau;

    if n > maxn then accp
    else {
      def _ = llog "about to start ctsim at time:" tp;
      def (svs, tp, mup, sr) = cs f L;
      if sr == SolverResultStopTimeReached then concat svs accp
      else {
        if sr == SolverResultRootsFound then
          sim mpp mup tp probes (concat svs accp)
        else error "Unrecognized return value from numerical solver"
      }
    }
  };

  (labels, reverse (sim m (Map.empty) t0 probes []))
}
