/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Matrix
include Graph
include ModelyzeDAE

type Frame = Node

def sw(a: {Dyn}, i: Int, j: Int) -> () = {
  def n = (Array.length a);
  if i < n && 0 <= i && j < n && 0 <= j then {
    def t = (Array.get a i);
    def _ = (Array.set a i (Array.get a j));
    Array.set a j t
  } else error DIMENSION_MISSMATCH
}

def mapToIdx(l: [Dyn]) -> [Int] = {
  def f(i: Int, e: Dyn) -> Int = { i };
  mapi f l
}

def initGuess: <Real> -> Real -> Equations
def (<~) = initGuess

def initEq: <Real> -> <Real> -> Equations
def (~=) = initEq
// def initEq: Equations -> Equations

type Vector2
def vec: Real -> Real -> Vector2
def v2zero = vec 0. 0.

def scalarEdge: Node -> Node -> <Real> -> <Real> -> Equations
def vector2Edge: Node -> Node -> Vector2 -> Vector2 -> Equations
// def initScalarEdge: Node -> Node -> <Real> -> <Real> -> Equations
// def initVector2Edge: Node -> Node -> Vector2 -> Vector2 -> Equations

type ModelEdge = (Edge, (Dyn, Dyn))
type ScalarEdge = (Edge, (<Real>, <Real>))
type Vector2Edge = (Edge, (Vector2, Vector2))

def mkGraph(mes: [ModelEdge]) -> [Edge] = {
  map (fun me: ModelEdge -> fst me) mes
}

def mkVarsList(mes: [ModelEdge]) -> [(Dyn, Dyn)] = {
  map (fun me: ModelEdge -> snd me) mes
}

type InitVal = (<Real>, (Real, Bool))

def i_(v: Vector2) -> <Real> = {
  match v with
  | vec x _ -> x
  | _ -> error "Invalid Operand"
}

def j_(v: Vector2) -> <Real> = {
  match v with
  | vec _ y -> y
  | _ -> error "Invalid Operand"
}

def mkVec = (fun t: () -> { def i, j: Real; vec i j })
def mkVec(v: (Real, Real)) -> Vector2 = { def (i, j) = v; vec i j }
// def mkScalar = (fun t: () -> { def s: Real; s })

def v2eq(lhs: Vector2, rhs: Vector2) -> Equations = {
  match lhs with
  | vec lx ly -> {
      match rhs with
      | vec rx ry -> lx = rx; ly = ry
      | _ -> error "Invalid RHS"
    }
  | _ -> error "Invalid LHS"
}
// def (=): Vector2 -> Vector2 -> Equations = v2eq

// def v2init(v: Vector2, v_0: Vector2) -> Equations = {
//   match v with
//   | vec x y -> {
//       match v_0 with
//       | vec x_0 y_0 -> x <- x_0; y <- y_0
//       | _ -> error "Invalid RHS"
//     }
//   | _ -> error "Invalid LHS"
// }
// def (<-): Vector2 -> Vector2 -> Equations = v2init

def v2add(lhs: Vector2, rhs: Vector2) -> Vector2 = {
  match lhs with
  | vec lx ly -> {
      match rhs with
      | vec rx ry -> vec (lx + rx) (ly + ry)
      | _ -> error "Invalid RHS"
    }
  | _ -> error "Invalid LHS"
}
// def (+): Vector2 -> Vector2 -> Vector2 = v2add

def v2sub(lhs: Vector2, rhs: Vector2) -> Vector2 = {
  match lhs with
  | vec lx ly -> {
      match rhs with
      | vec rx ry -> vec (lx - rx) (ly - ry)
      | _ -> error "Invalid RHS"
    }
  | _ -> error "Invalid LHS"
}
// def (-): Vector2 -> Vector2 -> Vector2 = v2sub

def v2chsgn(v: Vector2) -> Vector2 = {
  match v with
  | vec x y -> vec (-x) (-y)
  | _ -> error "Invalid Operand"
}
def (--): Vector2 -> Vector2 = v2chsgn

def v2prod(s: <Real>, v: Vector2) -> Vector2 = {
  match v with
  | vec x y -> vec (s * x) (s * y)
  | _ -> error "Invalid Operand"
}
// def (*): <Real> -> Vector2 -> Vector2 = v2prod

def v2dot(lhs: Vector2, rhs: Vector2) -> <Real> = {
  def f(e: Dyn) -> <Real> = { e };
  match lhs with
  | vec lx ly -> {
      match rhs with
      | vec rx ry -> (f lx) * (f rx) + (f ly) * (f ry)
      | _ -> error "Invalid RHS"
    }
  | _ -> error "Invalid LHS"
}
// def (*.): Vector2 -> Vector2 -> <Real> = v2dot

def v2der(v: Vector2) -> Vector2 = {
  match v with
  | vec x y -> vec (der x) (der y)
  | _ -> error "Invalid Operand"
}
// def ('): Vector2 -> Vector2 = v2der

def v2norm(v: Vector2) -> <Real> = {
  match v with
  | vec x y -> sqrt (x^(2.) + y^(2.))
  | _ -> error "Invalid Operand"
}

def getUknowns(m: Equations) -> [<Real>] = {
  def f(e: (<Real>, (Int, Bool))) -> <Real> = { fst e };
  map f (Map.toList (makeUkMap m))
}

def getScalarEdges(e: Equations) -> ([ScalarEdge], Equations) = {
  def work(e: Equations, a: ([ScalarEdge], Equations)) -> ([ScalarEdge], Equations)  = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | scalarEdge n_1 n_2 x y -> (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoEqn)
}

def getVector2Edges(e: Equations) -> ([Vector2Edge], Equations) = {
  def work(e: Equations, a: ([Vector2Edge], Equations)) -> ([Vector2Edge], Equations) = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | vector2Edge n_1 n_2 x y -> (((n_1, n_2), (x, y))::(fst a), snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoEqn)
}

def getInits(e: Equations) -> ([InitVal], Equations) = {
  def work(e: Equations, a: ([InitVal], Equations)) -> ([InitVal], Equations)  = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | v <- v_0 -> {
        match (v, v_0) with
        | (v, lift v_0: Real) -> ((v, (v_0, true))::(fst a), snd a)
        | _ -> error "Invalid init"
      }
    | v <~ v_0 -> {
        match (v, v_0) with
        | (v, lift v_0: Real) -> ((v, (v_0, false))::(fst a), snd a)
        | _ -> error "Invalid init"
      }
    | l ~= r -> (fst a, snd a; l = r)
    // | initScalarEdge n_1 n_2 x y -> (fst a, snd a; scalarEdge n_1 n_2 x y)
    // | initVector2Edge n_1 n_2 x y -> (fst a, snd a; vector2Edge n_1 n_2 x y)
    // | initEq e -> {
    //     def work(e: Equations, a: Equations) -> Equations = {
    //       match e with
    //       | e_1; e_2 -> work e_2 (work e_1 a)
    //       | initEq e -> work e a
    //       | _ -> a; e
    //     };

    //     (fst a , work e (snd a))
    //   }
    | _ -> a
  };

  work e ([], NoEqn)
}

// def getEquations(e: Equations) -> (Equations, Equations) = {
//   def work(e: Equations, a: (Equations, Equations)) -> (Equations, Equations) = {
//     match e with
//     | e_1; e_2 -> ((fst a); e, snd a)
//     | _ -> (fst a, (snd a); e)
//   };
//   work e (NoEqn, NoEqn)
// }

def mkCutsetMatrix(mes: [ModelEdge]) -> (MatrixMapInt, (Dyn, Dyn)) = {
  def G = mkGraph mes;
  if hasSelfLoop G then error "Model graph contains self loop"
  else {
    def IM = mkIncidenceMatrix G;
    def _ = logg 2 "IM" (fun t: () -> def _ = dp IM; ());
    def _ = logg 2 "(x, y)" (loggprint (mkVarsList mes));

    def vs = listToArray (mkVarsList mes);

    def work(i: Int, a: MatrixMapInt) -> MatrixMapInt = {
      if i > rdim a then a
      else {
        def j_max = snd (argfind (fun v: Int -> v != 0)
                      (sub (i, 1) (i, cdim a) a));
        if i == j_max then work (i + 1) a
        else {
          def _ = sw vs (i - 1) (j_max - 1);
          work (i + 1) (swcols i j_max a)
        }
      }
    };

    def IMrr = rowreduce IM;
    def _ = logg 2 "IMrr" (fun t: () -> def _ = dp IMrr; ());

    def IMrrt = trimrows IMrr;
    def _ = logg 2 "IMrrt" (fun t: () -> def _ = dp IMrrt; ());

    if rdim IMrrt > cdim IMrrt then error BAD_MATRIX
    else {
      def IA = work 1 (real2int IMrrt);
      def _ = logg 2 "IA" (fun t: () -> def _ = dp IA; ());

      def (I, A) = vsplit (rdim IA) IA;
      def T = (if dim A < (1, 1) then arrayToList vs
               else arrayToList (sub vs 0 (rdim A)));
      def C = (if dim A < (1, 1) then []
               else arrayToList (sub vs (rdim A) (Array.length vs)));
      (A, (T, C))
    }
  }
}

def mkTopolRes(bop: (Int -> Dyn -> Dyn -> Dyn), C: MatrixMapInt,
  pvs: [Dyn], svs: [Dyn]) -> [Dyn] = {

  def ipvs = zip (mapToIdx pvs) pvs;
  def jsvs = zip (mapToIdx svs) svs;

  map (fun ipv: (Int, Dyn) -> {
        def (i, pv) = ipv;

        def f(a: Dyn, jsv: (Int, Dyn)) -> Dyn = {
          def (j, sv) = jsv;
          def c = find (i + 1, j + 1) C;
          if c == 0 then a else bop c a sv
        };

        foldLeft f pv jsvs

      }) ipvs
}

def mkScalarTopolEquations(C: MatrixMapInt, pvs: [<Real>], svs: [<Real>], a: Equations)
  -> Equations = {
  def bop(c: Int, l: <Real>, r: <Real>) -> <Real> = { l + (int2real c) * r };
  def rs = mkTopolRes bop C pvs svs;

  def work(rs: [<Real>], a: Equations) -> Equations = {
    match rs with
    | [] -> a
    | r::rs -> work rs (a; r = 0.)
    | _ -> error "Unmatched"
  };

  work rs a
}

def mkVector2TopolEquations(C: MatrixMapInt, pvs: [Vector2], svs: [Vector2], a: Equations)
  -> Equations = {
  def bop(c: Int, l: Vector2, r: Vector2) -> Vector2 = { v2add l (v2prod (int2real c) r) };
  def rs = mkTopolRes bop C pvs svs;

  def work(rs: [Vector2], a: Equations) -> Equations = {
    match rs with
    | [] -> a
    | r::rs -> work rs (a; v2eq r v2zero)
    | _ -> error "Unmatched"
  };

  work rs a
}

def mkTopolEquations(f: (MatrixMapInt -> [Dyn] -> [Dyn] -> Equations -> Equations), mes: [ModelEdge], a: Equations) -> Equations = {
  def (A, (T, C)) = mkCutsetMatrix mes;
  def _ = logg 2 "A" (fun t: () -> def _ = dp A; ());

  def (x_t, y_t) = unzip T;
  def (x_c, y_c) = unzip C;

  def _ = logg 2 "x_t" (loggprint x_t);
  def _ = logg 2 "x_c" (loggprint x_c);

  f A y_t y_c (f (- (tr A)) x_c x_t a)
}

def elaborate(e: Equations) -> Equations = {
  def (ses, e) = getScalarEdges e;
  def (ves, e) = getVector2Edges e;
  def e = (if isEmpty ses then e else mkTopolEquations mkScalarTopolEquations ses e);
  def e = (if isEmpty ves then e else  mkTopolEquations mkVector2TopolEquations ves e);
  cleanupEquations e
}

def GRAVITATIONAL_CONSTANT = 9.81

def Clock(t_0: Real, t: <Real>) = {
  t <- t_0;
  t' <- 1.;
  t' = 1.
}

def ThroughActuator(ff: Vector2, aa: Vector2, n_1: Node, n_2: Node)
  -> Equations = {

  def t_x, t_y: Real;
  def tt = vec t_x t_y;
  vector2Edge n_1 n_2 aa tt;
  i_ tt = i_ ff;
  j_ tt = j_ ff
}

def ThroughActuator(ff: Vector2, n_1: Node, n_2: Node) -> Equations = {
  def x_a, y_a: Real;
  ThroughActuator ff (vec x_a y_a) n_1 n_2
}

def ThroughActuator(f: <Real>, a: <Real>, n_1: Node, n_2: Node)
  -> Equations = {

  def t: Real;
  scalarEdge n_1 n_2 a t;
  t = f
}

def AcrossActuator(ff: Vector2, tt: Vector2, n_1: Node, n_2: Node)
  -> Equations = {

  def a_x, a_y: Real;
  def aa = vec a_x a_y;
  vector2Edge n_1 n_2 aa tt;
  i_ aa = i_ ff;
  j_ aa = j_ ff
}

def AcrossActuator(ff: Vector2, n_1: Node, n_2: Node)
  -> Equations = {

  def t_x, t_y: Real;
  def tt = vec t_x t_y;
  AcrossActuator ff tt n_1 n_2
}

def AcrossActuator(f: <Real>, t: <Real>, n_1: Node, n_2: Node)
  -> Equations = {

  def a: Real;
  scalarEdge n_1 n_2 a t;
  a = f
}

def AcrossActuator(f: <Real>, n_1: Node, n_2: Node) -> Equations = {
  def t: Real;
  AcrossActuator f t n_1 n_2
}

def AcrossController(aa: Vector2, n_1: Node, n_2: Node) -> Equations = {
  ThroughActuator (vec 0. 0.) aa n_1 n_2
}

def AcrossController(a: <Real>, n_1: Node, n_2: Node) -> Equations = {
  ThroughActuator 0. a n_1 n_2
}

def Body(m: Real, I: Real,
         rr: Vector2,
         vv: Vector2,
         FF: Vector2,
         th: <Real>,
         om: <Real>,
         T: <Real>,
         DATUM: Frame, f: Frame) -> Equations = {

  scalarEdge DATUM f th T;
  vector2Edge DATUM f rr FF;
  (i_ rr)' = i_ vv;
  (j_ rr)' = j_ vv;
  i_ FF = m * (i_ vv)';
  j_ FF = m * (j_ vv)';
  th' = om;
  T = I * om'
}

def Body(m: Real, I: Real, rr: Vector2, th: <Real>, DATUM: Frame, f: Frame) -> Equations = {
  def vx_m, vy_m, Fx_m, Fy_m, om_m, T_m: Real;
  Body m I rr (vec vx_m vy_m) (vec Fx_m Fy_m) th om_m T_m DATUM f
}

def Body(m: Real, I: Real, DATUM: Frame, f: Frame) -> Equations = {
  def x_m, y_m, th_m: Real;
  Body m I (vec x_m y_m) th_m DATUM f
}

def Gravity(m: Real, DATUM: Frame, f: Frame) -> Equations = {
  ThroughActuator (vec 0. (m * GRAVITATIONAL_CONSTANT)) DATUM f
}

def RigidArm(l: Real,
             rr: Vector2,
             FF: Vector2,
             th_1: <Real>,
             T_1: <Real>,
             th_2: <Real>,
             T_2: <Real>,
             DATUM: Frame, f_1: Frame, f_2: Frame) -> Equations = {

  scalarEdge f_2 f_1 th_1 T_1;
  scalarEdge DATUM f_2 th_2 T_2;
  vector2Edge f_2 f_1 rr FF;
  i_ rr = -l * cos th_2;
  j_ rr = -l * sin th_2;
  th_1 = 0.;
  T_2 = l * (i_ FF * -sin th_2 + j_ FF * cos th_2)
}

def RigidArm(l: Real, f_1: Frame, f_2: Frame, f_3: Frame) -> Equations = {
  def x_r1, y_r1, Fx_r1, Fy_r1, th_r1, T_r1, th_r2, T_r2: Real;
  RigidArm l (vec x_r1 y_r1) (vec Fx_r1 Fy_r1) th_r1 T_r1 th_r2 T_r2 f_1 f_2 f_3
}

def NoAcceleration(rr: Vector2, vv: Vector2, f_1: Frame, f_2: Frame) -> Equations = {
  def Fx_i, Fy_i, th_i, T_i: Real;
  vector2Edge f_1 f_2 rr (vec Fx_i Fy_i);
  scalarEdge f_1 f_2 th_i T_i;
  (i_ rr)' = i_ vv;
  (j_ rr)' = j_ vv;
  (i_ vv)' = 0.;
  (j_ vv)' = 0.;
  th_i = 0.
}

def NoAcceleration(f_1: Frame, f_2: Frame) -> Equations = {
  def x_i, y_i, vx_i, vy_i: Real;
  NoAcceleration (vec x_i y_i) (vec vx_i vy_i) f_1 f_2
}

def RevoluteJoint(f_1: Frame, f_2: Frame) -> Equations = {
  AcrossActuator (vec 0. 0.) f_1 f_2
}

def Bar(m: Real, h: Real, l: Real, DATUM: Frame, we: Frame, c: Frame, ea: Frame) -> Equations = {
  def I = h * l * (h^2. + l^2.) / 12.;
  RigidArm (l / 2.) DATUM we c;
  RigidArm (l / 2.) DATUM c ea;
  Body m I DATUM c;
  Gravity m DATUM c
}

def Bar(m: Real, h: Real, l: Real, rr: Vector2, th: <Real>, DATUM: Frame, we: Frame, ea: Frame) -> Equations = {
  def c: Frame;
  def I = h * l * (h^2. + l^2.) / 12.;
  RigidArm (l / 2.) DATUM we c;
  RigidArm (l / 2.) DATUM c ea;
  Body m I rr th DATUM c;
  Gravity m DATUM c
}

def Translation(x: Real, y: Real, f_1: Frame, f_2: Frame) -> Equations = {
  AcrossActuator (vec x y) f_1 f_2
  // ; AcrossActuator 0. f_1 f_2
}

def Rotation(th: Real, f_1: Frame, f_2: Frame) -> Equations = {
  AcrossActuator th f_1 f_2
  // ; AcrossActuator (vec 0. 0.) f_1 f_2
}

def RotationalDamper(D: Real, f_1: Frame, f_2: Frame) -> Equations = {
  def th_d, T_d: Real;
  scalarEdge f_1 f_2 th_d T_d;
  T_d = D * th_d'
}
