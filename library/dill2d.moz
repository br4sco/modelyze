/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se

*/

include Matrix
include Graph
include ModelyzeDAE

type Vector2
def vec: Real -> Real -> Vector2
def v2zero = vec 0. 0.

def scalarEdge: Edge -> <Real> -> <Real> -> Equations
def vector2Edge: Edge -> Vector2 -> Vector2 -> Equations

type InitVal = (<Real>, Real)

def iOf(v: Vector2) -> <Real> = {
  match v with
  | vec x _ _ -> x
  | _ -> error "Invalid Operand"
}

def jOf(v: Vector2) -> <Real> = {
  match v with
  | vec _ y _ -> y
  | _ -> error "Invalid Operand"
}

def v2Eq(lhs: Vector2, rhs: Vector2) -> Equations = {
  match lhs with
  | vec lx ly -> {
      match rhs with
      | vec rx ry -> lx = rx; ly = ry
      | _ -> error "Invalid RHS"
    }
  | _ -> error "Invalid LHS"
}
def (=): Vector2 -> Vector2 -> Equations = v2Eq

def v2init(v: Vector2, v_0: Vector2) -> Equations = {
  match v with
  | vec x y -> {
      match v_0 with
      | vec x_0 y_0 -> x <- x_0; y <- y_0
      | _ -> error "Invalid RHS"
    }
  | _ -> error "Invalid LHS"
}
def (<-): Vector2 -> Vector2 -> Equations = v2init

def v2add(lhs: Vector2, rhs: Vector2) -> Vector2 = {
  match lhs with
  | vec lx ly -> {
      match rhs with
      | vec rx ry -> vec (lx + rx) (ly + ry)
      | _ -> error "Invalid RHS"
    }
  | _ -> error "Invalid LHS"
}
def (+): Vector2 -> Vector2 -> Vector2 = v2add

def v2sub(lhs: Vector2, rhs: Vector2) -> Vector2 = {
  match lhs with
  | vec lx ly -> {
      match rhs with
      | vec rx ry -> vec (lx - rx) (ly - ry)
      | _ -> error "Invalid RHS"
    }
  | _ -> error "Invalid LHS"
}
def (-): Vector2 -> Vector2 -> Vector2 = v2sub

def v2chsgn(v: Vector2) -> Vector2 = {
  match v with
  | vec x y -> vec (-x) (-y)
  | _ -> error "Invalid Operand"
}
def (--): Vector2 -> Vector2 = v2chsgn

def v2prod(s: <Real>, v: Vector2) -> Vector2 = {
  match v with
  | vec x y -> vec (s * x) (s * y)
  | _ -> error "Invalid Operand"
}
def (*): <Real> -> Vector2 -> Vector2 = v2prod

def v2der(v: Vector2) -> Vector2 = {
  match v with
  | vec x y -> vec (der x) (der y)
  | _ -> error "Invalid Operand"
}
def ('): Vector2 -> Vector2 = v2der

def getScalarEdges(e: Equations) -> (Equations, Equations) = {
  def work(e: Equations, a: (Equations, Equations)) -> (Equations, Equations)  = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | scalarEdge _ _ _ -> ((fst a); e, snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e (NoEqn, NoEqn)
}

def getVector2Edges(e: Equations) -> (Equations, Equations) = {
  def work(e: Equations, a: (Equations, Equations)) -> (Equations, Equations)  = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | vector2Edge _ _ _ -> ((fst a); e, snd a)
    | _ -> (fst a, (snd a); e)
  };

  work e (NoEqn, NoEqn)
}

def getInits(e: Equations) -> ([InitVal], Equations) = {
  def work(e: Equations, a: ([InitVal], Equations)) -> ([InitVal], Equations)  = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | init v v_0 ->
     {
      match (v, v_0) with
      | (sym: Real, lift v_0: Real) -> ((v, v_0)::(fst a), snd a)
      | _ -> error "Invalid init"
     }
    | _ -> (fst a, (snd a); e)
  };

  work e ([], NoEqn)
}
