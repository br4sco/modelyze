/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Equation
include Graph
include Matrix

type ModelVar = MatrixMapSReal
type Res = MatrixMapSReal
type TransFun = ModelVar -> ModelVar
type ModelVarInit = (ModelVar, MatrixMapReal)
type InitVal = (<Real>, Real)
type VectorModelEdge = (Edge, ([ModelVarInit], ModelVarInit), Res, TransFun, TransFun)
type BaseModelVar = (Node, ModelVar)

def dp(vmd: VectorModelEdge) -> VectorModelEdge = {
  def (e, ((aa, aa_0), (tt, tt_0)), res, _) = vmd;
  def _ = dprint(e);
  def _ = dp aa;
  def _ = dp tt;
  def _ = dp res;
  vmd
}

def sw(a: {Dyn}, i: Int, j: Int) -> () = {
  def n = (Array.length a);
  if i < n && 0 <= i && j < n && 0 <= j then {
    def t = (Array.get a i);
    def _ = (Array.set a i (Array.get a j));
    Array.set a j t
  } else error DIMENSION_MISSMATCH
}
def mapToIdx(l: [Dyn]) -> [Int] = {
  def f(i: Int, e: Dyn) -> Int = { i };
  mapi f l
}

def trans(tm: (Edge => TransFun), p: [Edge], v: ModelVar) -> ModelVar = {
  def f(a: ModelVar, e: Edge) -> ModelVar = {
    if Map.mem e tm then (Map.find e tm) a
    else error "Edge not in trans map"
  };

  foldLeft f v p
}

def getEdge(vme: VectorModelEdge) -> Edge = { fst vme }
def getHighestOrderModelVars(vme: VectorModelEdge) -> (ModelVar, ModelVar) = {
  def (_, (aas, (tt, _)), _, _, _) = vme;
  def (aa, _) = hd aas;
  (aa, tt)
}
def getTerminal(vme: VectorModelEdge) -> Res = {
  def (_, _, res, _, _) = vme; res
}
def getTransFun(vme: VectorModelEdge) -> TransFun = {
  def (_, _, _, tf, _) = vme; tf
}
def getInvTransFun(vme: VectorModelEdge) -> TransFun = {
  def (_, _, _, _, rtf) = vme; rtf
}
def getModelVarInits(vme: VectorModelEdge) -> [ModelVarInit] = {
  def (_, (aais, tti), _, _, _) = vme;
  tti::aais
}

def getTerminals(vmes: [VectorModelEdge]) -> [Res] = {
  map (fun vme: VectorModelEdge -> getTerminal vme) vmes
}

def mkInitVals(vmes: [VectorModelEdge]) -> [InitVal] = {
  concat
  (concat (map (fun vme: VectorModelEdge -> {
      def mvis = getModelVarInits vme;
      map (fun mvi: ModelVarInit -> {
        zip
          (concat (matrixToList (fst mvi)))
          (concat (matrixToList (snd mvi)))
      }) mvis
    }) vmes))
}

def mkScalarModelEdge(e: Edge, at: ((<Real>, Real), (<Real>, Real)), r: <Real>)
  -> VectorModelEdge = {

  def ((a, a_0), (t, t_0)) = at;
  def rsToM(s: Real) = { listToMatrix [[s]] (mmRealZero (1, 1)) };
  def ssToM(s: <Real>) = { listToMatrix [[s]] (mmSRealZero (1, 1)) };
  (e, ([(ssToM a, rsToM a_0)], (ssToM t, rsToM t_0)), ssToM r,
   fun r: ModelVar -> r, fun r: ModelVar -> r)
}

def mkTransMap(vme: VectorModelEdge) -> (Edge => TransFun) = {
  def (n_1, n_2) = getEdge vme;
  listToMap [((n_1, n_2), getTransFun vme), ((n_2, n_1), getInvTransFun vme)]
}

def mkTransMap(vmes: [VectorModelEdge]) -> (Edge => TransFun) = {
  Union (map (fun vme: VectorModelEdge -> mkTransMap vme) vmes)
}

def mkGraph(vmes: [VectorModelEdge]) -> [Edge] = {
  map (fun vme: VectorModelEdge -> getEdge vme) vmes
}

def mkBaseModelVars(vmes: [VectorModelEdge])
  -> [(BaseModelVar, BaseModelVar)] = {
  map (fun vme: VectorModelEdge -> {
    def (n, _) = getEdge vme;
    def (x, y) = getHighestOrderModelVars vme;
    ((n, x), (n, y))
  }) vmes
}

def mkCutsetMatrix(vmes: [VectorModelEdge])
  -> (MatrixMapInt, ([VectorModelEdge], [VectorModelEdge])) = {

  def G = mkGraph vmes;
  def IM = mkIncidenceMatrix G;
  def vmes = listToArray vmes;

  def work(i: Int, a: MatrixMapInt) -> MatrixMapInt = {
    if i > rdim a then a
    else {
      def j_max = snd (argfind (fun v: Int -> v != 0)
                    (sub (i, 1) (i, cdim a) a));
      if i == j_max then work (i + 1) a
      else {
        def _ = sw vmes (i - 1) (j_max - 1);
        work (i + 1) (swcols i j_max a)
      }
    }
  };

  def IMrrt = trimzerorows (rowreduce IM);
  if rdim IMrrt > cdim IMrrt then error BAD_MATRIX
  else {
    def IA = work 1 (real2int IMrrt);
    def (I, A) = vsplit (rdim IA) IA;
    def C = arrayToList (sub vmes 0 (rdim A));
    def T = arrayToList (sub vmes (rdim A) (Array.length vmes));
    (A, (C, T))
  }
}

def mkTopolResiduals(T: AdjList, tm: (Edge => TransFun), C: MatrixMapInt,
  pbmvs: [BaseModelVar], sbmvs: [BaseModelVar]) = {

  def ipbmvs = zip (mapToIdx pbmvs) pbmvs;
  def isbmvs = zip (mapToIdx sbmvs) sbmvs;
  map (fun ipbmv: (Int, BaseModelVar) -> {
    def (i, (n_1, pv)) = ipbmv;

    def isbmvs =
    filter (fun isbmv: (Int, BaseModelVar) -> {
      def (j, sbmv) = isbmv;
      find (i + 1, j + 1) C != 0
    }) isbmvs;

    def smvs =
    map (fun isbmv: (Int, BaseModelVar) -> {
      def (j, (n_2, sv)) = isbmv;
      def p = pathToEdgePath (hd (findPath T n_1 n_2));
      (find (i + 1, j + 1) C, trans tm p sv)
    }) isbmvs;

    def f(r: Res, smv: (Int, ModelVar)) -> Res = {
      def (c, v) = smv;
      r + (int2real c) *. v
    };
    def ress =
    foldLeft f pv smvs;

    ress
  }) ipbmvs
}

def mkTopolResiduals(vmes: [VectorModelEdge]) -> [Res] = {
  def (A, (C, T)) = mkCutsetMatrix vmes;
  def B = -(tr A);
  def eal = edgeList2AdjList (mkGraph (dprintln T));
  def tm = mkTransMap T;
  def (cbxs, cbys) = unzip (mkBaseModelVars C);
  def (tbxs, tbys) = unzip (mkBaseModelVars T);
  def cutres = mkTopolResiduals eal tm A cbys tbys;
  def circres = mkTopolResiduals eal tm B tbxs cbxs;
  append cutres circres
}

def mkResiduals(vmes: [VectorModelEdge]) -> [Real] = {
  def termres = getTerminals vmes;
  def topres = mkTopolResiduals vmes;
  concat (map (fun r: Res -> concat (matrixToList r))
    (append termres topres))
}
