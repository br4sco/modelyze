/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Matrix
include Equation

type Vector
type MatrixMapVector = (Int => (Int => Vector), Pos)
type Base = Set(Vector)
def zeroVector: Vector
def unitVector: Vector
def VECTORS_DIFFERENT_BASES = "Vectors belong to different bases"
def EXPECTED_SYMBOLIC_VECTOR = "Expected lhs to be a symbolic vector"
def UNSUPPORTED_VECTOR_CONSTRUCT = "Unsupported Vector construct"

def (--) : Vector -> Vector
def (-) : Vector -> Vector -> Vector
def (+) : Vector -> Vector -> Vector
def (*.) : Real -> Vector -> Vector
def der : Vector -> Vector
def (') = der
def sin : Vector -> Vector
def cos : Vector -> Vector

// Operators and functions for Vectors (in lack of type polymorphism)
def iszVec(v: Vector) -> Bool = { seq v zeroVector }
def addVec(l: Vector, r: Vector) -> Vector = {
  if iszVec l && iszVec r then zeroVector
  else if iszVec l then r
  else if iszVec r then l
  else {
    match r with
    | - r -> l - r
    | _ -> l + r
  }
}

def prodRealVec(r: Real, v: Vector) -> Vector = {
  if r == 0. then zeroVector
  else if r == 1. then v
  else if r == -1. then - v
  else r *. v
}

def chsgnVec(v: Vector) -> Vector = {
  match v with
  | - v_1 -> v
  | _ -> -v
}

def mmVectorZero(d: (Int, Int)) -> MatrixMapVector = { mmZero d }

def mmVectorAdd(ij: Pos, v: Vector, M: MatrixMapVector) -> MatrixMapVector = {
  mmAdd iszVec ij v M
}
def add: Pos -> Vector -> MatrixMapVector -> MatrixMapVector = mmVectorAdd

def mmVectorFind(ij: Pos, M: MatrixMapVector) -> Vector = { mmFind zeroVector ij M }
def add: Pos -> MatrixMapVector -> Vector = mmVectorFind

def listToMatrix(l: [[Vector]], M: MatrixMapVector) -> MatrixMapVector = {
  listToMatrix mmVectorAdd l M
}
def dp(M: MatrixMapVector) -> MatrixMapVector = { dp mmVectorFind M }

def matrixToList(M: MatrixMapVector) -> [[Vector]] = {
  matrixToList mmVectorFind M
}

def mmVectorProd(lM: MatrixMapReal, rM: MatrixMapVector) -> MatrixMapVector = {
  matrixProd mmRealFind mmVectorFind mmVectorAdd mmVectorZero addVec prodRealVec lM rM
}
def (*): MatrixMapReal -> MatrixMapVector -> MatrixMapVector = mmVectorProd

def tr(M: MatrixMapVector) -> MatrixMapVector = {
  matrixTranspose mmVectorFind mmVectorAdd mmVectorZero M
}

def hsplit(i: Int, M: MatrixMapVector) -> (MatrixMapVector, MatrixMapVector) = {
  matrixHSplit mmVectorFind mmVectorAdd mmVectorZero i M
}

def vsplit(j: Int, M: MatrixMapVector) -> (MatrixMapVector, MatrixMapVector) = {
  matrixVSplit mmVectorFind mmVectorAdd mmVectorZero j M
}

def vconcat(lM: MatrixMapVector, rM: MatrixMapVector) -> MatrixMapVector = {
  matrixConcat mmVectorFind mmVectorAdd mmVectorZero lM rM
}

def hconcat(lM: MatrixMapVector, rM: MatrixMapVector) -> MatrixMapVector = {
  tr (vconcat (tr lM) (tr rM))
}

def vectorToMatrix(f: (Vector -> MatrixMapSReal), v: Vector) -> MatrixMapSReal = {

  def work(v: Vector) -> MatrixMapSReal = {
    match v with
    | sym: Vector -> f v
    | -v -> -(work v)
    | v_1 - v_2 -> (work v_1) - (work v_2)
    | v_1 + v_2 -> (work v_1) + (work v_2)
    | r *. v -> { r *. (work v) }
    | der v -> map (fun r: <Real> -> der r) (work v)
    | sin v -> map (fun r: <Real> -> sin r) (work v)
    | cos v -> map (fun r: <Real> -> cos r) (work v)
    | _ -> { def _ = dprint(v); error UNSUPPORTED_VECTOR_CONSTRUCT }
  };
  work v
}
