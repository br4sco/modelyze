/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include MATRIX

type Frame = Node

def EXPECTED_VECTOR3 = "Expected vector3"
def EXPECTED_QUATERNION = "Expected quaternion"

def ZERO3_R = (0., 0., 0.)
def IDQ_R = (1., 0., 0., 0.)
def XHAT_R = (1., 0., 0.)
def YHAT_R = (0., 1., 0.)
def ZHAT_R = (0., 0., 1.)

type SRMatrix = MatrixMapSReal
type Vector = (SRMatrix, Frame)
type Quaternion = SRMatrix
type Vector3 = Vector
type RealVector3 = (Real, Real, Real)
type RealQuaternion = (Real, Real, Real, Real)

def world: Frame

def vec3(x: <Real>, y: <Real>, z: <Real>) -> Vector3 = {
  (listToMatrix [[x], [y], [z]] (mmSRealZero (3, 1)), world)
}

def vec3(t: ()) -> Vector3 = {
  def x, y, z: <Real>;
  vec3 x y z
}

def vec3(v: RealVector3) -> Vector3 = {
  def (x, y, z) = v;
  vec3 x y z
}

def vec3T(t: ()) -> Vector3 = {
  def v1_test, v2_test, v3_test: Real;
  vec3 v1_test v2_test v3_test
}

def _vm(v: Vector) -> SRMatrix = { fst v }
def _vf(v: Vector) -> Frame = { snd v }

def quat(w: <Real>, i: <Real>, j: <Real>, k: <Real>) -> Quaternion = {
  listToMatrix [[w], [i], [j], [k]] (mmSRealZero (4, 1))
}

def quat(q: RealQuaternion) -> Quaternion = {
  def (w, i, j, k) = q;
  quat w i j k
}

def quat(t: ()) -> Quaternion = {
  def w, i, j, k: <Real>;
  quat w i j k
}

def quatT(t: ()) -> Quaternion = {
  def q1_test, q2_test, q3_test, q4_test: Real;
  quat q1_test q2_test q3_test q4_test
}

def ID3 = mmSRealId 3
def ZERO1 = mmSRealZero (1, 1)
def ZERO3 = vec3 ZERO3_R
def XHAT = vec3 XHAT_R
def YHAT = vec3 YHAT_R
def ZHAT = vec3 ZHAT_R
def IDQ = quat IDQ_R

def toRealVector3(f: Frame, v: Vector3) -> (<Real>, <Real>, <Real>) = {
  def (vm, vf) = v;
  if seq f vf then {
    if dim vm != (3, 1) then error EXPECTED_VECTOR3
    else (find (1, 1) vm, find (2, 1) vm, find (3, 1) vm)
  } else error "Not implemented"
}

def toRealQauternion(q: Quaternion) -> (<Real>, <Real>, <Real>, <Real>) = {
  if dim q != (4, 1) then error EXPECTED_QUATERNION
  else (find (1, 1) q, find (2, 1) q, find (3, 1) q, find (4, 1) q)
}

def q2ea321(q: Quaternion) -> Vector3 = {
  def (w, i, j, k) = toRealQauternion q;
  vec3 (atan(2. * (w * i + j * k) / (1. - 2. * (i^2. + j^2.))))
            (asin(2. * (w * j - k * i)))
            (atan(2. * (w * k + i * j) / (1. - 2. * (j^2. + k^2.))))
}

def q2M(q: Quaternion) = {
  if dim q != (4, 1) then error EXPECTED_QUATERNION
  else {
    def (q0, q1, q2, q3) = toRealQauternion q;
    listToMatrix [
                  [ q0, -q1, -q2, -q3],
                  [ q1,  q0, -q3,  q2],
                  [ q2,  q3,  q0, -q1],
                  [ q3, -q2,  q1,  q0]
                 ] (mmSRealZero (4, 4))
  }
}

def M2q(M: Quaternion) = {
  if dim M != (4, 4) then error DIMENSION_MISSMATCH
  else {
    def q0 = find (1, 1) M;
    def q1 = find (2, 1) M;
    def q2 = find (3, 1) M;
    def q3 = find (4, 1) M;
    quat q0 q1 q2 q3
  }
}

def qprod(p: Quaternion, q: Quaternion) = { M2q ((q2M p) * (q2M q)) }

def qconj(q: Quaternion) = { M2q (tr (q2M q)) }

def qim(q: Quaternion) = {
  def (w, i, j, k) = toRealQauternion q;
  vec3 i j k
}

def qre(q: Quaternion) = {
  def (w, i, j, k) = toRealQauternion q;
  w
}

def norm2(v: Quaternion) -> <Real> = {
  def f(a: <Real>, ij: Pos) -> <Real> = {
    a + (find ij v)^2.
  };
  def z: <Real> = 0.;

  if cdim v != 1 && rdim v <= 0 then error DIMENSION_MISSMATCH
  else {
    foldij f z v
  }
}

def dot(l: Vector, r: Vector) -> <Real> = {
  def (lm, lf) = l;
  def (rm, rf) = r;
  if seq lf rf then {
    if dim lm != dim rm then error DIMENSION_MISSMATCH
    else hd (hd (matrixToList ((tr lm) * rm)))
  } else error "Not implemented"
}

def normalize(v: Vector) -> Vector = { vec3 (1. / sqrt(norm2 v)) *. v }

def mkOrthogonalBasis(u: RealVector3) -> (Vector3, Vector3, Vector3) = {
  def findNonParallelVector(v: Vector3) = {
    def (sval x: Real, sval y: Real, sval z: Real) = toRealVector3 world v;
    if x == 0. then vec3 1. y z
    else if y == 0. then vec3 x 1. z
    else if z == 0. then vec3 x y 1.
    else vec3 x (2. * y) (3. * z)
  };

  def u1 = vec3 u;
  def v = findNonParallelVector u1;
  def u2 = ss u1 * v;
  def u3 = ss u1 * u2;
  (u1, u2, u3)
}


def vectorFold2(f: (Dyn -> <Real> -> <Real> -> Dyn), a: Dyn,
  v1: Vector, v2: Vector) -> Dyn = {

  if dim v1 != dim v2 || rdim v1 < 1 || cdim v1 > 1 then
    error DIMENSION_MISSMATCH
  else {
    def ff(a: Dyn, ij: Pos) -> Dyn = { f a (find ij v1) (find ij v2) };
    foldij ff a v1
  }
}

def vectorFoldHead2(fa: (Dyn -> Dyn -> Dyn), f: (<Real> -> <Real> -> Dyn),
  v1: Vector, v2: Vector) -> Dyn = {

  if dim v1 != dim v2 || rdim v1 < 1 || cdim v1 > 1 then
    error DIMENSION_MISSMATCH
  else {
    def h = f (find (1, 1) v1) (find (1, 1) v2);
    if dim v2 == (1, 1) then h
    else {
      def lt = sub (2, 1) (dim v1) v1;
      def rt = sub (2, 1) (dim v2) v2;
      def ff(a: Model, ij: Pos) -> Model = {
        fa a (f (find ij lt) (find ij rt))
      };
      foldij ff h lt
    }
  }
}

def eaa2quat(th: Real, u: RealVector3) = {
  def (x, y, z) = u;
  def n = sqrt(x^2. + y^2. + z^2.);
  (cos (th / 2.), (x / n) * sin (th / 2.), (y / n) * sin (th / 2.),
    (z / n) * sin (th / 2.))
}

def quat2eaa(q: Quaternion) -> (<Real>, Vector3) = {
  def (w, i, j, k) = toRealQauternion q;
  def d = sqrt(1. - w * w + EPSILON);
  (2. * acos w, vec3 (i / d) (j / d) (k /d))
}

def vectorEqual(l: Vector, r: Vector) -> Model = {
  def fa(a: Model, e: Model) -> Model = { a; e };
  def f(l: <Real>, r: <Real>) -> Model = { l = r };
  vectorFoldHead2 fa f l r
}
def (=) = vectorEqual

def vectorInitEqual(l: Vector, r: Vector) -> Model = {
  def fa(a: Model, e: Model) -> Model = { a; e };
  def f(l: <Real>, r: <Real>) -> Model = { l ~= r };
  vectorFoldHead2 fa f l r
}
def (~=) = vectorInitEqual

def vectorInit(l: Vector, r: Vector) -> Model = {
  def fa(a: Model, e: Model) -> Model = { a; e };
  def f(l: <Real>, r: <Real>) -> Model = { l <~ r };
  vectorFoldHead2 fa f l r
}
def (<~) = vectorInit

def matrixDer(M: SRMatrix) -> SRMatrix = {
  def f(e: <Real>) -> <Real> = { e' };
  map f M
}
def (') = matrixDer
