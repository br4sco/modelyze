/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Matrix
include Equation

type Vector
type MatrixMapVector = (Int => (Int => Vector), Pos)
type Base = Set(Vector)
def zeroVector: Vector
def U: Vector
def VECTORS_DIFFERENT_BASES = "Vectors belong to different bases"
def EXPECTED_SYMBOLIC_VECTOR = "Expected lhs to be a symbolic vector"

def (--) : Vector -> Vector
def (-) : Vector -> Vector -> Vector
def (+) : Vector -> Vector -> Vector
def (*) : Real -> Vector -> Vector
def der : Vector -> Vector
def (') = der
def sin : Vector -> Vector
def cos : Vector -> Vector

// Operators and functions for Vectors (in lack of type polymorphism)
def iszVec(v: Vector) -> Bool = { seq v zeroVector }
def isuVec(v: Vector) -> Bool = { seq v U }
def addVec(l: Vector, r: Vector) -> Vector = {
  if iszVec l && iszVec r then zeroVector
  else if iszVec l then r
  else if iszVec r then l
  else {
    match r with
    | - r -> l - r
    | _ -> l + r
  }
}

def prodRealVec(r: Real, v: Vector) -> Vector = {
  if r == 0. then zeroVector
  else if r == 1. then v
  else if r == -1. then - v
  else r * v
}
// def prodVecReal(v: Vector, r: Real) -> Vector = {
//   prodRealVec r v
// }

// def ldotprod(f: (Vector -> Vector -> Real), lhs: Vector, rhs: Vector) -> <Real> = {

//   def work(v: Vector) -> <Real> = {
//     match v with
//     | sym: Vector -> {
//         if iszVec v then 0.
//         else if isuVec v then 1.
//         else f lhs v
//       }
//     | -v -> chsgnSReal (work v)
//     | v_1 - v_2 -> addSReal (work v_1) (chsgnSReal (work v_2))
//     | v_1 + v_2 -> addSReal (work v_1) (work v_2)
//     | r * v -> prodSReal r (work v)
//     | f v -> f (work v)
//   };

//   match lhs with
//   | sym: Vector -> if iszVec lhs || iszVec rhs then 0. else work rhs
//   | _ -> error EXPECTED_SYMBOLIC_VECTOR
// }

// def lldotprod(f: (Vector -> Vector -> Real), lhs: Vector, rhs: Vector) -> <Real> = {
//   def work(l: Vector, r: Vector) -> <Real> = {
//     match (l, r) with
//     | (sym: Vector, sym: Vector) -> f l r
//     | (sym: Vector, v) -> ldotprod f l r
//     | (-v, r) -> work v (-r)
//     | (v_1 - v_2, r) -> work

//   };

// }

// def onbvDotprod(onb: Base, l: Vector, r: Vector) -> Real = {
//   if (Set.mem l onb) && (Set.mem r onb) then {
//     if seq l r then 1.  else 0.
//   } else error VECTORS_DIFFERENT_BASES
// }

// def map(f: (Vector -> Vector), v: Vector) -> Vector = {
//   def work(v: Vector) -> Vector = {
//     match v with
//     | sym: Vector -> f v
//     | op v -> op (work v)
//   };
//   work v
// }

// def chgBase(b: Base, f: (Vector -> Vector), v: Vector) -> Vector = {
//   def ff(v: Vector) -> Vector = { if (Set.mem v b) then v else f v };
//   map ff v
// }

def chsgnVec(v: Vector) -> Vector = {
  match v with
  | - v_1 -> v
  | _ -> -v
}

// def reduce(v: Vector) -> Vector = {
//   match v with
//   | - v_1 -> {
//       def rv_1 = reduce v_1;
//       if iszVec rv_1 then rv_1 else - rv_1
//     }
//   | der v_1 -> {
//       def rv_1 = reduce v_1;
//       if iszVec rv_1 then rv_1 else der rv_1
//     }
//   | v_1 + v_2 -> {
//       def rv_1 = reduce v_1;
//       def rv_2 = reduce v_2;
//       if iszVec rv_1 then rv_2 else {
//         if iszVec rv_2 then rv_1 else rv_1 + rv_2
//       }
//     }
//   | v_1 - v_2 -> {
//       def rv_1 = reduce v_1;
//       def rv_2 = reduce (- v_2);
//       if iszVec rv_1 then rv_2 else {
//         if iszVec rv_2 then rv_1 else rv_1 + rv_2
//       }
//     }
//   | (sval r: Real) * v_2 -> {
//       if r == 0. then zeroVector else {
//         if r == 1. then reduce v_2 else {
//           if r == -1. then reduce (- v_2) else {
//             def rv_2 = reduce v_2;
//             if iszVec rv_2 then rv_2 else r * rv_2
//           }
//         }
//       }
//     }
//   | _ -> v
// }

def mmVectorZero(d: (Int, Int)) -> MatrixMapVector = { mmZero d }

def mmVectorAdd(ij: Pos, v: Vector, M: MatrixMapVector) -> MatrixMapVector = {
  mmAdd iszVec ij v M
}
def add: Pos -> Vector -> MatrixMapVector -> MatrixMapVector = mmVectorAdd

def mmVectorFind(ij: Pos, M: MatrixMapVector) -> Vector = { mmFind zeroVector ij M }
def add: Pos -> MatrixMapVector -> Vector = mmVectorFind

def listToMatrix(l: [[Vector]], M: MatrixMapVector) -> MatrixMapVector = {
  listToMatrix mmVectorAdd l M
}
def dp(M: MatrixMapVector) -> MatrixMapVector = { dp mmVectorFind M }

def matrixToList(M: MatrixMapVector) -> [[Vector]] = {
  matrixToList mmVectorFind M
}

def mmVectorProd(lM: MatrixMapReal, rM: MatrixMapVector) -> MatrixMapVector = {
  matrixProd mmRealFind mmVectorFind mmVectorAdd mmVectorZero addVec prodRealVec lM rM
}
def (*): MatrixMapReal -> MatrixMapVector -> MatrixMapVector = mmVectorProd

// def mmVectorProd(lM: MatrixMapVector, rM: MatrixMapReal) -> MatrixMapVector = {
//   matrixProd mmVectorFind mmRealFind mmVectorAdd mmVectorZero addVec prodVecReal lM rM
// }
// def (*): MatrixMapVector -> MatrixMapReal -> MatrixMapVector = mmVectorProd

def tr(M: MatrixMapVector) -> MatrixMapVector = {
  matrixTranspose mmVectorFind mmVectorAdd mmVectorZero M
}

def hsplit(i: Int, M: MatrixMapVector) -> (MatrixMapVector, MatrixMapVector) = {
  matrixHSplit mmVectorFind mmVectorAdd mmVectorZero i M
}

def vsplit(j: Int, M: MatrixMapVector) -> (MatrixMapVector, MatrixMapVector) = {
  matrixVSplit mmVectorFind mmVectorAdd mmVectorZero j M
}

def vconcat(lM: MatrixMapVector, rM: MatrixMapVector) -> MatrixMapVector = {
  matrixConcat mmVectorFind mmVectorAdd mmVectorZero lM rM
}

def hconcat(lM: MatrixMapVector, rM: MatrixMapVector) -> MatrixMapVector = {
  tr (vconcat (tr lM) (tr rM))
}

// def vectorToMatrix(f: (Vector -> MatrixMapSReal), v: Vector) -> MatrixMapSReal = {
//   def work(v: Vector) -> MatrixMapReal = {
//     match v with
//     | sym: Vector -> f v
//     | v_1 - v_2 ->
//   };

// }
