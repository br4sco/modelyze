/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include DILL2D

type Label = (<Real>, String)
type IValMap = (<Real> => Real)
type Interval = (Real, Real)
type SolverInit = (Residual, UkMap, {Real}, {Real})

def updYYYP(s: IValMap, ukm: UkMap, y: {Real}, yp: {Real}) -> () = {
  def f(v: <Real>, ib: (Int, Bool)) -> () = {
    def (i, _) = ib;
    def _ = (if Map.mem v s then (Array.set y i (Map.find v s)) else ());
    if Map.mem (v') s then (Array.set yp i (Map.find (v') s)) else ()
  };
  iter f ukm
}

def indexReduction(e: Equations, s: IValMap) -> (Equations, IValMap) = {
  def (e, dm) = indexReducationPantelides e (Map.empty);

  def f(k: <Real>, d: <Real>, a: IValMap) -> IValMap = {
    def a = (if Map.mem (k') s then Map.add d (Map.find (k') s) a else a);
    if Map.mem (k'') s then Map.add (d') (Map.find (k'') s) a else a
  };

  (e, fold f dm s)
}

def printLabels(lbs: [Label]) -> () = {
  def _ = print "t";
  def _ = iter (fun lb: Label -> print ("\t\t" ++ (snd lb))) lbs;
  print "\n"
}

def printSimState(lbs: [Label], ukm: UkMap, t: Real, yy: {Real}, yp: {Real}) -> ()  = {
  def ev(v: <Real>) -> Real = { evalFromArrays v ukm yy yp };
  def _ = print (real2string t);
  def _ = iter (fun lb: Label ->
                print ("\t\t" ++ (real2string (ev (fst lb))))
               ) lbs;
  print "\n"
}

def printState(ukm: UkMap, yy: {Real}, yp: {Real}) -> () = {
  def f(k: <Real>, d: (Int, Bool)) -> () = {
    def (i, b) = d;
    def _ = dprint(k);
    def _ = print " <- ";
    def _ = print (real2string (Array.get yy i));
    def _ = print "\t";
    def _ = dprint(k');
    def _ = print " <- ";
    def _ = print (real2string (Array.get yp i));
    if b then print "(D)\n" else print "\n"
  };
  iter f ukm
}

def printResidual(rs: [(Equations, Real)]) -> () = {
  iter (fun r: (Equations, Real) -> def _ = dprint(fst r); println (" -> " ++ real2string (snd r))) rs
}

def init(e: Equations, ivm: IValMap) -> SolverInit = {
  def ukm = makeUkMap e;
  def n = (Map.size ukm);
  def resf = peval (makeResidual ukm e);
  def yy = (Array.make n 0.);
  def yp = (Array.make n 0.);
  def ivm =  setIdIvs e ivm;
  def _ = updYYYP ivm ukm yy yp;
  (resf, ukm, yy, yp)
}

def solve(si: SolverInit, I: Interval, h: Real, lbls: [Label]) -> ()  = {
  def dt = 0.00001;
  def (resf, ukm, yy, yp) = si;
  def (t_0, t_f) = I;

  def dps = (fun t: () -> printState ukm yy yp);
  def vids = initConditionCorrection ukm;
  def ss = (DAESolver.init resf t_0 yy yp);
  def _ = (DAESolver.setStopTime ss t_f);
  def _ = (DAESolver.calcIcYaYdp ss vids yy yp (t_0 + dt));
  def _ = logg 1 "Calculated IVs" dps;

  def ps = (fun t: (Real) -> printSimState lbls ukm t yy yp);

  def go(tr: (Real, SolverResult)) -> () = {
    def (t, r) = tr;
    if r == DAE_SOLVER_RESULT_STOP_TIME_REACHED then ()
    else {
        def _ = ps t;
        go (DAESolver.solveNormal ss (t + h) yy yp)
      }
  };

  def _ = printLabels lbls;
  go (t_0 + dt, DAE_SOLVER_RESULT_SUCCESS)
}

def simulate(m: Equations, I: Interval, h: Real, lbls: [Label]) -> () = {
  def (ivs, m) = getInits m;
  def ivs = map (fun iv: (<Real>, (Real, Bool)) -> (fst iv, fst (snd iv))) ivs;
  def ivm = listToMap ivs;
  def (e, _) = getEquations m;
  def e = elaborate e;

  def _ = logg 1 "Equations" (loggprintln e);

  def _ = (if LOGGLEVEL > 0 then {
             def (t_0, _) = I;
             def (resf, ukm, yy, yp) = init e ivm;
             def dps = (fun t: () -> printState ukm yy yp);
             def _ = logg 1 "Assigned Ivs" dps;
             logg 1 "Residual" (fun t: () -> printResidual (zip (contToList e) (resf t_0 yy yp)))
           } else ());

  def (e, _) = indexReduction e ivm;

  def _ = logg 1 "IR Equations" (loggprintln e);

  def si = init e ivm;
  def (_, ukm, yy, yp) = si;

  solve si I h lbls
}

def simulate(m: Equations, I: Interval, h: Real) -> () = {
  def (e, _) = getEquations m;
  def lbls = map (fun uk: <Real> -> (uk, symstr(uk))) (getUknowns e);
  simulate m I h lbls
}
