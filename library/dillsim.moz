/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include DILL2D

type Label = (<Real>, String)
type StateMap = (<Real> => Real)
type Interval = (Real, Real)

def updYYYP(s: StateMap, ukm: UkMap, y: {Real}, yp: {Real}) -> () = {
  def f(v: <Real>, ib: (Int, Bool)) -> () = {
    def (i, _) = ib;
    def _ = (if Map.mem v s then (Array.set y i (Map.find v s)) else ());
    if Map.mem (v') s then (Array.set yp i (Map.find (v') s)) else ()
  };
  iter f ukm
}

def indexReduction(e: Equations, s: StateMap) -> (Equations, StateMap) = {
  def (e, dm) = indexReducationPantelides e (Map.empty);

  def f(k: <Real>, d: <Real>, a: StateMap) -> StateMap = {
    def a = (if Map.mem (k') s then Map.add d (Map.find (k') s) a else a);
    if Map.mem (k'') s then Map.add (d') (Map.find (k'') s) a else a
  };

  (e, fold f dm s)
}

def printLabels(lbs: [Label]) -> () = {
  def _ = print "t";
  def _ = iter (fun lb: Label -> print ("\t\t" ++ (snd lb))) lbs;
  print "\n"
}

def printSimState(lbs: [Label], ukm: UkMap, t: Real, yy: {Real}, yp: {Real}) -> ()  = {
  def ev(v: <Real>) -> Real = { evalFromArrays v ukm yy yp };
  def _ = print (real2string t);
  def _ = iter (fun lb: Label ->
                print ("\t\t" ++ (real2string (ev (fst lb))))
               ) lbs;
  print "\n"
}

def printState(ukm: UkMap, yy: {Real}, yp: {Real}) -> () = {
  def f(k: <Real>, d: (Int, Bool)) -> () = {
    def (i, b) = d;
    def _ = dprint(k);
    def _ = print " <- ";
    def _ = print (real2string (Array.get yy i));
    def _ = print "\t";
    def _ = dprint(k');
    def _ = print " <- ";
    def _ = print (real2string (Array.get yp i));
    if b then print "(D)\n" else print "\n"
  };
  iter f ukm
}


def simulate(m: Equations, I: Interval, h: Real, lbls: [Label]) = {
  def dt = 0.00001;
  def (t_0, t_f) = I;

  def (s, m) = getInits m;
  def e = elaborate m;
  def _ = logg 1 "Equations" (loggprintln e);

  def (e, s) = indexReduction e (listToMap s);
  def _ = logg 1 "IR Equations" (loggprintln e);

  def ukm = makeUkMap e;
  def n = (Map.size ukm);
  def resf = peval (makeResidual ukm e);
  def yy = (Array.make n 0.);
  def yp = (Array.make n 0.);

  def dps = (fun t: () -> printState ukm yy yp);

  def _ = updYYYP s ukm yy yp;
  def _ = logg 1 "Assigned IVs" dps;

  def vids = initConditionCorrection ukm;
  def ss = (DAESolver.init resf t_0 yy yp);
  def _ = (DAESolver.setStopTime ss t_f);
  def _ = (DAESolver.calcIcYaYdp ss vids yy yp (t_0 + dt));
  def _ = logg 1 "Calculated IVs" dps;

  def ps = (fun t: (Real) -> printSimState lbls ukm t yy yp);

  def go(tr: (Real, SolverResult)) -> () = {
    def (t, r) = tr;
    if r == DAE_SOLVER_RESULT_STOP_TIME_REACHED then ()
    else {
        def _ = ps t;
        go (DAESolver.solveNormal ss (t + h) yy yp)
      }
  };

  def _ = printLabels lbls;
  go (t_0 + dt, DAE_SOLVER_RESULT_SUCCESS)
}
