/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Vector3

type Quaternion
def quat: Real -> Real -> Real -> Real -> Quaternion
def pquat: Vector3 -> Quaternion
def qprod: Quaternion -> Quaternion -> Quaternion
def qsprod: Real -> Quaternion -> Quaternion
def qadd: Quaternion -> Quaternion -> Quaternion
def qconj: Quaternion -> Quaternion
def qder: Quaternion -> Quaternion
def qim: Quaternion -> Vector3
def qre: Quaternion -> Real
def qnorm2: Quaternion -> Real
def (==.): Quaternion -> Quaternion -> Equations
def (~==.): Quaternion -> Quaternion -> Equations
def (<~~.): Quaternion -> Quaternion -> Equations

def (*) = qprod
def (*) = qsprod
def (+) = qadd
def (') = qder
def q_ = pquat
def norm2 = qnorm2

type RealQuaternion = (Real, Real, Real, Real)

def norm2(q: RealQuaternion) = {
  def (w, i, j, k) = q;
  w^2. + i^2. + j^2. + k^2.
}

def conj(q: RealQuaternion) = {
  def (w, i, j, k) = q;
  (w, -i, -j, -k)
}

def ea2quat(th: Real, x: Real, y: Real, z: Real) = {
  def n = sqrt(x^2. + y^2. + z^2.);
  (cos (th / 2.), (x / n) * sin (th / 2.), (y / n) * sin (th / 2.), (z / n) * sin (th / 2.))
}

def quat2tuple(q: Quaternion) -> (<Real>, <Real>, <Real>, <Real>) = {
  match q with
  | quat w i j k -> (w, i, j, k)
  | _ -> error "Expected Quaternion"
}

def idq = quat 1. 0. 0. 0.

def mkQuat(q: RealQuaternion) -> Quaternion = { def (w, i, j, k) = q; quat w i j k }

type QuaternionUkMap = (Quaternion => Quaternion)

def L(q: Quaternion, v: Vector3) -> Vector3 = {
  qim (q * (pquat v) * (qconj q))
}

def mkQuaternionUkMap(e: <>) -> QuaternionUkMap = {
  def work(e: <>, a: QuaternionUkMap) -> QuaternionUkMap = {
    match e with
    | e_1 e_2 -> work e_2 (work e_1 a)
    | sym: Quaternion -> {
          if Map.mem e a then a
          else {
            def w, i, j, k: Real;
            Map.add e (quat w i j k) a
          }
        }
    | _ -> a
  };
  work e (Map.empty)
}

def quat2scalarVec3(q: Quaternion) -> (<Real>, Vector3) = {
  def z: <Real> = 0.;
  def work(q: Quaternion) -> (<Real>, Vector3) = {
    match q with
    | sym: Quaternion -> error "Unkown of Quaternion type not in Quaternion uknown map"
    | quat w i j k -> (w, vec3 i j k)
    | pquat v -> (z, v)
    | qconj q -> { def (q_0, qq) = work q; (q_0, -qq) }
    | qder q -> { def (q_0, qq) = work q; (q_0', qq') }
    | qsprod s q -> { def (q_0, qq) = work q; (s * q_0, s * qq) }
    | qprod p q -> {
        def (p_0, pp) = work p;
        def (q_0, qq) = work q;
        (p_0 * q_0 - dot pp qq, p_0 * qq + q_0 * pp + cross pp qq)
      }
    | qadd p q -> {
        def (p_0, pp) = work p;
        def (q_0, qq) = work q;
        (p_0 + q_0, pp + qq)
      }
    | _ -> { def _ = dprintln q; error "Unmatched" }
  };

  work q
}

def applyQuatToVector3Ops(e: <>) -> <> = {
  def work(e: <>) -> <> = {
    match e with
    | qim q -> snd (quat2scalarVec3 (work q))
    | e_1 e_2 -> (work e_1) (work e_2)
    | _ -> e
  };

  work e
}

def applyQuatToRealOps(e: <>) -> <> = {
  def work(e: <>) -> <> = {
    match e with
    | qnorm2 q -> fst (quat2scalarVec3 (qprod (qconj q) q))
    | qre q -> fst (quat2scalarVec3 q)
    | e_1 e_2 -> (work e_1) (work e_2)
    | _ -> e
  };

  work e
}

def evalQuat(q: Quaternion) -> Quaternion = {
  def q = applyQuatToRealOps (applyQuatToVector3Ops q);
  def (q_0, qq) = quat2scalarVec3 q;
  def w = applyVec2RealOptrs q_0;
  def qq = evalVector3 qq;
  match qq with
  | vec3 i j k -> quat w i j k
  | _ -> error ("Did not expect: " ++ symstr(qq))
}

def quat2RealQuat(q: Quaternion) -> RealQuaternion = {
  match q with
  | quat w i j k -> (evalReal w, evalReal i, evalReal j, evalReal k)
  | _ -> error ("Did not expect: " ++ symstr(q))
}

def toVector3Equations(e: Equations) -> Equations = {
  def ukm = mkQuaternionUkMap e;
  def e = subs e ukm;

  def work(e: Equations, a: Equations) -> Equations = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | p ==. q-> {
        def (p_0, pp) = quat2scalarVec3 p;
        def (q_0, qq) = quat2scalarVec3 q;
        a; p_0 = q_0; pp == qq
      }
    | p ~==. q-> {
        def (p_0, pp) = quat2scalarVec3 p;
        def (q_0, qq) = quat2scalarVec3 q;
        a; p_0 ~= q_0; pp ~== qq
      }
    | p <~~. q -> {
        def (p_0, pp) = quat2scalarVec3 p;
        def (q_0, qq) = quat2scalarVec3 q;
        a; p_0 <~ q_0; pp <~~ qq
      }
    | _ -> a; e
  };

  applyQuatToRealOps (applyQuatToVector3Ops (work e NoEqn))
}
