/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include Vector3

type Quaternion
def quat: Real -> Real -> Real -> Real -> Quaternion
def pquat: Vector3 -> Quaternion
def qprod: Quaternion -> Quaternion -> Quaternion
def qsprod: Real -> Quaternion -> Quaternion
def qadd: Quaternion -> Quaternion -> Quaternion
def qconj: Quaternion -> Quaternion
def qder: Quaternion -> Quaternion
def qim: Quaternion -> Vector3
def qre: Quaternion -> Real
def qnorm2: Quaternion -> Real
def (==.): Quaternion -> Quaternion -> Equations

def (*) = qprod
def (*) = qsprod
def (+) = qadd
def (') = qder
def q_ = pquat
def norm2 = qnorm2

def unitq = quat 1. 0. 0. 0.

type QuaternionUkMap = (Quaternion => Quaternion)

def L(q: Quaternion, v: Vector3) -> Vector3 = {
  qim (q * (pquat v) * (qconj q))
}

def mkQuaternionUkMap(e: <>) -> QuaternionUkMap = {
  def work(e: <>, a: QuaternionUkMap) -> QuaternionUkMap = {
    match e with
    | e_1 e_2 -> work e_2 (work e_1 a)
    | sym: Quaternion -> {
          if Map.mem e a then a
          else {
            def w, i, j, k: Real;
            Map.add e (quat w i j k) a
          }
        }
    | _ -> a
  };
  work e (Map.empty)
}

def quat2scalarVec3(q: Quaternion, ukm: QuaternionUkMap) -> (<Real>, Vector3) = {
  def z: <Real> = 0.;
  def work(q: Quaternion) -> (<Real>, Vector3) = {
    match q with
    | sym: Quaternion -> {
        if Map.mem q ukm then work (Map.find q ukm)
        else error "Unkown of Quaternion type not in Quaternion uknown map"
      }
    | quat w i j k -> (w, vec3 i j k)
    | pquat v -> (z, v)
    | qconj q -> { def (q_0, qq) = work q; (q_0, -qq) }
    | qder q -> { def (q_0, qq) = work q; (q_0', qq') }
    | qsprod s q -> { def (q_0, qq) = work q; (s * q_0, s * qq) }
    | qprod p q -> {
        def (p_0, pp) = work p;
        def (q_0, qq) = work q;
        (p_0 * q_0 - dot pp qq, p_0 * qq + q_0 * pp + cross pp qq)
      }
    | qadd p q -> {
        def (p_0, pp) = work p;
        def (q_0, qq) = work q;
        (p_0 + q_0, pp + qq)
      }
    | _ -> { def _ = dprintln q; error "Unmatched" }
  };

  work q
}

def applyQuatToVector3Ops(e: <>, ukm: QuaternionUkMap) -> <> = {
  def work(e: <>) -> <> = {
    match e with
    | qim q -> snd (quat2scalarVec3 q ukm)
    | e_1 e_2 -> (work e_1) (work e_2)
    | _ -> e
  };

  work e
}

def applyQuatToRealOps(e: <>, ukm: QuaternionUkMap) -> <> = {
  def work(e: <>) -> <> = {
    match e with
    | qnorm2 q -> fst (quat2scalarVec3 (qprod (qconj q) q) ukm)
    | qre q -> fst (quat2scalarVec3 q)
    | e_1 e_2 -> (work e_1) (work e_2)
    | _ -> e
  };

  work e
}

def toVector3Equations(e: Equations) -> Equations = {
  def ukm = mkQuaternionUkMap e;

  def work(e: Equations, a: Equations) -> Equations = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | l ==. r -> {
        def (l_0, ll) = quat2scalarVec3 l ukm;
        def (r_0, rr) = quat2scalarVec3 r ukm;
        a; l_0 = r_0; ll == rr
      }
    | _ -> a; e
  };

  applyQuatToRealOps (applyQuatToVector3Ops (work e NoEqn) ukm) ukm
}
