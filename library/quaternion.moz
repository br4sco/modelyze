include Vector3

type Quaternion
def quat: Real -> Real -> Real -> Real -> Quaternion
def pquat: Vector3 -> Quaternion
def qprod: Quaternion -> Quaternion -> Quaternion
def qconj: Quaternion -> Quaternion
def qder: Quaternion -> Quaternion
def qim: Quaternion -> Vector3
def qnorm: Quaternion -> Real
def (==.): Quaternion -> Quaternion -> Equations

type QuaternionUkMap = (Quaternion => Quaternion)

def L(q: Quaternion, v: Vector3) -> Vector3 = {
  qim (qprod q (qprod (pquat v) (qconj q)))
}

def mkQuaternionUkMap(e: <>) -> QuaternionUkMap = {
  def work(e: <>, a: QuaternionUkMap) -> QuaternionUkMap = {
    match e with
    | e_1 e_2 -> work e_2 (work e_1 a)
    | sym: Quaternion -> {
          if Map.mem e a then a
          else {
            def w, i, j, k: Real;
            Map.add e (quat w i j k) a
          }
        }
    | _ -> a
  };
  work e (Map.empty)
}

def quat2scalarVec3(q: Quaternion, ukm: QuaternionUkMap) -> (<Real>, Vector3) = {
  def z: <Real> = 0.;
  def work(q: Quaternion) -> (<Real>, Vector3) = {
    match q with
    | sym: Quaternion -> {
        if Map.mem q ukm then work (Map.find q ukm)
        else error "Unkown of Quaternion type not in Quaternion uknown map"
      }
    | quat w i j k -> (w, vec3 i j k)
    | pquat v -> (z, v)
    | qconj q -> { def (q_0, qq) = work q; (q_0, -qq) }
    | qder q -> { def (q_0, qq) = work q; (q_0', qq') }
    | qprod p q -> {
        def (p_0, pp) = work p;
        def (q_0, qq) = work q;
        (p_0 * q_0 - dot pp qq, p_0 * qq + q_0 * pp + cross pp qq)
      }
    | _ -> { def _ = dprintln q; error "Unmatched" }
  };

  work q
}

def applyQim(e: <>, ukm: QuaternionUkMap) -> <> = {
  def work(e: <>) -> <> = {
    match e with
    | qim q -> snd (quat2scalarVec3 q ukm)
    | e_1 e_2 -> (work e_1) (work e_2)
    | _ -> e
  };

  work e
}

def applyQnorm(e: <>, ukm: QuaternionUkMap) -> <> = {
  def work(e: <>) -> <> = {
    match e with
    | qnorm q -> fst (quat2scalarVec3 (qprod (qconj q) q) ukm)
    | e_1 e_2 -> (work e_1) (work e_2)
    | _ -> e
  };

  work e
}

def toVector3Equations(e: Equations) -> Equations = {
  def ukm = mkQuaternionUkMap e;

  def work(e: Equations, a: Equations) -> Equations = {
    match e with
    | e_1; e_2 -> work e_2 (work e_1 a)
    | l ==. r -> {
        def (l_0, ll) = quat2scalarVec3 l ukm;
        def (r_0, rr) = quat2scalarVec3 r ukm;
        a; l_0 = r_0; ll == rr
      }
    | _ -> a; e
  };

  applyQnorm (applyQim (work e NoEqn) ukm) ukm
}
