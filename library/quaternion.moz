include Matrix

type Quaternion = MatrixMapSReal

def mkQuaternion(w: <Real>, i: <Real>, j: <Real>, k: <Real>) -> Quaternion = {
  listToMatrix [[w], [i], [j], [k]] (mmSRealZero (4, 1))
}

def mkQuaternion(q_0: <Real>, qq: MatrixMapSReal) -> Quaternion = {
  if dim qq == (3, 1) then hconcat (listToMatrix [[q_0]] (mmSRealZero (1, 1))) qq
  else error "Invalid Vector dimensions"
}

def mkQuaternion(v: MatrixMapSReal) -> Quaternion = { mkQuaternion(0., v) }

def _re(q: Quaternion) -> MatrixMapSReal = { sub (1, 1) (1, 1) q }
def re(q: Quaternion) -> <Real> = { find (1, 1) q }
def im(q: Quaternion) -> MatrixMapSReal = { sub (2, 1) (4, 1) q }

def i_(q: Quaternion) -> <Real> = { find (2, 1) (im q) }
def j_(q: Quaternion) -> <Real> = { find (3, 1) (im q) }
def k_(q: Quaternion) -> <Real> = { find (4, 1) (im q) }

def quatConj(q: Quaternion) -> Quaternion = {
  mkQuaternion (re q) (-(im q))
}

def quatProd(p: Quaternion, q: Quaternion) -> Quaternion = {
  def p_0 = _re p;
  def pp = im p;
  def q_0 = _re q;
  def qq = im q;
  hconcat (p_0 * q_0 - (tr pp) * qq) (qq * p_0 + pp * q_0 + (ss pp) * qq)
}
