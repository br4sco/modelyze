/*
Modeling Kernel Language (Modelyze) library
Copyright (C) 2010-2012 David Broman

Modelyze library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Modelyze library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Modelyze library.  If not, see <http://www.gnu.org/licenses/>.

written by Oscar Eriksson oerikss@kth.se
*/

include MEBMLANG
include Numsolvers
include simoutput

type SimState = (Equations, Set(Equations), VMap, VMap, (Real, Int))

def simulateDebug(m: Equations, t0: Real, h: Real, tend: Real,
  monitored: [(<Real>, String)]) -> () = {

  def probes = map (fun e: (<Real>, String) -> fst e) monitored;
  def labels = map (fun e: (<Real>, String) -> snd e) monitored;

  def printSimHeader = (fun thunk: () -> {
    def _ = print "time";
    def _ = map (fun l: String -> print ("\t" ++ l)) labels;
    print "\n"
  });

  def printSimResult(isD: (<Real> -> Bool), ev: (<Real> -> Real),
    t: Real) -> () = {

    def f(e: <Real>) -> () = {
      def _ =  print "\t";
      if isD e then print (real2string (ev e))
      else print "?"
    };

    def _ = print (real2string t);
    def _ = map f probes;
    print "\n"
  };

  def consCheck(ivp: IVP) -> (Bool, VMap, Real) = {
    def llog = logger "consCheck" DEBUG;

    def (E, vm, t) = ivp;
    def (nvm, nt) = findiv ivp;

    def p(e: (<Real>, Real)) -> Bool = {
      def (x, v) = e;
      if isDefined nvm x then abs ((find x nvm) - v) < CONSISTLIM else true
    };

    def c = forAll p (Map.toList vm);
    def _ = llog "guess" vm;
    def _ = llog "actual" nvm;
    def _ = llog "close enough?" c;

    (c, nvm, nt)
  };

  def ctsim(ss: SimState)
    -> SimState = {

    def llog = logger "ctsim";

    def (m, E, ll, rl, (nt1, _)) = ss;
    def _ = llog DEBUG "here we are in continous land!" rl;
    def _ = llog DEBUG "with the following model" (setToCont E);
    def _ = llog DEBUG "and the time is" nt1;
    def P = gatherregs m;

    // Setup the DAE Solver
    def (resf, nroots, rootf, yy1, yp1, vids, ukm, zcm) =
      getDAESolverInput (E, rl, nt1) P INFINITE;
    def yy0 = (Array.make (Array.length yy1) INFINITE);
    def yp0 = (Array.make (Array.length yp1) INFINITE);
    def t0 = INFINITE;
    def s = (DAESolver.initWithRootf resf nroots rootf nt1 yy1 yp1);
    def _ = (DAESolver.setStopTime s tend);

    def psr(yy: {Real}, yp: {Real}) = printSimResult (isDefinedUkMap ukm)
      (fun e: <Real> -> evalFromArrays e ukm yy yp);

    // And then solve!
    def go(sr: SolverResult, t0: Real, yy0: {Real}, yp0: {Real},
      t1: Real, yy1: {Real}, yp1: {Real})
        -> (SolverResult, Real, {Real}, {Real}, {Real}, {Real}) = {

      def findLeftLimit(nyy0: {Real}, nyp0: {Real}) -> Real = {
        def llog = logger "findLeftLimit" TRACE;
        def e = 1.e-10;
        def _ = (DAESolver.reinit s t0 yy0 yp0);

        def work(t: Real) -> Real = {
          def _ = llog "t" t;
          if (t1 - t > e) then {
            def (tc, sr) = (DAESolver.solveNormal s t nyy0 nyp0);
            if sr != DAE_SOLVER_RESULT_ROOTS_FOUND then {
              work (t + (t1 - t) / 2.)
            } else {
              def _ = (DAESolver.reinit s t0 yy0 yp0);
              def (pt, _) = (DAESolver.solveNormal s (2. * t - t1) nyy0 nyp0);
              pt
            }
          } else t
        };

        work (t0 + (t1 - t0) / 2.)
      };

      if sr == DAE_SOLVER_RESULT_SUCCESS then {
        def _ = psr yy1 yp1 t1;
        def (nt0, nsr) = (DAESolver.solveNormal s (t1 + h) yy0 yp0);
        go nsr t1 yy1 yp1 nt0 yy0 yp0
      } else {
        if sr == DAE_SOLVER_RESULT_ROOTS_FOUND then {
          def nyy0 = (Array.make (Array.length yy0) 0.);
          def nyp0 = (Array.make (Array.length yp0) 0.);
          def nt0 = findLeftLimit nyy0 nyp0;
          def _ = psr nyy0 nyp0 nt0;
          (sr, t1, nyy0, nyp0, yy1, yp1)
        } else {
          def _ = psr yy1 yp1 t1;
          (sr, t1, yy0, yp0, yy1, yp1)
        }
      }
    };

    def (sr, t, nyy0, nyp0, nyy1, nyp1) =
      go DAE_SOLVER_RESULT_SUCCESS t0 yy0 yp0 nt1 yy1 yp1;
    def nll = ukMapYyYpToVMap ukm nyy0 nyp0;
    def nrl = ukMapYyYpToVMap ukm nyy1 nyp1;
    (m, E, nll, nrl, (t, 0))
  };

  def dtsim(ss: SimState) -> SimState = {
    def llog = dlogger "dtsim" TRACE;

    def (m, _, ll, rl, (t, n)) = ss;

    def psr(vm: VMap, t: Real) -> () = {
      printSimResult (isDefined vm) (fun e: <Real> -> evalRealFromVMap e vm) t
    };

    def go(m: Equations, rl: VMap, n: Int) -> (Equations, VMap) = {

      def dh = 0.001;
      def k = 3.;
      def _ = (if n > 10 then error "Number of ticks exceeds 10" else ());

      def rl = evalinits m rl;
      def E = evalpres (elaborate m) ll;
      def ia = impulseApprox E ll rl dh;
      def rl = ivApprox E ia dh;
      def irl = combineImpIVApp ia rl (isImpulse ll ia rl dh k);

      if stable m irl then {
        if stable m rl then (m, addIEDerApprox ia rl (-dh))
        else go (elabsws m rl) rl (n + 1)
      } else go (elabsws m irl) ia (n + 1)
    };

    def (m, rl) = go (elabsws m rl) rl 0;
    def E = indexred (evalpres (elaborate m) ll);
    def (c, rl, t) = consCheck (E, rl, t);
    (m, E, ll, rl, (t, n))
  };

  def sim(m: Equations) -> () = {

    def chain(first: (SimState -> SimState),
      second: (SimState -> SimState), ss: SimState) -> SimState = {

      def (_, _, _, _, (t, _)) = ss;
      if t >= tend then ss
      else {
        def nss = first ss;
        chain second first nss
      }
    };

    def E = indexred (elaborate m);
    def g = evalinits m (Map.empty);
    def (_, iv, nt0) = consCheck (E, g, t0);
    def ss = (m, E, Map.empty, iv, (nt0, 0));
    def _  = chain ctsim dtsim ss;
    ()
  };

  def _ = printSimHeader ();
  sim m
}
